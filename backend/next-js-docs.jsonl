{"url": "https://nextjs.org/docs/app/getting-started/partial-prerendering", "content": "rtial PrerenderingPartial PrerenderingThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback on GitHub.Partial Prerendering (PPR) is a rendering strategy that allows you to combine static and dynamic content in the same route. This improves the initial page performance while still supporting personalized, dynamic data.\n\nWhen a user visits a route:\n\nThe server sends a shell containing the static content, ensuring a fast initial load.\nThe shell leaves holes for the dynamic content that will load in asynchronously.\nThe dynamic holes are streamed in parallel, reducing the overall load time of the page.\n\n\ud83c\udfa5 Watch: Why PPR and how it works \u2192 YouTube (10 minutes).\n\nHow does Partial Prerendering work?\n\nTo understand Partial Prerendering, it helps to be familiar with the rendering strategies available in Next.js.\nStatic Rendering\n\nWith Static Rendering, HTML is generated ahead of time\u2014either at build time or through revalidation. The result is cached and shared across users and requests.\nIn Partial Prerendering, Next.js prerenders a static shell for a route. This can include the layout and any other components that don't depend on request-time data.\nDynamic Rendering\n\nWith Dynamic Rendering, HTML is generated at request time. This allows you to serve personalized content based on request-time data.\nA component becomes dynamic if it uses the following APIs:\n\ncookies\nheaders\nconnection\ndraftMode\nsearchParams prop\nunstable_noStore\nfetch with { cache: 'no-store' }\n\nIn Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a Suspense boundary to wrap your component to defer rendering until runtime.\nSuspense\n\nReact Suspense is used to defer rendering parts of your application until some condition is met.\nIn Partial Prerendering, Suspense is used to mark dynamic boundaries in your component tree.\nAt build time, Next.js prerenders the static content and the fallback UI. The dynamic content is postponed until the user requests the route.\nWrapping a component in Suspense doesn't make the component itself dynamic (your API usage does), but rather Suspense is used as a boundary that encapsulates dynamic content and enable streaming\napp/page.jsimport { Suspense } from 'react'\nimport StaticComponent from './StaticComponent'\nimport DynamicComponent from './DynamicComponent'\nimport Fallback from './Fallback'\n\nexport const experimental_ppr = true\n\nexport default function Page() {\n  return (\n    <>\n      <StaticComponent />\n      <Suspense fallback={<Fallback />}>\n        <DynamicComponent />\n      </Suspense>\n    </>\n  )\n}\nStreaming\n\nStreaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.\n\nIn Partial Prerendering, dynamic components wrapped in Suspense start streaming from the server in parallel.\n\nTo reduce network overhead, the full response\u2014including static HTML and streamed dynamic parts\u2014is sent in a single HTTP request. This avoids extra roundtrips and improves both initial load and overall performance.\nEnabling Partial Prerendering\n\nYou can enable PPR by adding the ppr option to your next.config.ts file:\nnext.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    ppr: 'incremental',\n  },\n}\n\nexport default nextConfig\n\nThe 'incremental' value allows you to adopt PPR for specific routes:\n/app/dashboard/layout.tsxexport const experimental_ppr = true\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  // ...\n}\n/app/dashboard/layout.jsexport const experimental_ppr = true\n\nexport default function Layout({ children }) {\n  // ...\n}\nRoutes that don't have experimental_ppr will default to false and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route.\n\nGood to know:\n\nexperimental_ppr will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route.\nTo disable PPR for children segments, you can set experimental_ppr to false in the child segment.\n\nExamples\n\nDynamic APIs\n\nWhen using Dynamic APIs that require looking at the incoming request, Next.js will opt into dynamic rendering for the route. To continue using PPR, wrap the component with Suspense. For example, the <User /> component is dynamic because it uses the cookies API:\n\napp/user.tsxTypeScriptJavaScriptTypeScriptimport { cookies } from 'next/headers'\n\nexport async function User() {\n  const session = (await cookies()).get('session')?.value\n  return '...'\n}\nThe <User /> component will be streamed while any other content inside <Page /> will be prerendered and become part of the static shell.\napp/page.tsxTypeScriptJavaScriptTypeScriptimport { Suspense } from 'react'\nimport { User, AvatarSkeleton } from './user'\n\nexport const experimental_ppr = true\n\nexport default function Page() {\n  return (\n    <section>\n      <h1>This will be prerendered</h1>\n      <Suspense fallback={<AvatarSkeleton />}>\n        <User />\n      </Suspense>\n    </section>\n  )\n}\n\nPassing dynamic props\n\nComponents only opt into dynamic rendering when the value is accessed. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop:\napp/page.tsxTypeScriptJavaScriptTypeScriptimport { Table, TableSkeleton } from './table'\nimport { Suspense } from 'react'\n\nexport default function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ sort: string }>\n}) {\n  return (\n    <section>\n      <h1>This will be prerendered</h1>\n      <Suspense fallback={<TableSkeleton />}>\n        <Table searchParams={searchParams} />\n      </Suspense>\n    </section>\n  )\n}\n\nInside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be prerendered.\napp/table.tsxTypeScriptJavaScriptTypeScriptexport async function Table({\n  searchParams,\n}: {\n  searchParams: Promise<{ sort: string }>\n}) {\n  const sort = (await searchParams).sort === 'true'\n  return '...'\n}\nNext StepsLearn more about the config option for Partial Prerendering.pprLearn how to enable Partial Prerendering in Next.js.PreviousServer and Client ComponentsNextFetching DataWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/fetching-data", "content": "tching DataFetching DataThis page will walk you through how you can fetch data in Server and Client Components, and how to stream components that depend on data.\nFetching data\n\nServer Components\n\nYou can fetch data in Server Components using:\n\nThe fetch API\nAn ORM or database\n\nWith the fetch API\n\nTo fetch data with the fetch API, turn your component into an asynchronous function, and await the fetch call. For example:\napp/blog/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts = await data.json()\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know:\n\nfetch responses are not cached by default. However, Next.js will prerender the route and the output will be cached for improved performance. If you'd like to opt into dynamic rendering, use the { cache: 'no-store' } option. See the fetch API Reference.\nDuring development, you can log fetch calls for better visibility and debugging. See the logging API reference.\n\nWith an ORM or database\n\nSince Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call:\napp/blog/page.tsxTypeScriptJavaScriptTypeScriptimport { db, posts } from '@/lib/db'\n\nexport default async function Page() {\n  const allPosts = await db.select().from(posts)\n  return (\n    <ul>\n      {allPosts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nClient Components\n\nThere are two ways to fetch data in Client Components, using:\n\nReact's use hook\nA community library like SWR or React Query\n\nStreaming data with the use hook\n\nYou can use React's use hook to stream data from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:\napp/blog/page.tsxTypeScriptJavaScriptTypeScriptimport Posts from '@/app/ui/posts\nimport { Suspense } from 'react'\n\nexport default function Page() {\n  // Don't await the data fetching function\n  const posts = getPosts()\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Posts posts={posts} />\n    </Suspense>\n  )\n}\n\nThen, in your Client Component, use the use hook to read the promise:\napp/ui/posts.tsxTypeScriptJavaScriptTypeScript'use client'\nimport { use } from 'react'\n\nexport default function Posts({\n  posts,\n}: {\n  posts: Promise<{ id: string; title: string }[]>\n}) {\n  const allPosts = use(posts)\n\n  return (\n    <ul>\n      {allPosts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nIn the example above, the <Posts> component is wrapped in a <Suspense> boundary. This means the fallback will be shown while the promise is being resolved. Learn more about streaming.\nCommunity libraries\n\nYou can use a community library like SWR or React Query to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:\napp/blog/page.tsxTypeScriptJavaScriptTypeScript'use client'\nimport useSWR from 'swr'\n\nconst fetcher = (url) => fetch(url).then((r) => r.json())\n\nexport default function BlogPage() {\n  const { data, error, isLoading } = useSWR(\n    'https://api.vercel.app/blog',\n    fetcher\n  )\n\n  if (isLoading) return <div>Loading...</div>\n  if (error) return <div>Error: {error.message}</div>\n\n  return (\n    <ul>\n      {data.map((post: { id: string; title: string }) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nDeduplicating requests with React.cache\n\nDeduplication is the process of preventing duplicate requests for the same resource during a render pass. It allows you to fetch the same data in different components while preventing multiple network requests to your data source.\nIf you are using fetch, requests can be deduplicated by adding cache: 'force-cache'. This means you can safely call the same URL with the same options, and only one request will be made.\nIf you are not using fetch, and instead using an ORM or database directly, you can wrap your data fetch with the React cache function.\napp/lib/data.tsTypeScriptJavaScriptTypeScriptimport { cache } from 'react'\nimport { db, posts, eq } from '@/lib/db'\n\nexport const getPost = cache(async (id: string) => {\n  const post = await db.query.posts.findFirst({\n    where: eq(posts.id, parseInt(id)),\n  })\n})\n\nStreaming\n\nWarning: The content below assumes the dynamicIO config option is enabled in your application. The flag was introduced in Next.js 15 canary.\n\nWhen using async/await in Server Components, Next.js will opt into dynamic rendering. This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.\nTo improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\n\nThere are two ways you can implement streaming in your application:\n\nWrapping a page with a loading.js file\nWrapping a component with <Suspense>\n\nWith loading.js\n\nYou can create a loading.js file in the same folder as your page to stream the entire page while the data is being fetched. For example, to stream app/blog/page.js, add the file inside the app/blog folder.\n\napp/blog/loading.tsxTypeScriptJavaScriptTypeScriptexport default function Loading() {\n  // Define the Loading UI here\n  return <div>Loading...</div>\n}\n\nOn navigation, the user will immediately see the layout and a loading state while the page is being rendered. The new content will then be automatically swapped in once rendering is complete.\n\nBehind-the-scenes, loading.js will be nested inside layout.js, and will automatically wrap the page.js file and any children below in a <Suspense> boundary.\n\nThis approach works well for route segments (layouts and pages), but for more granular streaming, you can use <Suspense>.\nWith <Suspense>\n\n<Suspense> allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the <Suspense> boundary, and stream in the list of blog posts inside the boundary.\napp/blog/page.tsxTypeScriptJavaScriptTypeScriptimport { Suspense } from 'react'\nimport BlogList from '@/components/BlogList'\nimport BlogListSkeleton from '@/components/BlogListSkeleton'\n\nexport default function BlogPage() {\n  return (\n    <div>\n      {/* This content will be sent to the client immediately */}\n      <header>\n        <h1>Welcome to the Blog</h1>\n        <p>Read the latest posts below.</p>\n      </header>\n      <main>\n        {/* Any content wrapped in a <Suspense> boundary will be streamed */}\n        <Suspense fallback={<BlogListSkeleton />}>\n          <BlogList />\n        </Suspense>\n      </main>\n    </div>\n  )\n}\n\nCreating meaningful loading states\n\nAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.\nIn development, you can preview and inspect the loading state of your components using the React Devtools.\nExamples\n\nSequential data fetching\n\nSequential data fetching happens when nested components in a tree each fetch their own data and the requests are not deduplicated, leading to longer response times.\n\nThere may be cases where you want this pattern because one fetch depends on the result of the other.\nFor example, the <Playlists> component will only start fetching data once the <Artist> component has finished fetching data because <Playlists> depends on the artistID prop:\napp/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page({\n  params,\n}: {\n  params: Promise<{ username: string }>\n}) {\n  const { username } = await params\n  // Get artist information\n  const artist = await getArtist(username)\n\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      {/* Show fallback UI while the Playlists component is loading */}\n      <Suspense fallback={<div>Loading...</div>}>\n        {/* Pass the artist ID to the Playlists component */}\n        <Playlists artistID={artist.id} />\n      </Suspense>\n    </>\n  )\n}\n\nasync function Playlists({ artistID }: { artistID: string }) {\n  // Use the artist ID to fetch playlists\n  const playlists = await getArtistPlaylists(artistID)\n\n  return (\n    <ul>\n      {playlists.map((playlist) => (\n        <li key={playlist.id}>{playlist.name}</li>\n      ))}\n    </ul>\n  )\n}\n\nTo improve the user experience, you should use React <Suspense> to show a fallback while data is being fetch. This will enable streaming and prevent the whole route from being blocked by the sequential data requests.\nParallel data fetching\n\nParallel data fetching happens when data requests in a route are eagerly initiated and start at the same time.\nBy default, layouts and pages are rendered in parallel. So each segment starts fetching data as soon as possible.\nHowever, within any component, multiple async/await requests can still be sequential if placed after the other. For example, getAlbums will be blocked until getArtist is resolved:\napp/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptimport { getArtist, getAlbums } from '@/app/lib/data'\n\nexport default async function Page({ params }) {\n  // These requests will be sequential\n  const { username } = await params\n  const artist = await getArtist(username)\n  const albums = await getAlbums(username)\n  return <div>{artist.name}</div>\n}\nYou can initiate requests in parallel by defining them outside the components that use the data, and resolving them together, for example, with Promise.all:\napp/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptimport Albums from './albums'\n\nasync function getArtist(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}`)\n  return res.json()\n}\n\nasync function getAlbums(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n  return res.json()\n}\n\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ username: string }>\n}) {\n  const { username } = await params\n  const artistData = getArtist(username)\n  const albumsData = getAlbums(username)\n\n  // Initiate both requests in parallel\n  const [artist, albums] = await Promise.all([artistData, albumsData])\n\n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums} />\n    </>\n  )\n}\n\nGood to know: If one request fails when using Promise.all, the entire operation will fail. To handle this, you can use the Promise.allSettled method instead.\n\nPreloading data\n\nYou can preload data by creating an utility function that you eagerly call above blocking requests. <Item> conditionally renders based on the checkIsAvailable() function.\nYou can call preload() before checkIsAvailable() to eagerly initiate <Item/> data dependencies. By the time <Item/> is rendered, its data has already been fetched.\napp/item/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport { getItem } from '@/lib/data'\n\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  // starting loading item data\n  preload(id)\n  // perform another asynchronous task\n  const isAvailable = await checkIsAvailable()\n\n  return isAvailable ? <Item id={id} /> : null\n}\n\nexport const preload = (id: string) => {\n  // void evaluates the given expression and returns undefined\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n  void getItem(id)\n}\nexport async function Item({ id }: { id: string }) {\n  const result = await getItem(id)\n  // ...\n}\n\nAdditionally, you can use React's cache function and the server-only package to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.\nutils/get-item.tsTypeScriptJavaScriptTypeScriptimport { cache } from 'react'\nimport 'server-only'\nimport { getItem } from '@/lib/data'\n\nexport const preload = (id: string) => {\n  void getItem(id)\n}\n\nexport const getItem = cache(async (id: string) => {\n  // ...\n})\nAPI ReferenceLearn more about the features mentioned in this page by reading the API Reference.Data SecurityLearn the built-in data security features in Next.js and learn best practices for protecting your application's data.fetchAPI reference for the extended fetch function.loading.jsAPI reference for the loading.js file.loggingConfigure how data fetches are logged to the console when running Next.js in development mode.taintEnable tainting Objects and Values.PreviousPartial PrerenderingNextUpdating DataWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/updating-data", "content": "dating DataUpdating DataYou can update data in Next.js using React's Server Functions. This page will go through how you can create and invoke Server Functions.\nWhat are Server Functions?\n\nA Server Function is an asynchronous function that runs on the server. They can be called from client through a network request, which is why they must be asynchronous.\nIn an action or mutation context, they are also called Server Actions.\nBy convention, a Server Action is an async function used with startTransition. This happens automatically when the function is:\n\nPassed to a <form> using the action prop.\nPassed to a <button> using the formAction prop.\n\nIn Next.js, Server Actions integrate with the framework's caching architecture. When an action is invoked, Next.js can return both the updated UI and new data in a single server roundtrip.\nBehind the scenes, actions use the POST method, and only this HTTP method can invoke them.\nCreating Server Functions\n\nA Server Function can be defined by using the use server directive. You can place the directive at the top of an asynchronous function to mark the function as a Server Function, or at the top of a separate file to mark all exports of that file.\napp/lib/actions.tsTypeScriptJavaScriptTypeScriptexport async function createPost(formData: FormData) {\n  'use server'\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // Update data\n  // Revalidate cache\n}\n\nexport async function deletePost(formData: FormData) {\n  'use server'\n  const id = formData.get('id')\n\n  // Update data\n  // Revalidate cache\n}\n\nServer Components\n\nServer Functions can be inlined in Server Components by adding the \"use server\" directive to the top of the function body:\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() {\n  // Server Action\n  async function createPost(formData: FormData) {\n    'use server'\n    // ...\n  }\n\n  return <></>\n}\n\nGood to know: Server Components support progressive enhancement by default, meaning forms that call Server Actions will be submitted even if JavaScript hasn't loaded yet or is disabled.\n\nClient Components\n\nIt's not possible to define Server Functions in Client Components. However, you can invoke them in Client Components by importing them from a file that has the \"use server\" directive at the top of it:\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nexport async function createPost() {}\n\napp/ui/button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { createPost } from '@/app/actions'\n\nexport function Button() {\n  return <button formAction={createPost}>Create</button>\n}\n\nGood to know: In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, and will be prioritized for hydration. After hydration, the browser does not refresh on form submission.\n\nPassing actions as props\n\nYou can also pass an action to a Client Component as a prop:\n<ClientComponent updateItemAction={updateItem} />\napp/client-component.tsxTypeScriptJavaScriptTypeScript'use client'\n\nexport default function ClientComponent({\n  updateItemAction,\n}: {\n  updateItemAction: (formData: FormData) => void\n}) {\n  return <form action={updateItemAction}>{/* ... */}</form>\n}\n\nInvoking Server Functions\n\nThere are two main ways you can invoke a Server Function:\n\nForms in Server and Client Components\nEvent Handlers and useEffect in Client Components\n\nForms\n\nReact extends the HTML <form> element to allow Server Function to be invoked with the HTML action prop.\nWhen invoked in a form, the function automatically receives the FormData object. You can extract the data using the native FormData methods:\napp/ui/form.tsxTypeScriptJavaScriptTypeScriptimport { createPost } from '@/app/actions'\n\nexport function Form() {\n  return (\n    <form action={createPost}>\n      <input type=\"text\" name=\"title\" />\n      <input type=\"text\" name=\"content\" />\n      <button type=\"submit\">Create</button>\n    </form>\n  )\n}\n\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // Update data\n  // Revalidate cache\n}\n\nEvent Handlers\n\nYou can invoke a Server Function in a Client Component by using event handlers such as onClick.\napp/like-button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { incrementLike } from './actions'\nimport { useState } from 'react'\n\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\n  const [likes, setLikes] = useState(initialLikes)\n\n  return (\n    <>\n      <p>Total Likes: {likes}</p>\n      <button\n        onClick={async () => {\n          const updatedLikes = await incrementLike()\n          setLikes(updatedLikes)\n        }}\n      >\n        Like\n      </button>\n    </>\n  )\n}\n\nExamples\n\nShowing a pending state\n\nWhile executing a Server Function, you can show a loading indicator with React's useActionState hook. This hook returns a pending boolean:\napp/ui/button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useActionState, startTransition } from 'react'\nimport { createPost } from '@/app/actions'\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\n\nexport function Button() {\n  const [state, action, pending] = useActionState(createPost, false)\n\n  return (\n    <button onClick={() => startTransition(action)}>\n      {pending ? <LoadingSpinner /> : 'Create Post'}\n    </button>\n  )\n}\n\nRevalidating\n\nAfter performing an update, you can revalidate the Next.js cache and show the updated data by calling revalidatePath or revalidateTag within the Server Function:\napp/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidatePath } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  // Update data\n  // ...\n\n  revalidatePath('/posts')\n}\n\nRedirecting\n\nYou may want to redirect the user to a different page after performing an update. You can do this by calling redirect within the Server Function:\napp/lib/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  // Update data\n  // ...\n\n  redirect('/posts')\n}\n\nCookies\n\nYou can get, set, and delete cookies inside a Server Action using the cookies API:\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { cookies } from 'next/headers'\n\nexport async function exampleAction() {\n  const cookieStore = await cookies()\n\n  // Get cookie\n  cookieStore.get('name')?.value\n\n  // Set cookie\n  cookieStore.set('name', 'Delba')\n\n  // Delete cookie\n  cookieStore.delete('name')\n}\n\nuseEffect\n\nYou can use the React useEffect hook to invoke a Server Action when the component mounts or a dependency changes. This is useful for mutations that depend on global events or need to be triggered automatically. For example, onKeyDown for app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:\napp/view-count.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { incrementViews } from './actions'\nimport { useState, useEffect, useTransition } from 'react'\n\nexport default function ViewCount({ initialViews }: { initialViews: number }) {\n  const [views, setViews] = useState(initialViews)\n  const [isPending, startTransition] = useTransition()\n\n  useEffect(() => {\n    startTransition(async () => {\n      const updatedViews = await incrementViews()\n      setViews(updatedViews)\n    })\n  }, [])\n\n  // You can use `isPending` to give users feedback\n  return <p>Total Views: {views}</p>\n}\nAPI ReferenceLearn more about the features mentioned in this page by reading the API Reference.revalidatePathAPI Reference for the revalidatePath function.revalidateTagAPI Reference for the revalidateTag function.redirectAPI Reference for the redirect function.PreviousFetching DataNextCaching and RevalidatingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/caching-and-revalidating", "content": "ching and RevalidatingCaching and RevalidatingCaching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application.\nNext.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them.\n\nfetch\nunstable_cache\nrevalidatePath\nrevalidateTag\n\nfetch\n\nBy default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'.\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  const data = await fetch('https://...', { cache: 'force-cache' })\n}\n\nGood to know: Although fetch requests are not cached by default, Next.js will prerender routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API.\n\nTo revalidate the data returned by a fetch request, you can use the next.revalidate option.\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  const data = await fetch('https://...', { next: { revalidate: 3600 } })\n}\n\nThis will revalidate the data after a specified amount of seconds.\nSee the fetch API reference to learn more.\nunstable_cache\n\nunstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example:\nimport { db } from '@/lib/db'\nexport async function getUserById(id: string) {\n  return db\n    .select()\n    .from(users)\n    .where(eq(users.id, id))\n    .then((res) => res[0])\n}\n\napp/page.tsxTypeScriptJavaScriptTypeScriptimport { unstable_cache } from 'next/cache'\nimport { getUserById } from '@/app/lib/data'\n\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ userId: string }>\n}) {\n  const { userId } = await params\n\n  const getCachedUser = unstable_cache(\n    async () => {\n      return getUserById(userId)\n    },\n    [userId] // add the user ID to the cache key\n  )\n}\n\nThe function accepts a third optional object to define how the cache should be revalidated. It accepts:\n\ntags: an array of tags used by Next.js to revalidate the cache.\nrevalidate: the number of seconds after cache should be revalidated.\n\napp/page.tsxTypeScriptJavaScriptTypeScriptconst getCachedUser = unstable_cache(\n  async () => {\n    return getUserById(userId)\n  },\n  [userId],\n  {\n    tags: ['user'],\n    revalidate: 3600,\n  }\n)\n\nSee the unstable_cache API reference to learn more.\nrevalidateTag\n\nrevalidateTag is used to revalidate a cache entries based on a tag and following an event. To use it with fetch, start by tagging the function with the next.tags option:\napp/lib/data.tsTypeScriptJavaScriptTypeScriptexport async function getUserById(id: string) {\n  const data = await fetch(`https://...`, {\n    next: {\n      tags: ['user'],\n    },\n  })\n}\n\nAlternatively, you can mark an unstable_cache function with the tags option:\napp/lib/data.tsTypeScriptJavaScriptTypeScriptexport const getUserById = unstable_cache(\n  async (id: string) => {\n    return db.query.users.findFirst({ where: eq(users.id, id) })\n  },\n  ['user'], // Needed if variables are not passed as parameters\n  {\n    tags: ['user'],\n  }\n)\n\nThen, call revalidateTag in a Route Handler or Server Action:\napp/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidateTag } from 'next/cache'\n\nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidateTag('user')\n}\n\nYou can reuse the same tag in multiple functions to revalidate them all at once.\nSee the revalidateTag API reference to learn more.\nrevalidatePath\n\nrevalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action:\napp/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidatePath } from 'next/cache'\n\nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidatePath('/profile')\n\nSee the revalidatePath API reference to learn more.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.fetchAPI reference for the extended fetch function.unstable_cacheAPI Reference for the unstable_cache function.revalidatePathAPI Reference for the revalidatePath function.revalidateTagAPI Reference for the revalidateTag function.PreviousUpdating DataNextError HandlingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/error-handling", "content": "ror HandlingError HandlingErrors can be divided into two categories: expected errors and uncaught exceptions. This page will walk you through how you can handle these errors in your Next.js application.\nHandling expected errors\n\nExpected errors are those that can occur during the normal operation of the application, such as those from server-side form validation or failed requests. These errors should be handled explicitly and returned to the client.\nServer Functions\n\nYou can use the useActionState hook to handle expected errors in Server Functions.\nFor these errors, avoid using try/catch blocks and throw errors. Instead, model expected errors as return values.\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nexport async function createPost(prevState: any, formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  const res = await fetch('https://api.vercel.app/posts', {\n    method: 'POST',\n    body: { title, content },\n  })\n  const json = await res.json()\n\n  if (!res.ok) {\n    return { message: 'Failed to create post' }\n  }\n}\n\nYou can pass your action to the useActionState hook and use the returned state to display an error message.\napp/ui/form.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useActionState } from 'react'\nimport { createPost } from '@/app/actions'\n\nconst initialState = {\n  message: '',\n}\n\nexport function Form() {\n  const [state, formAction, pending] = useActionState(createPost, initialState)\n\n  return (\n    <form action={formAction}>\n      <label htmlFor=\"title\">Title</label>\n      <input type=\"text\" id=\"title\" name=\"title\" required />\n      <label htmlFor=\"content\">Content</label>\n      <textarea id=\"content\" name=\"content\" required />\n      {state?.message && <p aria-live=\"polite\">{state.message}</p>}\n      <button disabled={pending}>Create Post</button>\n    </form>\n  )\n}\n\nServer Components\n\nWhen fetching data inside of a Server Component, you can use the response to conditionally render an error message or redirect.\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  const res = await fetch(`https://...`)\n  const data = await res.json()\n\n  if (!res.ok) {\n    return 'There was an error.'\n  }\n\n  return '...'\n}\n\nNot found\n\nYou can call the notFound function within a route segment and use the not-found.js file to show a 404 UI.\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptimport { getPostBySlug } from '@/lib/posts'\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const { slug } = await params\n  const post = getPostBySlug(slug)\n\n  if (!post) {\n    notFound()\n  }\n\n  return <div>{post.title}</div>\n}\n\napp/blog/[slug]/not-found.tsxTypeScriptJavaScriptTypeScriptexport default function NotFound() {\n  return <div>404 - Page Not Found</div>\n}\n\nHandling uncaught exceptions\n\nUncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries.\nNested error boundaries\n\nNext.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed.\nCreate an error boundary by adding an error.js file inside a route segment and exporting a React component:\napp/dashboard/error.tsxTypeScriptJavaScriptTypeScript'use client' // Error boundaries must be Client Components\n\nimport { useEffect } from 'react'\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  useEffect(() => {\n    // Log the error to an error reporting service\n    console.error(error)\n  }, [error])\n\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button\n        onClick={\n          // Attempt to recover by trying to re-render the segment\n          () => reset()\n        }\n      >\n        Try again\n      </button>\n    </div>\n  )\n}\n\nErrors will bubble up to the nearest parent error boundary. This allows for granular error handling by placing error.tsx files at different levels in the route hierarchy.\n\nGlobal errors\n\nWhile less common, you can handle errors in the root layout using the global-error.js file, located in the root app directory, even when leveraging internationalization. Global error UI must define its own <html> and <body> tags, since it is replacing the root layout or template when active.\napp/global-error.tsxTypeScriptJavaScriptTypeScript'use client' // Error boundaries must be Client Components\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    // global-error must include html and body tags\n    <html>\n      <body>\n        <h2>Something went wrong!</h2>\n        <button onClick={() => reset()}>Try again</button>\n      </body>\n    </html>\n  )\n}\nAPI ReferenceLearn more about the features mentioned in this page by reading the API Reference.redirectAPI Reference for the redirect function.error.jsAPI reference for the error.js special file.notFoundAPI Reference for the notFound function.not-found.jsAPI reference for the not-found.js file.PreviousCaching and RevalidatingNextCSSWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/css", "content": "SCSSNext.js provides several ways to style your application using CSS, including:\n\nCSS Modules\nGlobal CSS\nExternal Stylesheets\nTailwind CSS\nSass\nCSS-in-JS\n\nCSS Modules\n\nCSS Modules locally scope CSS by generating unique class names. This allows you to use the same class in different files without worrying about naming collisions.\nTo start using CSS Modules, create a new file with the extension .module.css and import it into any component inside the app directory:app/blog/blog.module.css.blog {\n  padding: 24px;\n}app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport styles from './blog.module.css'\n\nexport default function Page() {\n  return <main className={styles.blog}></main>\n}\n\nGlobal CSS\n\nYou can use global CSS to apply styles across your application.\nCreate a app/global.css file and import it in the root layout to apply the styles to every route in your application:app/global.cssbody {\n  padding: 20px 20px 60px;\n  max-width: 680px;\n  margin: 0 auto;\n}app/layout.tsxTypeScriptJavaScriptTypeScript// These styles apply to every route in the application\nimport './global.css'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\nGood to know: Global styles can be imported into any layout, page, or component inside the app directory. However, since Next.js uses React's built-in support for stylesheets to integrate with Suspense, this currently does not remove stylesheets as you navigate between routes which can lead to conflicts. We recommend using global styles for truly global CSS, and CSS Modules for scoped CSS.\n\nExternal stylesheets\n\nStylesheets published by external packages can be imported anywhere in the app directory, including colocated components:app/layout.tsxTypeScriptJavaScriptTypeScriptimport 'bootstrap/dist/css/bootstrap.css'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body className=\"container\">{children}</body>\n    </html>\n  )\n}\nGood to know: In React 19, <link rel=\"stylesheet\" href=\"...\" /> can also be used. See the React link documentation for more information.\n\nOrdering and Merging\n\nNext.js optimizes CSS during production builds by automatically chunking (merging) stylesheets. The order of your CSS depends on the order you import styles in your code.\nFor example, base-button.module.css will be ordered before page.module.css since <BaseButton> is imported before page.module.css:\npage.tsTypeScriptJavaScriptTypeScriptimport { BaseButton } from './base-button'\nimport styles from './page.module.css'\n\nexport default function Page() {\n  return <BaseButton className={styles.primary} />\n}\n\nbase-button.tsxTypeScriptJavaScriptTypeScriptimport styles from './base-button.module.css'\n\nexport function BaseButton() {\n  return <button className={styles.primary} />\n}\n\nRecommendations\n\nTo keep CSS ordering predictable:\n\nTry to contain CSS imports to a single JavaScript or TypeScript entry file\nImport global styles and Tailwind stylesheets in the root of your application.\nUse CSS Modules instead of global styles for nested components.\nUse a consistent naming convention for your CSS modules. For example, using <name>.module.css over <name>.tsx.\nExtract shared styles into shared components to avoid duplicate imports.\nTurn off linters or formatters that auto-sort imports like ESLint\u2019s sort-imports.\nYou can use the cssChunking option in next.config.js to control how CSS is chunked.\n\nDevelopment vs Production\n\nIn development (next dev), CSS updates apply instantly with Fast Refresh.\nIn production (next build), all CSS files are automatically concatenated into many minified and code-split .css files, ensuring the minimal amount of CSS is loaded for a route.\nCSS still loads with JavaScript disabled in production, but JavaScript is required in development for Fast Refresh.\nCSS ordering can behave differently in development, always ensure to check the build (next build) to verify the final CSS order.\nNext StepsLearn more about the alternatives ways you can use CSS in your application.Tailwind CSSStyle your Next.js Application using Tailwind CSS.SassStyle your Next.js application using Sass.CSS-in-JSUse CSS-in-JS libraries with Next.jsPreviousError HandlingNextImage OptimizationWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/images", "content": "age OptimizationImage OptimizationThe Next.js <Image> component extends the HTML <img> element to provide:\n\nSize optimization: Automatically serving correctly sized images for each device, using modern image formats like WebP.\nVisual stability: Preventing layout shift automatically when images are loading.\nFaster page loads: Only loading images when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.\nAsset flexibility: Resizing images on-demand, even images stored on remote servers.\n\nTo start using <Image>, import it from next/image and render it within your component.\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Image from 'next/image'\n\nexport default function Page() {\n  return <Image src=\"\" alt=\"\" />\n}\n\nThe src property can be a local or remote image.\n\n\ud83c\udfa5 Watch: Learn more about how to use next/image \u2192 YouTube (9 minutes).\n\nLocal images\n\nYou can store static files, like images and fonts, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/).\n\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Image from 'next/image'\n\nexport default function Page() {\n  return (\n    <Image\n      src=\"/profile.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n\nIf the image is statically imported, Next.js will automatically determine the intrinsic width and height. These values are used to determine the image ratio and prevent Cumulative Layout Shift while your image is loading.\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Image from 'next/image'\nimport ProfileImage from './profile.png'\n\nexport default function Page() {\n  return (\n    <Image\n      src={ProfileImage}\n      alt=\"Picture of the author\"\n      // width={500} automatically provided\n      // height={500} automatically provided\n      // blurDataURL=\"data:...\" automatically provided\n      // placeholder=\"blur\" // Optional blur-up while loading\n    />\n  )\n}\n\nRemote images\n\nTo use a remote image, you can provide a URL string for the src property.\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Image from 'next/image'\n\nexport default function Page() {\n  return (\n    <Image\n      src=\"https://s3.amazonaws.com/my-bucket/profile.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n\nSince Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually. The width and height are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. Alternatively, you can use the fill property to make the image fill the size of the parent element.\nTo safely allow images from remote servers, you need to define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:\nnext.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next'\n\nconst config: NextConfig = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 's3.amazonaws.com',\n        port: '',\n        pathname: '/my-bucket/**',\n        search: '',\n      },\n    ],\n  },\n}\n\nexport default config\nAPI ReferenceSee the API Reference for the full feature set of Next.js Image.Image ComponentOptimize Images in your Next.js Application using the built-in `next/image` Component.PreviousCSSNextFont OptimizationWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/fonts", "content": "nt OptimizationFont OptimizationThe next/font module automatically optimizes your fonts and removes external network requests for improved privacy and performance.\nIt includes built-in self-hosting for any font file. This means you can optimally load web fonts with no layout shift.\nTo start using next/font, import it from next/font/local or next/font/google, call it as a function with the appropriate options, and set the className of the element you want to apply the font to. For example:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport { Geist } from 'next/font/google'\n\nconst geist = Geist({\n  subsets: ['latin'],\n})\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" className={geist.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nFonts are scoped to the component they're used in. To apply a font to your entire application, add it to the Root Layout.\nGoogle fonts\n\nYou can automatically self-host any Google Font. Fonts are included stored as static assets and served from the same domain as your deployment, meaning no requests are sent to Google by the browser when the user visits your site.\nTo start using a Google Font, import your chosen font from next/font/google:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport { Geist } from 'next/font/google'\n\nconst geist = Geist({\n  subsets: ['latin'],\n})\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={geist.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nWe recommend using variable fonts for the best performance and flexibility. But if you can't use a variable font, you will need to specify a weight:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport { Roboto } from 'next/font/google'\n\nconst roboto = Roboto({\n  weight: '400',\n  subsets: ['latin'],\n})\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={roboto.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nLocal fonts\n\nTo use a local font, import your font from next/font/local and specify the src of your local font file. Fonts can be stored in the public folder or co-located inside the app folder. For example:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport localFont from 'next/font/local'\n\nconst myFont = localFont({\n  src: './my-font.woff2',\n})\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" className={myFont.className}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nIf you want to use multiple files for a single font family, src can be an array:\nconst roboto = localFont({\n  src: [\n    {\n      path: './Roboto-Regular.woff2',\n      weight: '400',\n      style: 'normal',\n    },\n    {\n      path: './Roboto-Italic.woff2',\n      weight: '400',\n      style: 'italic',\n    },\n    {\n      path: './Roboto-Bold.woff2',\n      weight: '700',\n      style: 'normal',\n    },\n    {\n      path: './Roboto-BoldItalic.woff2',\n      weight: '700',\n      style: 'italic',\n    },\n  ],\n})API ReferenceSee the API Reference for the full feature set of Next.js FontFontOptimizing loading web fonts with the built-in `next/font` loaders.PreviousImage OptimizationNextMetadata and OG imagesWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/metadata-and-og-images", "content": "tadata and OG imagesMetadata and OG imagesThe Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include:\n\nThe static metadata object\nThe dynamic generateMetadata function\nSpecial file conventions that can be used to add static or dynamically generated favicons and OG images.\n\nWith all the options above, Next.js will automatically generate the relevant <head> tags for your page, which can be inspected in the browser's developer tools.\nDefault fields\n\nThere are two default meta tags that are always added even if a route doesn't define metadata:\n\nThe meta charset tag sets the character encoding for the website.\nThe meta viewport tag sets the viewport width and scale for the website to adjust for different devices.\n\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\nThe other metadata fields can be defined with the Metadata object (for static metadata) or the generateMetadata function (for generated metadata).\nStatic metadata\n\nTo define static metadata, export a Metadata object from a static layout.js or page.js file. For example, to add a title and description to the blog route:\napp/blog/layout.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My Blog',\n  description: '...',\n}\n\nexport default function Page() {}\n\nYou can view a full list of available options, in the generateMetadata documentation.\nGenerated metadata\n\nYou can use generateMetadata function to fetch metadata that depends on data. For example, to fetch the title and description for a specific blog post:\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata, ResolvingMetadata } from 'next'\n\ntype Props = {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n\nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  const slug = (await params).slug\n\n  // fetch post information\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>\n    res.json()\n  )\n\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n\nexport default function Page({ params, searchParams }: Props) {}\n\nStreaming metadata\n\nFor dynamically rendered pages, if resolving generateMetadata might block rendering, Next.js streams the resolved metadata separately and injects it into the HTML as soon as it's ready.\nStatically rendered pages don\u2019t use this behavior since metadata is resolved at build time.\nLearn more about streaming metadata.\nMemoizing data requests\n\nThere may be cases where you need to fetch the same data for metadata and the page itself. To avoid duplicate requests, you can use React's cache function to memoize the return value and only fetch the data once. For example, to fetch the blog post information for both the metadata and the page:\napp/lib/data.tsTypeScriptJavaScriptTypeScriptimport { cache } from 'react'\nimport { db } from '@/app/lib/db'\n\n// getPost will be used twice, but execute only once\nexport const getPost = cache(async (slug: string) => {\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })\n  return res\n})\n\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptimport { getPost } from '@/app/lib/data'\n\nexport async function generateMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  const post = await getPost(params.slug)\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n  return <div>{post.title}</div>\n}\n\nFile-based metadata\n\nThe following special files are available for metadata:\n\nfavicon.ico, apple-icon.jpg, and icon.jpg\nopengraph-image.jpg and twitter-image.jpg\nrobots.txt\nsitemap.xml\n\nYou can use these for static metadata, or you can programmatically generate these files with code.\nFavicons\n\nFavicons are small icons that represent your site in bookmarks and search results. To add a favicon to your application, create a favicon.ico and add to the root of the app folder.\n\nYou can also programmatically generate favicons using code. See the favicon docs for more information.\n\nStatic Open Graph images\n\nOpen Graph (OG) images are images that represent your site in social media. To add a static OG image to your application, create a opengraph-image.png file in the root of the app folder.\n\nYou can also add OG images for specific routes by creating a opengraph-image.png deeper down the folder structure. For example, to create an OG image specific to the /blog route, add a opengraph-image.jpg file inside the blog folder.\n\nThe more specific image will take precedence over any OG images above it in the folder structure.\n\nOther image formats such as jpeg, png, and webp are also supported. See the Open Graph Image docs for more information.\n\nGenerated Open Graph images\n\nThe ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for OG images that depend on data.\nFor example, to generate a unique OG image for each blog post, add a opengraph-image.ts file inside the blog folder, and import the ImageResponse constructor from next/og:\napp/blog/[slug]/opengraph-image.tsTypeScriptJavaScriptTypeScriptimport { ImageResponse } from 'next/og'\nimport { getPost } from '@/app/lib/data'\n\n// Image metadata\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n\nexport const contentType = 'image/png'\n\n// Image generation\nexport default async function Image({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n\n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        {post.title}\n      </div>\n    )\n  )\n}\n\nImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images. See the full list of supported CSS properties.\n\nGood to know:\n\nExamples are available in the Vercel OG Playground.\nImageResponse uses @vercel/og, satori, and resvg to convert HTML and CSS into PNG.\nOnly flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work.\n\nAPI ReferenceLearn more about the Metadata APIs mentioned in this page.generateMetadataLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.generateViewportAPI Reference for the generateViewport function.ImageResponseAPI Reference for the ImageResponse constructor.Metadata FilesAPI documentation for the metadata file conventions.favicon, icon, and apple-iconAPI Reference for the Favicon, Icon and Apple Icon file conventions.opengraph-image and twitter-imageAPI Reference for the Open Graph Image and Twitter Image file conventions.robots.txtAPI Reference for robots.txt file.sitemap.xmlAPI Reference for the sitemap.xml file.PreviousFont OptimizationNextRoute Handlers and MiddlewareWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/route-handlers-and-middleware", "content": "ute Handlers and MiddlewareRoute Handlers and MiddlewareRoute Handlers\n\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.\n\nGood to know: Route Handlers are only available inside the app directory. They are the equivalent of API Routes inside the pages directory meaning you do not need to use API Routes and Route Handlers together.\n\nConvention\n\nRoute Handlers are defined in a route.js|ts file inside the app directory:\napp/api/route.tsTypeScriptJavaScriptTypeScriptexport async function GET(request: Request) {}\n\nRoute Handlers can be nested anywhere inside the app directory, similar to page.js and layout.js. But there cannot be a route.js file at the same route segment level as page.js.\nSupported HTTP Methods\n\nThe following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.\nExtended NextRequest and NextResponse APIs\n\nIn addition to supporting the native Request and Response APIs, Next.js extends them with NextRequest and NextResponse to provide convenient helpers for advanced use cases.\nCaching\n\nRoute Handlers are not cached by default. You can, however, opt into caching for GET methods. Other supported HTTP methods are not cached. To cache a GET method, use a route config option such as export const dynamic = 'force-static' in your Route Handler file.\napp/items/route.tsTypeScriptJavaScriptTypeScriptexport const dynamic = 'force-static'\n\nexport async function GET() {\n  const res = await fetch('https://data.mongodb-api.com/...', {\n    headers: {\n      'Content-Type': 'application/json',\n      'API-Key': process.env.DATA_API_KEY,\n    },\n  })\n  const data = await res.json()\n\n  return Response.json({ data })\n}\n\nGood to know: Other supported HTTP methods are not cached, even if they are placed alongside a GET method that is cached, in the same file.\n\nSpecial Route Handlers\n\nSpecial Route Handlers like sitemap.ts, opengraph-image.tsx, and icon.tsx, and other metadata files remain static by default unless they use Dynamic APIs or dynamic config options.\nRoute Resolution\n\nYou can consider a route the lowest level routing primitive.\n\nThey do not participate in layouts or client-side navigations like page.\nThere cannot be a route.js file at the same route as page.js.\n\nPageRouteResultapp/page.jsapp/route.js Conflictapp/page.jsapp/api/route.js Validapp/[user]/page.jsapp/api/route.js Valid\nEach route.js or page.js file takes over all HTTP verbs for that route.\napp/page.tsTypeScriptJavaScriptTypeScriptexport default function Page() {\n  return <h1>Hello, Next.js!</h1>\n}\n\n// \u274c Conflict\n// `app/route.ts`\nexport async function POST(request: Request) {}\n\nRead more about how Route Handlers complement your frontend application, or explore the Route Handlers API Reference.\nMiddleware\n\nMiddleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.\nUse cases\n\nSome common scenarios where Middleware is effective include:\n\nQuick redirects after reading parts of the incoming request\nRewriting to different pages based on A/B tests or experiments\nModifying headers for all pages or a subset of pages\n\nMiddleware is not a good fit for:\n\nSlow data fetching\nSession management\n\nUsing fetch with options.cache, options.next.revalidate, or options.next.tags, has no effect in Middleware.\nConvention\n\nUse the file middleware.ts (or .js) in the root of your project to define Middleware. For example, at the same level as pages or app, or inside src if applicable.\n\nNote: While only one middleware.ts file is supported per project, you can still organize your middleware logic into modules. Break out middleware functionalities into separate .ts or .js files and import them into your main middleware.ts file. This allows for cleaner management of route-specific middleware, aggregated in the middleware.ts for centralized control. By enforcing a single middleware file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple middleware layers.\n\nExample\n\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\n\n// This function can be marked `async` if using `await` inside\nexport function middleware(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n\n// See \"Matching Paths\" below to learn more\nexport const config = {\n  matcher: '/about/:path*',\n}\n\nRead more about using middleware, or refer to the middleware API reference.API ReferenceLearn more about Route Handlers and Middlewareroute.jsAPI reference for the route.js special file.middleware.jsAPI reference for the middleware.js file.Backend for FrontendLearn how to use Next.js as a backend frameworkPreviousMetadata and OG imagesNextDeployingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/deploying", "content": "ployingDeployingNext.js can be deployed as a Node.js server, Docker container, static export, or adapted to run on different platforms.\nDeployment OptionFeature SupportNode.js serverAllDocker containerAllStatic exportLimitedAdaptersPlatform-specific\nNode.js server\n\nNext.js can be deployed to any provider that supports Node.js. Ensure your package.json has the \"build\" and \"start\" scripts:\npackage.json{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\nThen, run npm run build to build your application and npm run start to start the Node.js server. This server supports all Next.js features. If needed, you can also eject to a custom server.\nNode.js deployments support all Next.js features. Learn how to configure them for your infrastructure.\nTemplates\n\nFlightcontrol\nRailway\nReplit\n\nDocker\n\nNext.js can be deployed to any provider that supports Docker containers. This includes container orchestrators like Kubernetes or a cloud provider that runs Docker.\nDocker deployments support all Next.js features. Learn how to configure them for your infrastructure.\n\nNote for development: While Docker is excellent for production deployments, consider using local development (npm run dev) instead of Docker during development on Mac and Windows for better performance. Learn more about optimizing local development.\n\nTemplates\n\nDocker\nDocker Multi-Environment\nDigitalOcean\nFly.io\nGoogle Cloud Run\nRender\nSST\n\nStatic export\n\nNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.\nSince Next.js supports static exports, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. This includes tools like AWS S3, Nginx, or Apache.\nRunning as a static export does not support Next.js features that require a server. Learn more.\nTemplates\n\nGitHub Pages\n\nAdapters\n\nNext.js can be adapted to run on different platforms to support their infrastructure capabilities.\nRefer to each provider's documentation for information on supported Next.js features:\n\nAWS Amplify Hosting\nCloudflare\nDeno Deploy\nNetlify\nVercel\n\nNote: We are working on a Deployment Adapters API for all platforms to adopt. After completion, we will add documentation on how to write your own adapters.\nPreviousRoute Handlers and MiddlewareNextUpgradingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/upgrading", "content": "gradingUpgradingLatest version\n\nTo update to the latest version of Next.js, you can use the upgrade codemod:\nTerminalnpx @next/codemod@latest upgrade latest\nIf you prefer to upgrade manually, install the latest Next.js and React versions:\npnpmnpmyarnbunTerminalpnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\n\nCanary version\n\nTo update to the latest canary, make sure you're on the latest version of Next.js and everything is working as expected. Then, run the following command:\nTerminalnpm i next@canary\nFeatures available in canary\n\nThe following features are currently available in canary:\nCaching:\n\n\"use cache\"\ncacheLife\ncacheTag\ndynamicIO\n\nAuthentication:\n\nforbidden\nunauthorized\nforbidden.js\nunauthorized.js\nauthInterrupts\nVersion guidesSee the version guides for in-depth upgrade instructions.Version 15Upgrade your Next.js Application from Version 14 to 15.Version 14Upgrade your Next.js Application from Version 13 to 14.PreviousDeployingNextGuidesWas this helpful?\n\nsupported.Send"}
