{"url": "https://nextjs.org/docs/app/guides/analytics", "content": "w to add analytics to your Next.js application\nNext.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to manage reporting yourself, or alternatively, Vercel provides a managed service to automatically collect and visualize metrics for you.\nClient Instrumentation\n\nFor more advanced analytics and monitoring needs, Next.js provides a instrumentation-client.js|ts file that runs before your application's frontend code starts executing. This is ideal for setting up global analytics, error tracking, or performance monitoring tools.\nTo use it, create an instrumentation-client.js or instrumentation-client.ts file in your application's root directory:\ninstrumentation-client.js// Initialize analytics before the app starts\nconsole.log('Analytics initialized')\n\n// Set up global error tracking\nwindow.addEventListener('error', (event) => {\n  // Send to your error tracking service\n  reportError(event.error)\n})\nBuild Your Own\n\napp/_components/web-vitals.js'use client'\n\nimport { useReportWebVitals } from 'next/web-vitals'\n\nexport function WebVitals() {\n  useReportWebVitals((metric) => {\n    console.log(metric)\n  })\n}app/layout.jsimport { WebVitals } from './_components/web-vitals'\n\nexport default function Layout({ children }) {\n  return (\n    <html>\n      <body>\n        <WebVitals />\n        {children}\n      </body>\n    </html>\n  )\n}\nSince the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component.\nView the API Reference for more information.\nWeb Vitals\n\nWeb Vitals are a set of useful metrics that aim to capture the user\nexperience of a web page. The following web vitals are all included:\n\nTime to First Byte (TTFB)\nFirst Contentful Paint (FCP)\nLargest Contentful Paint (LCP)\nFirst Input Delay (FID)\nCumulative Layout Shift (CLS)\nInteraction to Next Paint (INP)\n\nYou can handle all the results of these metrics using the name property.\n\napp/_components/web-vitals.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useReportWebVitals } from 'next/web-vitals'\n\nexport function WebVitals() {\n  useReportWebVitals((metric) => {\n    switch (metric.name) {\n      case 'FCP': {\n        // handle FCP results\n      }\n      case 'LCP': {\n        // handle LCP results\n      }\n      // ...\n    }\n  })\n}\n\nSending results to external systems\n\nYou can send results to any endpoint to measure and track\nreal user performance on your site. For example:\nuseReportWebVitals((metric) => {\n  const body = JSON.stringify(metric)\n  const url = 'https://example.com/analytics'\n\n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.\n  if (navigator.sendBeacon) {\n    navigator.sendBeacon(url, body)\n  } else {\n    fetch(url, { body, method: 'POST', keepalive: true })\n  }\n})\n\nGood to know: If you use Google Analytics, using the\nid value can allow you to construct metric distributions manually (to calculate percentiles,\netc.)\n\nuseReportWebVitals((metric) => {\n  // Use `window.gtag` if you initialized Google Analytics as this example:\n  // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics\n  window.gtag('event', metric.name, {\n    value: Math.round(\n      metric.name === 'CLS' ? metric.value * 1000 : metric.value\n    ), // values must be integers\n    event_label: metric.id, // id unique to current page load\n    non_interaction: true, // avoids affecting bounce rate.\n  })\n})\nRead more about sending results to Google Analytics.\nPreviousGuidesNextAuthenticationWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/authentication", "content": "ionHow to implement authentication in Next.jsUnderstanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.\nBefore starting, it helps to break down the process into three concepts:\n\nAuthentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password.\nSession Management: Tracks the user's auth state across requests.\nAuthorization: Decides what routes and data the user can access.\n\nThis diagram shows the authentication flow using React and Next.js features:\n\nThe examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section.\nAuthentication\n\nSign-up and login functionality\n\nYou can use the <form> element with React's Server Actions and useActionState to capture user credentials, validate form fields, and call your Authentication Provider's API or database.Since Server Actions always execute on the server, they provide a secure environment for handling authentication logic.Here are the steps to implement signup/login functionality:1. Capture user credentials\n\nTo capture user credentials, create a form that invokes a Server Action on submission. For example, a signup form that accepts the user's name, email, and password:app/ui/signup-form.tsxTypeScriptJavaScriptTypeScriptimport { signup } from '@/app/actions/auth'\n\nexport function SignupForm() {\n  return (\n    <form action={signup}>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\n      </div>\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input id=\"email\" name=\"email\" type=\"email\" placeholder=\"Email\" />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input id=\"password\" name=\"password\" type=\"password\" />\n      </div>\n      <button type=\"submit\">Sign Up</button>\n    </form>\n  )\n}app/actions/auth.tsTypeScriptJavaScriptTypeScriptexport async function signup(formData: FormData) {}2. Validate form fields on the server\n\nUse the Server Action to validate the form fields on the server. If your authentication provider doesn't provide form validation, you can use a schema validation library like Zod or Yup.Using Zod as an example, you can define a form schema with appropriate error messages:app/lib/definitions.tsTypeScriptJavaScriptTypeScriptimport { z } from 'zod'\n\nexport const SignupFormSchema = z.object({\n  name: z\n    .string()\n    .min(2, { message: 'Name must be at least 2 characters long.' })\n    .trim(),\n  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),\n  password: z\n    .string()\n    .min(8, { message: 'Be at least 8 characters long' })\n    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })\n    .regex(/[0-9]/, { message: 'Contain at least one number.' })\n    .regex(/[^a-zA-Z0-9]/, {\n      message: 'Contain at least one special character.',\n    })\n    .trim(),\n})\n\nexport type FormState =\n  | {\n      errors?: {\n        name?: string[]\n        email?: string[]\n        password?: string[]\n      }\n      message?: string\n    }\n  | undefinedTo prevent unnecessary calls to your authentication provider's API or database, you can return early in the Server Action if any form fields do not match the defined schema.app/actions/auth.tsTypeScriptJavaScriptTypeScriptimport { SignupFormSchema, FormState } from '@/app/lib/definitions'\n\nexport async function signup(state: FormState, formData: FormData) {\n  // Validate form fields\n  const validatedFields = SignupFormSchema.safeParse({\n    name: formData.get('name'),\n    email: formData.get('email'),\n    password: formData.get('password'),\n  })\n\n  // If any form fields are invalid, return early\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    }\n  }\n\n  // Call the provider or db to create a user...\n}Back in your <SignupForm />, you can use React's useActionState hook to display validation errors while the form is submitting:app/ui/signup-form.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { signup } from '@/app/actions/auth'\nimport { useActionState } from 'react'\n\nexport default function SignupForm() {\n  const [state, action, pending] = useActionState(signup, undefined)\n\n  return (\n    <form action={action}>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input id=\"name\" name=\"name\" placeholder=\"Name\" />\n      </div>\n      {state?.errors?.name && <p>{state.errors.name}</p>}\n\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input id=\"email\" name=\"email\" placeholder=\"Email\" />\n      </div>\n      {state?.errors?.email && <p>{state.errors.email}</p>}\n\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input id=\"password\" name=\"password\" type=\"password\" />\n      </div>\n      {state?.errors?.password && (\n        <div>\n          <p>Password must:</p>\n          <ul>\n            {state.errors.password.map((error) => (\n              <li key={error}>- {error}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n      <button disabled={pending} type=\"submit\">\n        Sign Up\n      </button>\n    </form>\n  )\n}\nGood to know:\n\nIn React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available.\nBefore mutating data, you should always ensure a user is also authorized to perform the action. See Authentication and Authorization.\n\n3. Create a user or check user credentials\n\nAfter validating form fields, you can create a new user account or check if the user exists by calling your authentication provider's API or database.Continuing from the previous example:app/actions/auth.tsxTypeScriptJavaScriptTypeScriptexport async function signup(state: FormState, formData: FormData) {\n  // 1. Validate form fields\n  // ...\n\n  // 2. Prepare data for insertion into database\n  const { name, email, password } = validatedFields.data\n  // e.g. Hash the user's password before storing it\n  const hashedPassword = await bcrypt.hash(password, 10)\n\n  // 3. Insert the user into the database or call an Auth Library's API\n  const data = await db\n    .insert(users)\n    .values({\n      name,\n      email,\n      password: hashedPassword,\n    })\n    .returning({ id: users.id })\n\n  const user = data[0]\n\n  if (!user) {\n    return {\n      message: 'An error occurred while creating your account.',\n    }\n  }\n\n  // TODO:\n  // 4. Create user session\n  // 5. Redirect user\n}After successfully creating the user account or verifying the user credentials, you can create a session to manage the user's auth state. Depending on your session management strategy, the session can be stored in a cookie or database, or both. Continue to the Session Management section to learn more.\nTips:\n\nThe example above is verbose since it breaks down the authentication steps for the purpose of education. This highlights that implementing your own secure solution can quickly become complex. Consider using an Auth Library to simplify the process.\nTo improve the user experience, you may want to check for duplicate emails or usernames earlier in the registration flow. For example, as the user types in a username or the input field loses focus. This can help prevent unnecessary form submissions and provide immediate feedback to the user. You can debounce requests with libraries such as use-debounce to manage the frequency of these checks.\n\nSession Management\n\nSession management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.\nThere are two types of sessions:\n\nStateless: Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly.\nDatabase: Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources.\n\nGood to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose.\n\nStateless Sessions\n\nTo create and manage stateless sessions, there are a few steps you need to follow:\nGenerate a secret key, which will be used to sign your session, and store it as an environment variable.\nWrite logic to encrypt/decrypt session data using a session management library.\nManage cookies using the Next.js cookies API.\nIn addition to the above, consider adding functionality to update (or refresh) the session when the user returns to the application, and delete the session when the user logs out.\nGood to know: Check if your auth library includes session management.\n1. Generating a secret key\n\nThere are a few ways you can generate secret key to sign your session. For example, you may choose to use the openssl command in your terminal:terminalopenssl rand -base64 32This command generates a 32-character random string that you can use as your secret key and store in your environment variables file:.envSESSION_SECRET=your_secret_keyYou can then reference this key in your session management logic:app/lib/session.jsconst secretKey = process.env.SESSION_SECRET2. Encrypting and decrypting sessions\n\nNext, you can use your preferred session management library to encrypt and decrypt sessions. Continuing from the previous example, we'll use Jose (compatible with the Edge Runtime) and React's server-only package to ensure that your session management logic is only executed on the server.app/lib/session.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\nimport { SignJWT, jwtVerify } from 'jose'\nimport { SessionPayload } from '@/app/lib/definitions'\n\nconst secretKey = process.env.SESSION_SECRET\nconst encodedKey = new TextEncoder().encode(secretKey)\n\nexport async function encrypt(payload: SessionPayload) {\n  return new SignJWT(payload)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setIssuedAt()\n    .setExpirationTime('7d')\n    .sign(encodedKey)\n}\n\nexport async function decrypt(session: string | undefined = '') {\n  try {\n    const { payload } = await jwtVerify(session, encodedKey, {\n      algorithms: ['HS256'],\n    })\n    return payload\n  } catch (error) {\n    console.log('Failed to verify session')\n  }\n}\nTips:\n\nThe payload should contain the minimum, unique user data that'll be used in subsequent requests, such as the user's ID, role, etc. It should not contain personally identifiable information like phone number, email address, credit card information, etc, or sensitive data like passwords.\n\n3. Setting cookies (recommended options)\n\nTo store the session in a cookie, use the Next.js cookies API. The cookie should be set on the server, and include the recommended options:\nHttpOnly: Prevents client-side JavaScript from accessing the cookie.\nSecure: Use https to send the cookie.\nSameSite: Specify whether the cookie can be sent with cross-site requests.\nMax-Age or Expires: Delete the cookie after a certain period.\nPath: Define the URL path for the cookie.\nPlease refer to MDN for more information on each of these options.app/lib/session.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\nimport { cookies } from 'next/headers'\n\nexport async function createSession(userId: string) {\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n  const session = await encrypt({ userId, expiresAt })\n  const cookieStore = await cookies()\n\n  cookieStore.set('session', session, {\n    httpOnly: true,\n    secure: true,\n    expires: expiresAt,\n    sameSite: 'lax',\n    path: '/',\n  })\n}Back in your Server Action, you can invoke the createSession() function, and use the redirect() API to redirect the user to the appropriate page:app/actions/auth.tsTypeScriptJavaScriptTypeScriptimport { createSession } from '@/app/lib/session'\n\nexport async function signup(state: FormState, formData: FormData) {\n  // Previous steps:\n  // 1. Validate form fields\n  // 2. Prepare data for insertion into database\n  // 3. Insert the user into the database or call an Library API\n\n  // Current steps:\n  // 4. Create user session\n  await createSession(user.id)\n  // 5. Redirect user\n  redirect('/profile')\n}\nTips:\n\nCookies should be set on the server to prevent client-side tampering.\n\ud83c\udfa5 Watch: Learn more about stateless sessions and authentication with Next.js \u2192 YouTube (11 minutes).\n\nUpdating (or refreshing) sessions\n\nYou can also extend the session's expiration time. This is useful for keeping the user logged in after they access the application again. For example:app/lib/session.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\nimport { cookies } from 'next/headers'\nimport { decrypt } from '@/app/lib/session'\n\nexport async function updateSession() {\n  const session = (await cookies()).get('session')?.value\n  const payload = await decrypt(session)\n\n  if (!session || !payload) {\n    return null\n  }\n\n  const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n\n  const cookieStore = await cookies()\n  cookieStore.set('session', session, {\n    httpOnly: true,\n    secure: true,\n    expires: expires,\n    sameSite: 'lax',\n    path: '/',\n  })\n}\nTip: Check if your auth library supports refresh tokens, which can be used to extend the user's session.\nDeleting the session\n\nTo delete the session, you can delete the cookie:app/lib/session.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\nimport { cookies } from 'next/headers'\n\nexport async function deleteSession() {\n  const cookieStore = await cookies()\n  cookieStore.delete('session')\n}Then you can reuse the deleteSession() function in your application, for example, on logout:app/actions/auth.tsTypeScriptJavaScriptTypeScriptimport { cookies } from 'next/headers'\nimport { deleteSession } from '@/app/lib/session'\n\nexport async function logout() {\n  await deleteSession()\n  redirect('/login')\n}\n\nDatabase Sessions\n\nTo create and manage database sessions, you'll need to follow these steps:\n\nCreate a table in your database to store session and data (or check if your Auth Library handles this).\nImplement functionality to insert, update, and delete sessions\nEncrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks in Middleware).\n\nFor example:app/lib/session.tsTypeScriptJavaScriptTypeScriptimport cookies from 'next/headers'\nimport { db } from '@/app/lib/db'\nimport { encrypt } from '@/app/lib/session'\n\nexport async function createSession(id: number) {\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n\n  // 1. Create a session in the database\n  const data = await db\n    .insert(sessions)\n    .values({\n      userId: id,\n      expiresAt,\n    })\n    // Return the session ID\n    .returning({ id: sessions.id })\n\n  const sessionId = data[0].id\n\n  // 2. Encrypt the session ID\n  const session = await encrypt({ sessionId, expiresAt })\n\n  // 3. Store the session in cookies for optimistic auth checks\n  const cookieStore = await cookies()\n  cookieStore.set('session', session, {\n    httpOnly: true,\n    secure: true,\n    expires: expiresAt,\n    sameSite: 'lax',\n    path: '/',\n  })\n}\nTips:\n\nFor faster access, you may consider adding server caching for the lifetime of the session. You can also keep the session data in your primary database, and combine data requests to reduce the number of queries.\nYou may opt to use database sessions for more advanced use cases, such as keeping track of the last time a user logged in, or number of active devices, or give users the ability to log out of all devices.\n\nAfter implementing session management, you'll need to add authorization logic to control what users can access and do within your application. Continue to the Authorization section to learn more.\n\nAuthorization\n\nOnce a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.\nThere are two main types of authorization checks:\n\nOptimistic: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles.\nSecure: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions.\n\nFor both cases, we recommend:\n\nCreating a Data Access Layer to centralize your authorization logic\nUsing Data Transfer Objects (DTO) to only return the necessary data\nOptionally use Middleware to perform optimistic checks.\n\nOptimistic checks with Middleware (Optional)\n\nThere are some cases where you may want to use Middleware and redirect users based on permissions:\n\nTo perform optimistic checks. Since Middleware runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users.\nTo protect static routes that share data between users (e.g. content behind a paywall).\n\nHowever, since Middleware runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.\nFor example:\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server'\nimport { decrypt } from '@/app/lib/session'\nimport { cookies } from 'next/headers'\n\n// 1. Specify protected and public routes\nconst protectedRoutes = ['/dashboard']\nconst publicRoutes = ['/login', '/signup', '/']\n\nexport default async function middleware(req: NextRequest) {\n  // 2. Check if the current route is protected or public\n  const path = req.nextUrl.pathname\n  const isProtectedRoute = protectedRoutes.includes(path)\n  const isPublicRoute = publicRoutes.includes(path)\n\n  // 3. Decrypt the session from the cookie\n  const cookie = (await cookies()).get('session')?.value\n  const session = await decrypt(cookie)\n\n  // 4. Redirect to /login if the user is not authenticated\n  if (isProtectedRoute && !session?.userId) {\n    return NextResponse.redirect(new URL('/login', req.nextUrl))\n  }\n\n  // 5. Redirect to /dashboard if the user is authenticated\n  if (\n    isPublicRoute &&\n    session?.userId &&\n    !req.nextUrl.pathname.startsWith('/dashboard')\n  ) {\n    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))\n  }\n\n  return NextResponse.next()\n}\n\n// Routes Middleware should not run on\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\n}\n\nWhile Middleware can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information.\n\nTips:\n\nIn Middleware, you can also read cookies using req.cookies.get('session').value.\nMiddleware uses the Edge Runtime, check if your Auth library and session management library are compatible.\nYou can use the matcher property in the Middleware to specify which routes Middleware should run on. Although, for auth, it's recommended Middleware runs on all routes.\n\nCreating a Data Access Layer (DAL)\n\nWe recommend creating a DAL to centralize your data requests and authorization logic.The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests.For example, create a separate file for your DAL that includes a verifySession() function. Then use React's cache API to memoize the return value of the function during a React render pass:app/lib/dal.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\n\nimport { cookies } from 'next/headers'\nimport { decrypt } from '@/app/lib/session'\n\nexport const verifySession = cache(async () => {\n  const cookie = (await cookies()).get('session')?.value\n  const session = await decrypt(cookie)\n\n  if (!session?.userId) {\n    redirect('/login')\n  }\n\n  return { isAuth: true, userId: session.userId }\n})You can then invoke the verifySession() function in your data requests, Server Actions, Route Handlers:app/lib/dal.tsTypeScriptJavaScriptTypeScriptexport const getUser = cache(async () => {\n  const session = await verifySession()\n  if (!session) return null\n\n  try {\n    const data = await db.query.users.findMany({\n      where: eq(users.id, session.userId),\n      // Explicitly return the columns you need rather than the whole user object\n      columns: {\n        id: true,\n        name: true,\n        email: true,\n      },\n    })\n\n    const user = data[0]\n\n    return user\n  } catch (error) {\n    console.log('Failed to fetch user')\n    return null\n  }\n})\nTip:\n\nA DAL can be used to protect data fetched at request time. However, for static routes that share data between users, data will be fetched at build time and not at request time. Use Middleware to protect static routes.\nFor secure checks, you can check if the session is valid by comparing the session ID with your database. Use React's cache function to avoid unnecessary duplicate requests to the database during a render pass.\nYou may wish to consolidate related data requests in a JavaScript class that runs verifySession() before any methods.\n\nUsing Data Transfer Objects (DTO)\n\nWhen retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc.However, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client.app/lib/dto.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\nimport { getUser } from '@/app/lib/dal'\n\nfunction canSeeUsername(viewer: User) {\n  return true\n}\n\nfunction canSeePhoneNumber(viewer: User, team: string) {\n  return viewer.isAdmin || team === viewer.team\n}\n\nexport async function getProfileDTO(slug: string) {\n  const data = await db.query.users.findMany({\n    where: eq(users.slug, slug),\n    // Return specific columns here\n  })\n  const user = data[0]\n\n  const currentUser = await getUser(user.id)\n\n  // Or return only what's specific to the query here\n  return {\n    username: canSeeUsername(currentUser) ? user.username : null,\n    phonenumber: canSeePhoneNumber(currentUser, user.team)\n      ? user.phonenumber\n      : null,\n  }\n}By centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales.\nGood to know:\n\nThere are a couple of different ways you can define a DTO, from using toJSON(), to individual functions like the example above, or JS classes. Since these are JavaScript patterns and not a React or Next.js feature, we recommend doing some research to find the best pattern for your application.\nLearn more about security best practices in our Security in Next.js article.\n\nServer Components\n\nAuth check in Server Components are useful for role-based access. For example, to conditionally render components based on the user's role:app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport { verifySession } from '@/app/lib/dal'\n\nexport default function Dashboard() {\n  const session = await verifySession()\n  const userRole = session?.user?.role // Assuming 'role' is part of the session object\n\n  if (userRole === 'admin') {\n    return <AdminDashboard />\n  } else if (userRole === 'user') {\n    return <UserDashboard />\n  } else {\n    redirect('/login')\n  }\n}In the example, we use the verifySession() function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role.Layouts and auth checks\n\nDue to Partial Rendering, be cautious when doing checks in Layouts as these don't re-render on navigation, meaning the user session won't be checked on every route change.Instead, you should do the checks close to your data source or the component that'll be conditionally rendered.For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data (getUser()) in the layout and do the auth check in your DAL.This guarantees that wherever getUser() is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data.app/layout.tsxTypeScriptJavaScriptTypeScriptexport default async function Layout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const user = await getUser();\n\n  return (\n    // ...\n  )\n}app/lib/dal.tsTypeScriptJavaScriptTypeScriptexport const getUser = cache(async () => {\n  const session = await verifySession()\n  if (!session) return null\n\n  // Get user ID from session and fetch data\n})\nGood to know:\n\nA common pattern in SPAs is to return null in a layout or a top-level component if a user is not authorized. This pattern is not recommended since Next.js applications have multiple entry points, which will not prevent nested route segments and Server Actions from being accessed.\n\nServer Actions\n\nTreat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.In the example below, we check the user's role before allowing the action to proceed:app/lib/actions.tsTypeScriptJavaScriptTypeScript'use server'\nimport { verifySession } from '@/app/lib/dal'\n\nexport async function serverAction(formData: FormData) {\n  const session = await verifySession()\n  const userRole = session?.user?.role\n\n  // Return early if user is not authorized to perform the action\n  if (userRole !== 'admin') {\n    return null\n  }\n\n  // Proceed with the action for authorized users\n}Route Handlers\n\nTreat Route Handlers with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler.For example:app/api/route.tsTypeScriptJavaScriptTypeScriptimport { verifySession } from '@/app/lib/dal'\n\nexport async function GET() {\n  // User authentication and role verification\n  const session = await verifySession()\n\n  // Check if the user is authenticated\n  if (!session) {\n    // User is not authenticated\n    return new Response(null, { status: 401 })\n  }\n\n  // Check if the user has the 'admin' role\n  if (session.user.role !== 'admin') {\n    // User is authenticated but does not have the right permissions\n    return new Response(null, { status: 403 })\n  }\n\n  // Continue for authorized users\n}The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'.Context Providers\n\nUsing context providers for auth works due to interleaving. However, React context is not supported in Server Components, making them only applicable to Client Components.This works, but any child Server Components will be rendered on the server first, and will not have access to the context provider\u2019s session data:app/layout.tsTypeScriptJavaScriptTypeScriptimport { ContextProvider } from 'auth-lib'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <ContextProvider>{children}</ContextProvider>\n      </body>\n    </html>\n  )\n}'use client';\n\nimport { useSession } from \"auth-lib\";\n\nexport default function Profile() {\n  const { userId } = useSession();\n  const { data } = useSWR(`/api/user/${userId}`, fetcher)\n\n  return (\n    // ...\n  );\n}If session data is needed in Client Components (e.g. for client-side data fetching), use React\u2019s taintUniqueValue API to prevent sensitive session data from being exposed to the client.\n\nResources\n\nNow that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:\nAuth Libraries\n\nAuth0\nBetter Auth\nClerk\nKinde\nLogto\nNextAuth.js\nOry\nStack Auth\nSupabase\nStytch\nWorkOS\n\nSession Management Libraries\n\nIron Session\nJose\n\nFurther Reading\n\nTo continue learning about authentication and security, check out the following resources:\n\nHow to think about security in Next.js\nUnderstanding XSS Attacks\nUnderstanding CSRF Attacks\nThe Copenhagen Book\nPreviousAnalyticsNextBackend for FrontendWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/backend-for-frontend", "content": "FrontendHow to use Next.js as a backend for your frontendNext.js supports the \"Backend for Frontend\" pattern. This lets you create public endpoints to handle HTTP requests and return any content type\u2014not just HTML. You can also access data sources and perform side effects like updating remote data.\nIf you are starting a new project, using create-next-app with the --api flag automatically includes an example route.ts in your new project\u2019s app/ folder, demonstrating how to create an API endpoint.\nTerminalnpx create-next-app@latest --api\n\nGood to know: Next.js backend capabilities are not a full backend replacement. They serve as an API layer that:\n\nis publicly reachable\nhandles any HTTP request\ncan return any content type\n\nTo implement this pattern, use:\n\nRoute Handlers\nmiddleware\nIn Pages Router, API Routes\n\nPublic Endpoints\n\nRoute Handlers are public HTTP endpoints. Any client can access them.\nCreate a Route Handler using the route.ts or route.js file convention:\n/app/api/route.tsTypeScriptJavaScriptTypeScriptexport function GET(request: Request) {}\n\nThis handles GET requests sent to /api.\nUse try/catch blocks for operations that may throw an exception:\n/app/api/route.tsTypeScriptJavaScriptTypeScriptimport { submit } from '@/lib/submit'\n\nexport function POST(request: Request) {\n  try {\n    await submit(request)\n    return new Response(null, { status: 204 })\n  } catch (reason) {\n    const message =\n      reason instanceof Error ? reason.message : 'Unexpected error'\n\n    return new Response(message, { status: 500 })\n  }\n}\n\nAvoid exposing sensitive information in error messages sent to the client.\nTo restrict access, implement authentication and authorization. See Authentication.\nContent types\n\nRoute Handlers let you serve non-UI responses, including JSON, XML, images, files, and plain text.\nNext.js uses file conventions for common endpoints:\n\nsitemap.xml\nopengraph-image.jpg, twitter-image\nfavicon, app icon, and apple-icon\nmanifest.json\nrobots.txt\n\nYou can also define custom ones, such as:\n\nllms.txt\nrss.xml\n.well-known\n\nFor example, app/rss.xml/route.ts creates a Route Handler for rss.xml.\n/app/rss.xml/route.tsTypeScriptJavaScriptTypeScriptexport async function GET(request: Request) {\n  const rssResponse = await fetch(/* rss endpoint */)\n  const rssData = await rssResponse.json()\n\n  const rssFeed = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n<channel>\n <title>${rssData.title}</title>\n <description>${rssData.description}</description>\n <link>${rssData.link}</link>\n <copyright>${rssData.copyright}</copyright>\n ${rssData.items.map((item) => {\n   return `<item>\n    <title>${item.title}</title>\n    <description>${item.description}</description>\n    <link>${item.link}</link>\n    <pubDate>${item.publishDate}</pubDate>\n    <guid isPermaLink=\"false\">${item.guid}</guid>\n </item>`\n })}\n</channel>\n</rss>`\n\n  const headers = new Headers({ 'content-type': 'application/xml' })\n\n  return new Response(rssFeed, { headers })\n}\n\nSanitize any input used to generate markup.\nConsuming request payloads\n\nUse Request instance methods like .json(), .formData(), or .text() to access the request body.\nGET and HEAD requests don\u2019t carry a body.\n/app/api/echo-body/route.tsTypeScriptJavaScriptTypeScriptexport async function POST(request: Request) {\n  const res = await request.json()\n  return Response.json({ res })\n}\n\nGood to know: Validate data before passing it to other systems\n\n/app/api/send-email/route.tsTypeScriptJavaScriptTypeScriptimport { sendMail, validateInputs } from '@/lib/email-transporter'\n\nexport async function POST(request: Request) {\n  const formData = await request.formData()\n  const email = formData.get('email')\n  const contents = formData.get('contents')\n\n  try {\n    await validateInputs({ email, contents })\n    const info = await sendMail({ email, contents })\n\n    return Response.json({ messageId: info.messageId })\n  } catch (reason) {\n    const message =\n      reason instanceof Error ? reason.message : 'Unexpected exception'\n\n    return new Response(message, { status: 500 })\n  }\n}\n\nYou can only read the request body once. Clone the request if you need to read it again:\n/app/api/clone/route.tsTypeScriptJavaScriptTypeScriptexport async function POST(request: Request) {\n  try {\n    const clonedRequest = request.clone()\n\n    await request.body()\n    await clonedRequest.body()\n    await request.body() // Throws error\n\n    return new Response(null, { status: 204 })\n  } catch {\n    return new Response(null, { status: 500 })\n  }\n}\n\nManipulating data\n\nRoute Handlers can transform, filter, and aggregate data from one or more sources. This keeps logic out of the frontend and avoids exposing internal systems.\nYou can also offload heavy computations to the server and reduce client battery and data usage.\nimport { parseWeatherData } from '@/lib/weather'\n\nexport async function POST(request: Request) {\n  const body = await request.json()\n  const searchParams = new URLSearchParams({ lat: body.lat, lng: body.lng })\n\n  try {\n    const weatherResponse = await fetch(`${weatherEndpoint}?${searchParams}`)\n\n    if (!weatherResponse.ok) {\n      /* handle error */\n    }\n\n    const weatherData = await weatherResponse.text()\n    const payload = parseWeatherData.asJSON(weatherData)\n\n    return new Response(payload, { status: 200 })\n  } catch (reason) {\n    const message =\n      reason instanceof Error ? reason.message : 'Unexpected exception'\n\n    return new Response(message, { status: 500 })\n  }\n}\n\nGood to know: This example uses POST to avoid putting geo-location data in the URL. GET requests may be cached or logged, which could expose sensitive info.\n\nProxying to a backend\n\nYou can use a Route Handler as a proxy to another backend. Add validation logic before forwarding the request.\n/app/api/[...slug]/route.tsTypeScriptJavaScriptTypeScriptimport { isValidRequest } from '@/lib/utils'\n\nexport async function POST(request: Request, { params }) {\n  const clonedRequest = request.clone()\n  const isValid = await isValidRequest(clonedRequest)\n\n  if (!isValid) {\n    return new Response(null, { status: 400, statusText: 'Bad Request' })\n  }\n\n  const { slug } = await params\n  const pathname = slug.join('/')\n  const proxyURL = new URL(pathname, 'https://nextjs.org')\n  const proxyRequest = new Request(proxyURL, request)\n\n  try {\n    return fetch(proxyRequest)\n  } catch (reason) {\n    const message =\n      reason instanceof Error ? reason.message : 'Unexpected exception'\n\n    return new Response(message, { status: 500 })\n  }\n}\n\nOr use:\n\nmiddleware rewrites\nrewrites in next.config.js.\n\nNextRequest and NextResponse\n\nNext.js extends the Request and Response Web APIs with methods that simplify common operations. These extensions are available in both Route Handlers and Middleware.\nBoth provide methods for reading and manipulating cookies.\nNextRequest includes the nextUrl property, which exposes parsed values from the incoming request, for example, it makes it easier to access request pathname and search params.\nNextResponse provides helpers like next(), json(), redirect(), and rewrite().\nYou can pass NextRequest to any function expecting Request. Likewise, you can return NextResponse where a Response is expected.\n/app/echo-pathname/route.tsTypeScriptJavaScriptTypeScriptimport { type NextRequest, NextResponse } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const nextUrl = request.nextUrl\n\n  if (nextUrl.searchParams.get('redirect')) {\n    return NextResponse.redirect(new URL('/', request.url))\n  }\n\n  if (nextUrl.searchParams.get('rewrite')) {\n    return NextResponse.rewrite(new URL('/', request.url))\n  }\n\n  return NextResponse.json({ pathname: nextUrl.pathname })\n}\n\nLearn more about NextRequest and NextResponse.\nWebhooks and callback URLs\n\nUse Route Handlers to receive event notifications from third-party applications.\nFor example, revalidate a route when content changes in a CMS. Configure the CMS to call a specific endpoint on changes.\n/app/webhook/route.tsTypeScriptJavaScriptTypeScriptimport { type NextRequest, NextResponse } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const token = request.nextUrl.searchParams.get('token')\n\n  if (token !== process.env.REVALIDATE_SECRET_TOKEN) {\n    return NextResponse.json({ success: false }, { status: 401 })\n  }\n\n  const tag = request.nextUrl.searchParams.get('tag')\n\n  if (!tag) {\n    return NextResponse.json({ success: false }, { status: 400 })\n  }\n\n  revalidateTag(tag)\n\n  return NextResponse.json({ success: true })\n}\n\nCallback URLs are another use case. When a user completes a third-party flow, the third party sends them to a callback URL. Use a Route Handler to verify the response and decide where to redirect the user.\n/app/auth/callback/route.tsTypeScriptJavaScriptTypeScriptimport { type NextRequest, NextResponse } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const token = request.nextUrl.searchParams.get('session_token')\n  const redirectUrl = request.nextUrl.searchParams.get('redirect_url')\n\n  const response = NextResponse.redirect(new URL(redirectUrl, request.url))\n\n  response.cookies.set({\n    value: token,\n    name: '_token',\n    path: '/',\n    secure: true,\n    httpOnly: true,\n    expires: undefined, // session cookie\n  })\n\n  return response\n}\n\nRedirects\n\napp/api/route.tsTypeScriptJavaScriptTypeScriptimport { redirect } from 'next/navigation'\n\nexport async function GET(request: Request) {\n  redirect('https://nextjs.org/')\n}\n\nLearn more about redirects in redirect and permanentRedirect\nMiddleware\n\nOnly one middleware file is allowed per project. Use config.matcher to target specific paths. Learn more about middleware.\nUse middleware to generate a response before the request reaches a route path.\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { isAuthenticated } from '@lib/auth'\n\nexport const config = {\n  matcher: '/api/:function*',\n}\n\nexport function middleware(request: Request) {\n  if (!isAuthenticated(request)) {\n    return Response.json(\n      { success: false, message: 'authentication failed' },\n      { status: 401 }\n    )\n  }\n}\n\nYou can also proxy requests using middleware:\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextResponse } from 'next/server'\n\nexport function middleware(request: Request) {\n  if (request.nextUrl.pathname === '/proxy-this-path') {\n    const rewriteUrl = new URL('https://nextjs.org')\n    return NextResponse.rewrite(rewriteUrl)\n  }\n}\n\nAnother type of response middleware can produce are redirects:\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextResponse } from 'next/server'\n\nexport function middleware(request: Request) {\n  if (request.nextUrl.pathname === '/v1/docs') {\n    request.nextUrl.pathname = '/v2/docs'\n    return NextResponse.redirect(request.nextUrl)\n  }\n}\n\nSecurity\n\nRate limiting\n\nYou can implement rate limiting in your Next.js backend. In addition to code-based checks, enable any rate limiting features provided by your host.\n/app/resource/route.tsTypeScriptJavaScriptTypeScriptimport { NextResponse } from 'next/server'\nimport { checkRateLimit } from '@/lib/rate-limit'\n\nexport async function POST(request: Request) {\n  const { rateLimited } = await checkRateLimit(request)\n\n  if (rateLimited) {\n    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 })\n  }\n\n  return new Response(null, { status: 204 })\n}\n\nVerify payloads\n\nNever trust incoming request data. Validate content type and size, and sanitize against XSS before use.\nUse timeouts to prevent abuse and protect server resources.\nStore user-generated static assets in dedicated services. When possible, upload them from the browser and store the returned URI in your database to reduce request size.\nAccess to protected resources\n\nAlways verify credentials before granting access. Do not rely on middleware alone for authentication and authorization.\nRemove sensitive or unnecessary data from responses and backend logs.\nRotate credentials and API keys regularly.\nPreflight Requests\n\nPreflight requests use the OPTIONS method to ask the server if a request is allowed based on origin, method, and headers.\nIf OPTIONS is not defined, Next.js adds it automatically and sets the Allow header based on the other defined methods.\n\nCORS\n\nLibrary patterns\n\nCommunity libraries often use the factory pattern for Route Handlers.\n/app/api/[...path]/route.tsimport { createHandler } from 'third-party-library'\n\nconst handler = createHandler({\n  /* library-specific options */\n})\n\nexport const GET = handler\n// or\nexport { handler as POST }\nThis creates a shared handler for GET and POST requests. The library customizes behavior based on the method and pathname in the request.\nLibraries can also provide a middleware factory.\nmiddleware.tsimport { createMiddleware } from 'third-party-library'\n\nexport default createMiddleware()\nMore examples\n\nSee more examples on using Router Handlers and the middleware API references.\nThese examples include, working with Cookies, Headers, Streaming, Middleware negative matching, and other useful code snippets.\nCaveats\n\nServer Components\n\nFetch data in Server Components directly from its source, not via Route Handlers.\nFor Server Components pre-rendered at build time, using Route Handlers will fail the build step. This is because, while building there is no server listening for these requests.\nFor Server Components rendered on demand, fetching from Route Handlers is slower due to the extra HTTP round trip between the handler and the render process.\n\nA server side fetch request uses absolute URLs. This implies an HTTP round trip, to an external server. During development, your own development server acts as the external server. At build time there is no server, and at runtime, the server is available through your public facing domain.\n\nServer Components cover most data-fetching needs. However, fetching data client side might be necessary for:\n\nData that depends on client-only Web APIs:\n\nGeo-location API\nStorage API\nAudio API\nFile API\n\nFrequently polled data\n\nFor these, use community libraries like swr or react-query.\nServer Actions\n\nServer Actions let you run server-side code from the client. Their primary purpose is to mutate data from your frontend client.\nServer Actions are queued. Using them for data fetching introduces sequential execution.\nexport mode\n\nexport mode outputs a static site without a runtime server. Features that require the Next.js runtime are not supported, because this mode produces a static site, and no runtime server.\nIn export mode, only GET Route Handlers are supported, in combination with the dynamic route segment config, set to 'force-static'.\nThis can be used to generate static HTML, JSON, TXT, or other files.\napp/hello-world/route.tsexport const dynamic = 'force-static'\n\nexport function GET() {\n  return new Response('Hello World', { status: 200 })\n}\nDeployment environment\n\nSome hosts deploy Route Handlers as lambda functions. This means:\n\nRoute Handlers cannot share data between requests.\nThe environment may not support writing to File System.\nLong-running handlers may be terminated due to timeouts.\nWebSockets won\u2019t work because the connection closes on timeout, or after the response is generated.\nAPI ReferenceLearn more about Route Handlers and Middlewareroute.jsAPI reference for the route.js special file.middleware.jsAPI reference for the middleware.js file.PreviousAuthenticationNextCachingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/caching", "content": "ing in Next.jsNext.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other.\n\nGood to know: This page helps you understand how Next.js works under the hood but is not essential knowledge to be productive with Next.js. Most of Next.js' caching heuristics are determined by your API usage and have defaults for the best performance with zero or minimal configuration. If you instead want to jump to examples, start here.\n\nOverview\n\nHere's a high-level overview of the different caching mechanisms and their purpose:\nMechanismWhatWherePurposeDurationRequest MemoizationReturn values of functionsServerRe-use data in a React Component treePer-request lifecycleData CacheDataServerStore data across user requests and deploymentsPersistent (can be revalidated)Full Route CacheHTML and RSC payloadServerReduce rendering cost and improve performancePersistent (can be revalidated)Router CacheRSC PayloadClientReduce server requests on navigationUser session or time-based\nBy default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered and data requests are cached unless you opt out. The diagram below shows the default caching behavior: when a route is statically rendered at build time and when a static route is first visited.\n\nCaching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests.\nFetch caching is not supported in middleware. Any fetches done inside of your middleware will be uncached.\nRequest Memoization\n\nNext.js extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.\n\nFor example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to fetch data at the top of the tree, and forward props between components. Instead, you can fetch data in the components that need it without worrying about the performance implications of making multiple requests across the network for the same data.\napp/example.tsxTypeScriptJavaScriptTypeScriptasync function getItem() {\n  // The `fetch` function is automatically memoized and the result\n  // is cached\n  const res = await fetch('https://.../item/1')\n  return res.json()\n}\n\n// This function is called twice, but only executed the first time\nconst item = await getItem() // cache MISS\n\n// The second call could be anywhere in your route\nconst item = await getItem() // cache HIT\n\nHow Request Memoization Works\n\nWhile rendering a route, the first time a particular request is called, its result will not be in memory and it'll be a cache MISS.\nTherefore, the function will be executed, and the data will be fetched from the external source, and the result will be stored in memory.\nSubsequent function calls of the request in the same render pass will be a cache HIT, and the data will be returned from memory without executing the function.\nOnce the route has been rendered and the rendering pass is complete, memory is \"reset\" and all request memoization entries are cleared.\n\nGood to know:\n\nRequest memoization is a React feature, not a Next.js feature. It's included here to show how it interacts with the other caching mechanisms.\nMemoization only applies to the GET method in fetch requests.\nMemoization only applies to the React Component tree, this means:\n\nIt applies to fetch requests in generateMetadata, generateStaticParams, Layouts, Pages, and other Server Components.\nIt doesn't apply to fetch requests in Route Handlers as they are not a part of the React component tree.\n\nFor cases where fetch is not suitable (e.g. some database clients, CMS clients, or GraphQL clients), you can use the React cache function to memoize functions.\n\nDuration\n\nThe cache lasts the lifetime of a server request until the React component tree has finished rendering.\nRevalidating\n\nSince the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it.\nOpting out\n\nMemoization only applies to the GET method in fetch requests, other methods, such as POST and DELETE, are not memoized. This default behavior is a React optimization and we do not recommend opting out of it.\nTo manage individual requests, you can use the signal property from AbortController. However, this will not opt requests out of memoization, rather, abort in-flight requests.\napp/example.jsconst { signal } = new AbortController()\nfetch(url, { signal })\nData Cache\n\nNext.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics.\n\nGood to know: In the browser, the cache option of fetch indicates how a request will interact with the browser's HTTP cache, in Next.js, the cache option indicates how a server-side request will interact with the server's Data Cache.\n\nYou can use the cache and next.revalidate options of fetch to configure the caching behavior.\nIn development mode, fetch data is reused for Hot Module Replacement (HMR), and caching options are ignored for hard refreshes.\nHow the Data Cache Works\n\nThe first time a fetch request with the 'force-cache' option is called during rendering, Next.js checks the Data Cache for a cached response.\nIf a cached response is found, it's returned immediately and memoized.\nIf a cached response is not found, the request is made to the data source, the result is stored in the Data Cache, and memoized.\nFor uncached data (e.g. no cache option defined or using { cache: 'no-store' }), the result is always fetched from the data source, and memoized.\nWhether the data is cached or uncached, the requests are always memoized to avoid making duplicate requests for the same data during a React render pass.\n\nDifferences between the Data Cache and Request Memoization\nWhile both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request.\n\nDuration\n\nThe Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out.\nRevalidating\n\nCached data can be revalidated in two ways, with:\n\nTime-based Revalidation: Revalidate data after a certain amount of time has passed and a new request is made. This is useful for data that changes infrequently and freshness is not as critical.\nOn-demand Revalidation: Revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful when you want to ensure the latest data is shown as soon as possible (e.g. when content from your headless CMS is updated).\n\nTime-based Revalidation\n\nTo revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in seconds).\n// Revalidate at most every hour\nfetch('https://...', { next: { revalidate: 3600 } })\nAlternatively, you can use Route Segment Config options to configure all fetch requests in a segment or for cases where you're not able to use fetch.\nHow Time-based Revalidation Works\n\nThe first time a fetch request with revalidate is called, the data will be fetched from the external data source and stored in the Data Cache.\nAny requests that are called within the specified timeframe (e.g. 60-seconds) will return the cached data.\nAfter the timeframe, the next request will still return the cached (now stale) data.\n\nNext.js will trigger a revalidation of the data in the background.\nOnce the data is fetched successfully, Next.js will update the Data Cache with the fresh data.\nIf the background revalidation fails, the previous data will be kept unaltered.\n\nThis is similar to stale-while-revalidate behavior.\nOn-demand Revalidation\n\nData can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag).\nHow On-Demand Revalidation Works\n\nThe first time a fetch request is called, the data will be fetched from the external data source and stored in the Data Cache.\nWhen an on-demand revalidation is triggered, the appropriate cache entries will be purged from the cache.\n\nThis is different from time-based revalidation, which keeps the stale data in the cache until the fresh data is fetched.\n\nThe next time a request is made, it will be a cache MISS again, and the data will be fetched from the external data source and stored in the Data Cache.\n\nOpting out\n\nIf you do not want to cache the response from fetch, you can do the following:\nlet data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })\nFull Route Cache\n\nRelated terms:\nYou may see the terms Automatic Static Optimization, Static Site Generation, or Static Rendering being used interchangeably to refer to the process of rendering and caching routes of your application at build time.\n\nNext.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads.\nTo understand how the Full Route Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result:\n1. React Rendering on the Server\n\nOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments and Suspense boundaries.\nEach chunk is rendered in two steps:\n\nReact renders Server Components into a special data format, optimized for streaming, called the React Server Component Payload.\nNext.js uses the React Server Component Payload and Client Component JavaScript instructions to render HTML on the server.\n\nThis means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.\n\nWhat is the React Server Component Payload?\nThe React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The React Server Component Payload contains:\n\nThe rendered result of Server Components\nPlaceholders for where Client Components should be rendered and references to their JavaScript files\nAny props passed from a Server Component to a Client Component\n\nTo learn more, see the Server Components documentation.\n\n2. Next.js Caching on the Server (Full Route Cache)\n\nThe default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.\n3. React Hydration and Reconciliation on the Client\n\nAt request time, on the client:\n\nThe HTML is used to immediately show a fast non-interactive initial preview of the Client and Server Components.\nThe React Server Components Payload is used to reconcile the Client and rendered Server Component trees, and update the DOM.\nThe JavaScript instructions are used to hydrate Client Components and make the application interactive.\n\n4. Next.js Caching on the Client (Router Cache)\n\nThe React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.\n5. Subsequent Navigations\n\nOn subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server.\nIf the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.\nStatic and Dynamic Rendering\n\nWhether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.\nThis diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:\n\nLearn more about static and dynamic rendering.\nDuration\n\nBy default, the Full Route Cache is persistent. This means that the render output is cached across user requests.\nInvalidation\n\nThere are two ways you can invalidate the Full Route Cache:\n\nRevalidating Data: Revalidating the Data Cache, will in turn invalidate the Router Cache by re-rendering components on the server and caching the new render output.\nRedeploying: Unlike the Data Cache, which persists across deployments, the Full Route Cache is cleared on new deployments.\n\nOpting out\n\nYou can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by:\n\nUsing a Dynamic API: This will opt the route out from the Full Route Cache and dynamically render it at request time. The Data Cache can still be used.\nUsing the dynamic = 'force-dynamic' or revalidate = 0 route segment config options: This will skip the Full Route Cache and the Data Cache. Meaning components will be rendered and data fetched on every incoming request to the server. The Router Cache will still apply as it's a client-side cache.\nOpting out of the Data Cache: If a route has a fetch request that is not cached, this will opt the route out of the Full Route Cache. The data for the specific fetch request will be fetched for every incoming request. Other fetch requests that do not opt out of caching will still be cached in the Data Cache. This allows for a hybrid of cached and uncached data.\n\nClient-side Router Cache\n\nNext.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages.\nWhen a user navigates between routes, Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of React state and browser state.\nWith the Router Cache:\n\nLayouts are cached and reused on navigation (partial rendering).\nLoading states are cached and reused on navigation for instant navigation.\nPages are not cached by default, but are reused during browser backward and forward navigation. You can enable caching for page segments by using the experimental staleTimes config option.\n\nGood to know: This cache specifically applies to Next.js and Server Components, and is different to the browser's bfcache, though it has a similar result.\n\nDuration\n\nThe cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:\n\nSession: The cache persists across navigation. However, it's cleared on page refresh.\nAutomatic Invalidation Period: The cache of layouts and loading states is automatically invalidated after a specific time. The duration depends on how the resource was prefetched, and if the resource was statically generated:\n\nDefault Prefetching (prefetch={null} or unspecified): not cached for dynamic pages, 5 minutes for static pages.\nFull Prefetching (prefetch={true} or router.prefetch): 5 minutes for both static & dynamic pages.\n\nWhile a page refresh will clear all cached segments, the automatic invalidation period only affects the individual segment from the time it was prefetched.\n\nGood to know: The experimental staleTimes config option can be used to adjust the automatic invalidation times mentioned above.\n\nInvalidation\n\nThere are two ways you can invalidate the Router Cache:\n\nIn a Server Action:\n\nRevalidating data on-demand by path with (revalidatePath) or by cache tag with (revalidateTag)\nUsing cookies.set or cookies.delete invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication).\n\nCalling router.refresh will invalidate the Router Cache and make a new request to the server for the current route.\n\nOpting out\n\nAs of Next.js 15, page segments are opted out by default.\n\nGood to know: You can also opt out of prefetching by setting the prefetch prop of the <Link> component to false.\n\nCache Interactions\n\nWhen configuring the different caching mechanisms, it's important to understand how they interact with each other:\nData Cache and Full Route Cache\n\nRevalidating or opting out of the Data Cache will invalidate the Full Route Cache, as the render output depends on data.\nInvalidating or opting out of the Full Route Cache does not affect the Data Cache. You can dynamically render a route that has both cached and uncached data. This is useful when most of your page uses cached data, but you have a few components that rely on data that needs to be fetched at request time. You can dynamically render without worrying about the performance impact of re-fetching all the data.\n\nData Cache and Client-side Router cache\n\nTo immediately invalidate the Data Cache and Router cache, you can use revalidatePath or revalidateTag in a Server Action.\nRevalidating the Data Cache in a Route Handler will not immediately invalidate the Router Cache as the Route Handler isn't tied to a specific route. This means Router Cache will continue to serve the previous payload until a hard refresh, or the automatic invalidation period has elapsed.\n\nAPIs\n\nThe following table provides an overview of how different Next.js APIs affect caching:\nAPIRouter CacheFull Route CacheData CacheReact Cache<Link prefetch>Cacherouter.prefetchCacherouter.refreshRevalidatefetchCacheCachefetch options.cacheCache or Opt outfetch options.next.revalidateRevalidateRevalidatefetch options.next.tagsCacheCacherevalidateTagRevalidate (Server Action)RevalidateRevalidaterevalidatePathRevalidate (Server Action)RevalidateRevalidateconst revalidateRevalidate or Opt outRevalidate or Opt outconst dynamicCache or Opt outCache or Opt outcookiesRevalidate (Server Action)Opt outheaders, searchParamsOpt outgenerateStaticParamsCacheReact.cacheCacheunstable_cacheCache\n<Link>\n\nBy default, the <Link> component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.\nTo disable prefetching, you can set the prefetch prop to false. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.\nLearn more about the <Link> component.\nrouter.prefetch\n\nThe prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.\nSee the useRouter hook API reference.\nrouter.refresh\n\nThe refresh option of the useRouter hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route. refresh does not affect the Data or Full Route Cache.\nThe rendered result will be reconciled on the client while preserving React state and browser state.\nSee the useRouter hook API reference.\nfetch\n\nData returned from fetch is not automatically cached in the Data Cache.\nThe default caching behavior of fetch (e.g., when the cache option is not specified) is equal to setting the cache option to no-store:\nlet data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })\nSee the fetch API Reference for more options.\nfetch options.cache\n\nYou can opt individual fetch into caching by setting the cache option to force-cache:\n// Opt into caching\nfetch(`https://...`, { cache: 'force-cache' })\nSee the fetch API Reference for more options.\nfetch options.next.revalidate\n\nYou can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.\n// Revalidate at most after 1 hour\nfetch(`https://...`, { next: { revalidate: 3600 } })\nSee the fetch API reference for more options.\nfetch options.next.tags and revalidateTag\n\nNext.js has a cache tagging system for fine-grained data caching and revalidation.\n\nWhen using fetch or unstable_cache, you have the option to tag cache entries with one or more tags.\nThen, you can call revalidateTag to purge the cache entries associated with that tag.\n\nFor example, you can set a tag when fetching data:\n// Cache data with a tag\nfetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })\nThen, call revalidateTag with a tag to purge the cache entry:\n// Revalidate entries with a specific tag\nrevalidateTag('a')\nThere are two places you can use revalidateTag, depending on what you're trying to achieve:\n\nRoute Handlers - to revalidate data in response of a third party event (e.g. webhook). This will not invalidate the Router Cache immediately as the Router Handler isn't tied to a specific route.\nServer Actions - to revalidate data after a user action (e.g. form submission). This will invalidate the Router Cache for the associated route.\n\nrevalidatePath\n\nrevalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.\nrevalidatePath('/')\nThere are two places you can use revalidatePath, depending on what you're trying to achieve:\n\nRoute Handlers - to revalidate data in response to a third party event (e.g. webhook).\nServer Actions - to revalidate data after a user interaction (e.g. form submission, clicking a button).\n\nSee the revalidatePath API reference for more information.\n\nrevalidatePath vs. router.refresh:\nCalling router.refresh will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache.\nThe difference is that revalidatePath purges the Data Cache and Full Route Cache, whereas router.refresh() does not change the Data Cache and Full Route Cache, as it is a client-side API.\n\nDynamic APIs\n\nDynamic APIs like cookies and headers, and the searchParams prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.\ncookies\n\nUsing cookies.set or cookies.delete in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes).\nSee the cookies API reference.\nSegment Config Options\n\nThe Route Segment Config options can be used to override the route segment defaults or when you're not able to use the fetch API (e.g. database client or 3rd party libraries).\nThe following Route Segment Config options will opt out of the Full Route Cache:\n\nconst dynamic = 'force-dynamic'\n\nThis config option will opt all fetches out of the Data Cache (i.e. no-store):\n\nconst fetchCache = 'default-no-store'\n\nSee the fetchCache to see more advanced options.\nSee the Route Segment Config documentation for more options.\ngenerateStaticParams\n\nFor dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited.\nTo statically render all paths at build time, supply the full list of paths to generateStaticParams:\napp/blog/[slug]/page.jsexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n\n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\nTo statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:\napp/blog/[slug]/page.jsexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n\n  // Render the first 10 posts at build time\n  return posts.slice(0, 10).map((post) => ({\n    slug: post.slug,\n  }))\n}\nTo statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static':\napp/blog/[slug]/page.jsexport async function generateStaticParams() {\n  return []\n}\n\nGood to know: You must return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.\n\napp/changelog/[slug]/page.jsexport const dynamic = 'force-static'\nTo disable caching at request time, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and other routes will 404 or match (in the case of catch-all routes).\nReact cache function\n\nThe React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.\nSince fetch requests are automatically memoized, you do not need to wrap it in React cache. However, you can use cache to manually memoize data requests for use cases when the fetch API is not suitable. For example, some database clients, CMS clients, or GraphQL clients.\nutils/get-item.tsTypeScriptJavaScriptTypeScriptimport { cache } from 'react'\nimport db from '@/lib/db'\n\nexport const getItem = cache(async (id: string) => {\n  const item = await db.item.findUnique({ id })\n  return item\n})\nPreviousBackend for FrontendNextCI Build CachingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/ci-build-caching", "content": "chingHow to configure Continuous Integration (CI) build cachingTo improve build performance, Next.js saves a cache to .next/cache that is shared between builds.\nTo take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly persist the cache between builds.\n\nIf your CI is not configured to persist .next/cache between builds, you may see a No Cache Detected error.\n\nHere are some example cache configurations for common CI providers:\nVercel\n\nNext.js caching is automatically configured for you. There's no action required on your part. If you are using Turborepo on Vercel, learn more here.\nCircleCI\n\nEdit your save_cache step in .circleci/config.yml to include .next/cache:\nsteps:\n  - save_cache:\n      key: dependency-cache-{{ checksum \"yarn.lock\" }}\n      paths:\n        - ./node_modules\n        - ./.next/cache\nIf you do not have a save_cache key, please follow CircleCI's documentation on setting up build caching.\nTravis CI\n\nAdd or merge the following into your .travis.yml:\ncache:\n  directories:\n    - $HOME/.cache/yarn\n    - node_modules\n    - .next/cache\nGitLab CI\n\nAdd or merge the following into your .gitlab-ci.yml:\ncache:\n  key: ${CI_COMMIT_REF_SLUG}\n  paths:\n    - node_modules/\n    - .next/cache/\nNetlify CI\n\nUse Netlify Plugins with @netlify/plugin-nextjs.\nAWS CodeBuild\n\nAdd (or merge in) the following to your buildspec.yml:\ncache:\n  paths:\n    - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`\n    - '.next/cache/**/*' # Cache Next.js for faster application rebuilds\nGitHub Actions\n\nUsing GitHub's actions/cache, add the following step in your workflow file:\nuses: actions/cache@v4\nwith:\n  # See here for caching with `yarn`, `bun` or other package managers https://github.com/actions/cache/blob/main/examples.md or you can leverage caching with actions/setup-node https://github.com/actions/setup-node\n  path: |\n    ~/.npm\n    ${{ github.workspace }}/.next/cache\n  # Generate a new cache whenever packages or source files change.\n  key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}\n  # If source files changed but packages didn't, rebuild from a prior cache.\n  restore-keys: |\n    ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-\nBitbucket Pipelines\n\nAdd or merge the following into your bitbucket-pipelines.yml at the top level (same level as pipelines):\ndefinitions:\n  caches:\n    nextcache: .next/cache\nThen reference it in the caches section of your pipeline's step:\n- step:\n    name: your_step_name\n    caches:\n      - node\n      - nextcache\nHeroku\n\nUsing Heroku's custom cache, add a cacheDirectories array in your top-level package.json:\n\"cacheDirectories\": [\".next/cache\"]\nAzure Pipelines\n\nUsing Azure Pipelines' Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executes next build:\n- task: Cache@2\n  displayName: 'Cache .next/cache'\n  inputs:\n    key: next | $(Agent.OS) | yarn.lock\n    path: '$(System.DefaultWorkingDirectory)/.next/cache'\nJenkins (Pipeline)\n\nUsing Jenkins' Job Cacher plugin, add the following build step to your Jenkinsfile where you would normally run next build or npm install:\nstage(\"Restore npm packages\") {\n    steps {\n        // Writes lock-file to cache based on the GIT_COMMIT hash\n        writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\"\n\n        cache(caches: [\n            arbitraryFileCache(\n                path: \"node_modules\",\n                includes: \"**/*\",\n                cacheValidityDecidingFile: \"package-lock.json\"\n            )\n        ]) {\n            sh \"npm install\"\n        }\n    }\n}\nstage(\"Build\") {\n    steps {\n        // Writes lock-file to cache based on the GIT_COMMIT hash\n        writeFile file: \"next-lock.cache\", text: \"$GIT_COMMIT\"\n\n        cache(caches: [\n            arbitraryFileCache(\n                path: \".next/cache\",\n                includes: \"**/*\",\n                cacheValidityDecidingFile: \"next-lock.cache\"\n            )\n        ]) {\n            // aka `next build`\n            sh \"npm run build\"\n        }\n    }\n}PreviousCachingNextContent Security PolicyWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/content-security-policy", "content": "urity PolicyHow to set a Content Security Policy (CSP) for your Next.js application\nContent Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.\nBy using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.\nExamples\nStrict CSP\n\nNonces\n\nA nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.\nWhy use a nonce?\n\nEven though CSPs are designed to block malicious scripts, there are legitimate scenarios where inline scripts are necessary. In such cases, nonces offer a way to allow these scripts to execute if they have the correct nonce.\nAdding a nonce with Middleware\n\nMiddleware enables you to add headers and generate nonces before the page renders.\nEvery time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces.\nFor example:\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n  // Replace newline characters and spaces\n  const contentSecurityPolicyHeaderValue = cspHeader\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n\n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-nonce', nonce)\n\n  requestHeaders.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n\n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n  response.headers.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n\n  return response\n}\n\nBy default, Middleware runs on all requests. You can filter Middleware to run on specific paths using a matcher.\nWe recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header.\nmiddleware.tsTypeScriptJavaScriptTypeScriptexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    {\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\n      missing: [\n        { type: 'header', key: 'next-router-prefetch' },\n        { type: 'header', key: 'purpose', value: 'prefetch' },\n      ],\n    },\n  ],\n}\n\nReading the nonce\n\nYou can read the nonce from a Server Component using headers:app/page.tsxTypeScriptJavaScriptTypeScriptimport { headers } from 'next/headers'\nimport Script from 'next/script'\n\nexport default async function Page() {\n  const nonce = (await headers()).get('x-nonce')\n\n  return (\n    <Script\n      src=\"https://www.googletagmanager.com/gtag/js\"\n      strategy=\"afterInteractive\"\n      nonce={nonce}\n    />\n  )\n}\nWithout Nonces\n\nFor applications that do not require nonces, you can set the CSP header directly in your next.config.js file:\nnext.config.jsconst cspHeader = `\n    default-src 'self';\n    script-src 'self' 'unsafe-eval' 'unsafe-inline';\n    style-src 'self' 'unsafe-inline';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'Content-Security-Policy',\n            value: cspHeader.replace(/\\n/g, ''),\n          },\n        ],\n      },\n    ]\n  },\n}\nVersion History\n\nWe recommend using v13.4.20+ of Next.js to properly handle and apply nonces.Next Stepsmiddleware.jsAPI reference for the middleware.js file.headersAPI reference for the headers function.PreviousCI Build CachingNextCSS-in-JSWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/css-in-js", "content": "w to use CSS-in-JS libraries\n\nWarning: Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, including concurrent rendering.\nThe following libraries are supported in Client Components in the app directory (alphabetical):\nant-design\nchakra-ui\n@fluentui/react-components\nkuma-ui\n@mui/material\n@mui/joy\npandacss\nstyled-jsx\nstyled-components\nstylex\ntamagui\ntss-react\nvanilla-extract\nThe following are currently working on support:\nemotion\n\nGood to know: We're testing out different CSS-in-JS libraries and we'll be adding more examples for libraries that support React 18 features and/or the app directory.\nConfiguring CSS-in-JS in app\n\nConfiguring CSS-in-JS is a three-step opt-in process that involves:\nA style registry to collect all CSS rules in a render.\nThe new useServerInsertedHTML hook to inject rules before any content that might use them.\nA Client Component that wraps your app with the style registry during initial server-side rendering.\nstyled-jsx\n\nUsing styled-jsx in Client Components requires using v5.1.0. First, create a new registry:app/registry.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport React, { useState } from 'react'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\n\nexport default function StyledJsxRegistry({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // Only create stylesheet once with lazy initial state\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n  const [jsxStyleRegistry] = useState(() => createStyleRegistry())\n\n  useServerInsertedHTML(() => {\n    const styles = jsxStyleRegistry.styles()\n    jsxStyleRegistry.flush()\n    return <>{styles}</>\n  })\n\n  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>\n}Then, wrap your root layout with the registry:app/layout.tsxTypeScriptJavaScriptTypeScriptimport StyledJsxRegistry from './registry'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        <StyledJsxRegistry>{children}</StyledJsxRegistry>\n      </body>\n    </html>\n  )\n}View an example here.Styled Components\n\nBelow is an example of how to configure styled-components@6 or newer:First, enable styled-components in next.config.js.next.config.jsmodule.exports = {\n  compiler: {\n    styledComponents: true,\n  },\n}Then, use the styled-components API to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use the useServerInsertedHTML hook to inject the styles collected in the registry into the <head> HTML tag in the root layout.lib/registry.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport React, { useState } from 'react'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\n\nexport default function StyledComponentsRegistry({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // Only create stylesheet once with lazy initial state\n  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())\n\n  useServerInsertedHTML(() => {\n    const styles = styledComponentsStyleSheet.getStyleElement()\n    styledComponentsStyleSheet.instance.clearTag()\n    return <>{styles}</>\n  })\n\n  if (typeof window !== 'undefined') return <>{children}</>\n\n  return (\n    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>\n      {children}\n    </StyleSheetManager>\n  )\n}Wrap the children of the root layout with the style registry component:app/layout.tsxTypeScriptJavaScriptTypeScriptimport StyledComponentsRegistry from './lib/registry'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        <StyledComponentsRegistry>{children}</StyledComponentsRegistry>\n      </body>\n    </html>\n  )\n}View an example here.\nGood to know:\n\nDuring server rendering, styles will be extracted to a global registry and flushed to the <head> of your HTML. This ensures the style rules are placed before any content that might use them. In the future, we may use an upcoming React feature to determine where to inject the styles.\nDuring streaming, styles from each chunk will be collected and appended to existing styles. After client-side hydration is complete, styled-components will take over as usual and inject any further dynamic styles.\nWe specifically use a Client Component at the top level of the tree for the style registry because it's more efficient to extract CSS rules this way. It avoids re-generating styles on subsequent server renders, and prevents them from being sent in the Server Component payload.\nFor advanced use cases where you need to configure individual properties of styled-components compilation, you can read our Next.js styled-components API reference to learn more.\n\nPreviousContent Security PolicyNextCustom ServerWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/custom-server", "content": "erHow to set up a custom server in Next.js\nNext.js includes its own server with next start by default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject.\n\nGood to know:\n\nBefore deciding to use a custom server, keep in mind that it should only be used when the integrated router of Next.js can't meet your app requirements. A custom server will remove important performance optimizations, like Automatic Static Optimization.\nWhen using standalone output mode, it does not trace custom server files. This mode outputs a separate minimal server.js file, instead. These cannot be used together.\n\nTake a look at the following example of a custom server:\nserver.tsTypeScriptJavaScriptTypeScriptimport { createServer } from 'http'\nimport { parse } from 'url'\nimport next from 'next'\n\nconst port = parseInt(process.env.PORT || '3000', 10)\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  createServer((req, res) => {\n    const parsedUrl = parse(req.url!, true)\n    handle(req, res, parsedUrl)\n  }).listen(port)\n\n  console.log(\n    `> Server listening at http://localhost:${port} as ${\n      dev ? 'development' : process.env.NODE_ENV\n    }`\n  )\n})\n\nserver.js does not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using. View an example.\n\nTo run the custom server, you'll need to update the scripts in package.json like so:\npackage.json{\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"next build\",\n    \"start\": \"NODE_ENV=production node server.js\"\n  }\n}\nAlternatively, you can set up nodemon (example). The custom server uses the following import to connect the server with the Next.js application:\nimport next from 'next'\n\nconst app = next({})\nThe above next import is a function that receives an object with the following options:\nOptionTypeDescriptionconfObjectThe same object you would use in next.config.js. Defaults to {}devBoolean(Optional) Whether or not to launch Next.js in dev mode. Defaults to falsedirString(Optional) Location of the Next.js project. Defaults to '.'quietBoolean(Optional) Hide error messages containing server information. Defaults to falsehostnameString(Optional) The hostname the server is running behindportNumber(Optional) The port the server is running behindhttpServernode:http#Server(Optional) The HTTP Server that Next.js is running behindturboBoolean(Optional) Enable Turbopack\nThe returned app can then be used to let Next.js handle requests as required.\nPreviousCSS-in-JSNextData SecurityWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/data-security", "content": "tyHow to think about data security in Next.jsReact Server Components improve performance and simplify data fetching, but also shift where and how data is accessed, changing some of the traditional security assumptions for handling data in frontend apps.\nThis guide will help you understand how to think about data security in Next.js and how to implement best practices.\nData fetching approaches\n\nThere are three main approaches we recommend for fetching data in Next.js, depending on the size and age of your project:\n\nHTTP APIs: for existing large applications and organizations.\nData Access Layer: for new projects.\nComponent-Level Data Access: for prototypes and learning.\n\nWe recommend choosing one data fetching approach and avoiding mixing them. This makes it clear for both developers working in your code base and security auditors what to expect.\nExternal HTTP APIs\n\nYou should follow a Zero Trust model when adopting Server Components in an existing project. You can continue calling your existing API endpoints such as REST or GraphQL from Server Components using fetch, just as you would in Client Components.\napp/page.tsximport { cookies } from 'next/headers'\n\nexport default async function Page() {\n  const cookieStore = cookies()\n  const token = cookieStore.get('AUTH_TOKEN')?.value\n\n  const res = await fetch('https://api.example.com/profile', {\n    headers: {\n      Cookie: `AUTH_TOKEN=${token}`,\n      // Other headers\n    },\n  })\n\n  // ....\n}\nThis approach works well when:\n\nYou already have security practices in place.\nSeparate backend teams use other languages or manage APIs independently.\n\nData Access Layer\n\nFor new projects, we recommend creating a dedicated Data Access Layer (DAL). This is a internal library that controls how and when data is fetched, and what gets passed to your render context.\nA Data Access Layer should:\n\nOnly run on the server.\nPerform authorization checks.\nReturn safe, minimal Data Transfer Objects (DTOs).\n\nThis approach centralizes all data access logic, making it easier to enforce consistent data access and reduces the risk of authorization bugs. You also get the benefit of sharing an in-memory cache across different parts of a request.\ndata/auth.tsimport { cache } from 'react'\nimport { cookies } from 'next/headers'\n\n// Cached helper methods makes it easy to get the same value in many places\n// without manually passing it around. This discourages passing it from Server\n// Component to Server Component which minimizes risk of passing it to a Client\n// Component.\nexport const getCurrentUser = cache(async () => {\n  const token = cookies().get('AUTH_TOKEN')\n  const decodedToken = await decryptAndValidate(token)\n  // Don't include secret tokens or private information as public fields.\n  // Use classes to avoid accidentally passing the whole object to the client.\n  return new User(decodedToken.id)\n})\ndata/user-dto.tsximport 'server-only'\nimport { getCurrentUser } from './auth'\n\nfunction canSeeUsername(viewer: User) {\n  // Public info for now, but can change\n  return true\n}\n\nfunction canSeePhoneNumber(viewer: User, team: string) {\n  // Privacy rules\n  return viewer.isAdmin || team === viewer.team\n}\n\nexport async function getProfileDTO(slug: string) {\n  // Don't pass values, read back cached values, also solves context and easier to make it lazy\n\n  // use a database API that supports safe templating of queries\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`\n  const userData = rows[0]\n\n  const currentUser = await getCurrentUser()\n\n  // only return the data relevant for this query and not everything\n  // <https://www.w3.org/2001/tag/doc/APIMinimization>\n  return {\n    username: canSeeUsername(currentUser) ? userData.username : null,\n    phonenumber: canSeePhoneNumber(currentUser, userData.team)\n      ? userData.phonenumber\n      : null,\n  }\n}\napp/page.tsximport { getProfile } from '../../data/user'\n\nexport async function Page({ params: { slug } }) {\n  // This page can now safely pass around this profile knowing\n  // that it shouldn't contain anything sensitive.\n  const profile = await getProfile(slug);\n  ...\n}\n\nGood to know: Secret keys should be stored in environment variables, but only the Data Access Layer should access process.env. This keeps secrets from being exposed to other parts of the application.\n\nComponent-level data access\n\nFor quick prototypes and iteration, database queries can be placed directly in Server Components.\nThis approach, however, makes it easier to accidentally expose private data to the client, for example:\napp/page.tsximport Profile from './components/profile.tsx'\n\nexport async function Page({ params: { slug } }) {\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`\n  const userData = rows[0]\n  // EXPOSED: This exposes all the fields in userData to the client because\n  // we are passing the data from the Server Component to the Client.\n  return <Profile user={userData} />\n}\napp/ui/profile.tsx'use client'\n\n// BAD: This is a bad props interface because it accepts way more data than the\n// Client Component needs and it encourages server components to pass all that\n// data down. A better solution would be to accept a limited object with just\n// the fields necessary for rendering the profile.\nexport default async function Profile({ user }: { user: User }) {\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      ...\n    </div>\n  )\n}\nYou should sanitize the data before passing it to the Client Component:\ndata/user.tsimport { sql } from './db'\n\nexport async function getUser(slug: string) {\n  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`\n  const user = rows[0]\n\n  // Return only the public fields\n  return {\n    name: user.name,\n  }\n}\napp/page.tsximport { getUser } from '../data/user'\nimport Profile from './ui/profile'\n\nexport default async function Page({\n  params: { slug },\n}: {\n  params: { slug: string }\n}) {\n  const publicProfile = await getUser(slug)\n  return <Profile user={publicProfile} />\n}\nReading data\n\nPassing data from server to client\n\nOn the initial load, both Server and Client Components run on the server to generate HTML. However, they execute in isolated module systems. This ensures that Server Components can access private data and APIs, while Client Components cannot.\nServer Components:\n\nRun only on the server.\nCan safely access environment variables, secrets, databases, and internal APIs.\n\nClient Components:\n\nRun on the server during pre-rendering, but must follow the same security assumptions as code running in the browser.\nMust not access privileged data or server-only modules.\n\nThis ensures the app is secure by default, but it's possible to accidentally expose private data through how data is fetched or passed to components.\nTainting\n\nTo prevent accidental exposure of private data to the client, you can use React Taint APIs:\n\nexperimental_taintObjectReference for data objects.\nexperimental_taintUniqueValue for specific values.\n\nYou can enable usage in your Next.js app with the experimental.taint option in next.config.js:\nnext.config.jsmodule.exports = {\n  experimental: {\n    taint: true,\n  },\n}\nThis prevents the tainted objects or values from being passed to the client. However, it's an additional layer of protection, you should still filter and sanitize the data in your DAL before passing it to React's render context.\n\nGood to know:\n\nBy default, environment variables are only available on the Server. Next.js exposes any environment variable prefixed with NEXT_PUBLIC_ to the client. Learn more.\nFunctions and classes are already blocked from being passed to Client Components by default.\n\nPreventing client-side execution of server-only code\n\nTo prevent server-only code from being executed on the client, you can mark a module with the server-only package:\n\npnpmnpmyarnbunTerminalpnpm add server-only\nlib/data.tsimport 'server-only'\n\n//...\nThis ensures that proprietary code or internal business logic stays on the server by causing a build error if the module is imported in the client environment.\nMutating Data\n\nNext.js handles mutations with Server Actions.\nBuilt-in Server Actions Security features\n\nBy default, when a Server Action is created and exported, it creates a public HTTP endpoint and should be treated with the same security assumptions and authorization checks. This means, even if a Server Action or utility function is not imported elsewhere in your code, it's still publicly accessible.\nTo improve security, Next.js has the following built-in features:\n\nSecure action IDs: Next.js creates encrypted, non-deterministic IDs to allow the client to reference and call the Server Action. These IDs are periodically recalculated between builds for enhanced security.\nDead code elimination: Unused Server Actions (referenced by their IDs) are removed from client bundle to avoid public access.\n\nGood to know:\nThe IDs are created during compilation and are cached for a maximum of 14 days. They will be regenerated when a new build is initiated or when the build cache is invalidated.\nThis security improvement reduces the risk in cases where an authentication layer is missing. However, you should still treat Server Actions like public HTTP endpoints.\n\n// app/actions.js\n'use server'\n\n// If this action **is** used in our application, Next.js\n// will create a secure ID to allow the client to reference\n// and call the Server Action.\nexport async function updateUserAction(formData) {}\n\n// If this action **is not** used in our application, Next.js\n// will automatically remove this code during `next build`\n// and will not create a public endpoint.\nexport async function deleteUserAction(formData) {}\nValidating client input\n\nYou should always validate input from client, as they can be easily modified. For example, form data, URL parameters, headers, and searchParams:\napp/page.tsx// BAD: Trusting searchParams directly\nexport default async function Page({ searchParams }) {\n  const isAdmin = searchParams.get('isAdmin')\n  if (isAdmin === 'true') {\n    // Vulnerable: relies on untrusted client data\n    return <AdminPanel />\n  }\n}\n\n// GOOD: Re-verify every time\nimport { cookies } from 'next/headers'\nimport { verifyAdmin } from './auth'\n\nexport default async function Page() {\n  const token = cookies().get('AUTH_TOKEN')\n  const isAdmin = await verifyAdmin(token)\n\n  if (isAdmin) {\n    return <AdminPanel />\n  }\n}\nAuthentication and authorization\n\nYou should always ensure that a user is authorized to perform an action. For example:\napp/actions.ts'use server'\n\nimport { auth } from './lib'\n\nexport function addItem() {\n  const { user } = auth()\n  if (!user) {\n    throw new Error('You must be signed in to perform this action')\n  }\n\n  // ...\n}\nLearn more about Authentication in Next.js.\nClosures and encryption\n\nDefining a Server Action inside a component creates a closure where the action has access to the outer function's scope. For example, the publish action has access to the publishVersion variable:\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  const publishVersion = await getLatestVersion();\n\n  async function publish() {\n    \"use server\";\n    if (publishVersion !== await getLatestVersion()) {\n      throw new Error('The version has changed since pressing publish');\n    }\n    ...\n  }\n\n  return (\n    <form>\n      <button formAction={publish}>Publish</button>\n    </form>\n  );\n}\n\nClosures are useful when you need to capture a snapshot of data (e.g. publishVersion) at the time of rendering so that it can be used later when the action is invoked.\nHowever, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build.\n\nGood to know: We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client.\n\nOverwriting encryption keys (advanced)\n\nWhen self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key, leading to potential inconsistencies.\nTo mitigate this, you can overwrite the encryption key using the process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY environment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances use the same key. This variable must be AES-GCM encrypted.\nThis is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You should consider standard security practices such key rotation and signing.\n\nGood to know: Next.js applications deployed to Vercel automatically handle this.\n\nAllowed origins (advanced)\n\nSince Server Actions can be invoked in a <form> element, this opens them up to CSRF attacks.\nBehind the scenes, Server Actions use the POST method, and only this HTTP method is allowed to invoke them. This prevents most CSRF vulnerabilities in modern browsers, particularly with SameSite cookies being the default.\nAs an additional protection, Server Actions in Next.js also compare the Origin header to the Host header (or X-Forwarded-Host). If these don't match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that hosts it.\nFor large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration option serverActions.allowedOrigins option to specify a list of safe origins. The option accepts an array of strings.\nnext.config.js/** @type {import('next').NextConfig} */\nmodule.exports = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],\n    },\n  },\n}\nLearn more about Security and Server Actions.\nAvoiding side-effects during rendering\n\nMutations (e.g. logging out users, updating databases, invalidating caches) should never be a side-effect, either in Server or Client Components. Next.js explicitly prevents setting cookies or triggering cache revalidation within render methods to avoid unintended side effects.\napp/page.tsx// BAD: Triggering a mutation during rendering\nexport default async function Page({ searchParams }) {\n  if (searchParams.get('logout')) {\n    cookies().delete('AUTH_TOKEN')\n  }\n\n  return <UserProfile />\n}\nInstead, you should use Server Actions to handle mutations.\napp/page.tsx// GOOD: Using Server Actions to handle mutations\nimport { logout } from './actions'\n\nexport default function Page() {\n  return (\n    <>\n      <UserProfile />\n      <form action={logout}>\n        <button type=\"submit\">Logout</button>\n      </form>\n    </>\n  )\n}\n\nGood to know: Next.js uses POST requests to handle mutations. This prevents accidental side-effects from GET requests, reducing Cross-Site Request Forgery (CSRF) risks.\n\nAuditing\n\nIf you're doing an audit of a Next.js project, here are a few things we recommend looking extra at:\n\nData Access Layer: Is there an established practice for an isolated Data Access Layer? Verify that database packages and environment variables are not imported outside the Data Access Layer.\n\"use client\" files: Are the Component props expecting private data? Are the type signatures overly broad?\n\"use server\" files: Are the Action arguments validated in the action or inside the Data Access Layer? Is the user re-authorized inside the action?\n/[param]/. Folders with brackets are user input. Are params validated?\nmiddleware.tsx and route.tsx: Have a lot of power. Spend extra time auditing these using traditional techniques. Perform Penetration Testing or Vulnerability Scanning regularly or in alignment with your team's software development lifecycle.\nNext StepsLearn more about the topics mentioned in this guide.AuthenticationLearn how to implement authentication in your Next.js application.Content Security PolicyLearn how to set a Content Security Policy (CSP) for your Next.js application.FormsLearn how to create forms in Next.js with React Server Actions.PreviousCustom ServerNextDebuggingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/debugging", "content": "w to use debugging tools with Next.js\nThis documentation explains how you can debug your Next.js frontend and backend code with full source maps support using the VS Code debugger, Chrome DevTools, or Firefox DevTools.\nAny debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.js Debugging Guide.\nDebugging with VS Code\n\nCreate a file named .vscode/launch.json at the root of your project with the following content:\nlaunch.json{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Next.js: debug server-side\",\n      \"type\": \"node-terminal\",\n      \"request\": \"launch\",\n      \"command\": \"npm run dev\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side\",\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side (Firefox)\",\n      \"type\": \"firefox\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\",\n      \"reAttach\": true,\n      \"pathMappings\": [\n        {\n          \"url\": \"webpack://_N_E\",\n          \"path\": \"${workspaceFolder}\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Next.js: debug full stack\",\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/node_modules/next/dist/bin/next\",\n      \"runtimeArgs\": [\"--inspect\"],\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"serverReadyAction\": {\n        \"action\": \"debugWithEdge\",\n        \"killOnServerStop\": true,\n        \"pattern\": \"- Local:.+(https?://.+)\",\n        \"uriFormat\": \"%s\",\n        \"webRoot\": \"${workspaceFolder}\"\n      }\n    }\n  ]\n}\n\nNote: To use Firefox debugging in VS Code, you'll need to install the Firefox Debugger extension.\n\nnpm run dev can be replaced with yarn dev if you're using Yarn or pnpm dev if you're using pnpm.\nIn the \"Next.js: debug full stack\" configuration, serverReadyAction.action specifies which browser to open when the server is ready. debugWithEdge means to launch the Edge browser. If you are using Chrome, change this value to debugWithChrome.\nIf you're changing the port number your application starts on, replace the 3000 in http://localhost:3000 with the port you're using instead.\nIf you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to add cwd to the server-side and full stack debugging tasks. For example, \"cwd\": \"${workspaceFolder}/apps/web\".\nNow go to the Debug panel (Ctrl+Shift+D on Windows/Linux, \u21e7+\u2318+D on macOS), select a launch configuration, then press F5 or select Debug: Start Debugging from the Command Palette to start your debugging session.\nUsing the Debugger in Jetbrains WebStorm\n\nClick the drop down menu listing the runtime configuration, and click Edit Configurations.... Create a JavaScript Debug debug configuration with http://localhost:3000 as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and click OK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application.\nDebugging with Browser DevTools\n\nClient-side code\n\nStart your development server as usual by running next dev, npm run dev, or yarn dev. Once the server starts, open http://localhost:3000 (or your alternate URL) in your preferred browser.\nFor Chrome:\n\nOpen Chrome's Developer Tools (Ctrl+Shift+J on Windows/Linux, \u2325+\u2318+I on macOS)\nGo to the Sources tab\n\nFor Firefox:\n\nOpen Firefox's Developer Tools (Ctrl+Shift+I on Windows/Linux, \u2325+\u2318+I on macOS)\nGo to the Debugger tab\n\nIn either browser, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually:\n\nIn Chrome: Press Ctrl+P on Windows/Linux or \u2318+P on macOS\nIn Firefox: Press Ctrl+P on Windows/Linux or \u2318+P on macOS, or use the file tree in the left panel\n\nNote that when searching, your source files will have paths starting with webpack://_N_E/./.\nServer-side code\n\nTo debug server-side Next.js code with browser DevTools, you need to pass the --inspect flag to the underlying Node.js process:\nTerminalNODE_OPTIONS='--inspect' next dev\n\nGood to know: Use NODE_OPTIONS='--inspect=0.0.0.0' to allow remote debugging access outside localhost, such as when running the app in a Docker container.\n\nIf you're using npm run dev or yarn dev then you should update the dev script on your package.json:\npackage.json{\n  \"scripts\": {\n    \"dev\": \"NODE_OPTIONS='--inspect' next dev\"\n  }\n}\nLaunching the Next.js dev server with the --inspect flag will look something like this:\nTerminalDebugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95\nFor help, see: https://nodejs.org/en/docs/inspector\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\nFor Chrome:\n\nOpen a new tab and visit chrome://inspect\nClick Configure... to ensure both debugging ports are listed\nAdd both localhost:9229 and localhost:9230 if they're not already present\nLook for your Next.js application in the Remote Target section\nClick inspect to open a separate DevTools window\nGo to the Sources tab\n\nFor Firefox:\n\nOpen a new tab and visit about:debugging\nClick This Firefox in the left sidebar\nUnder Remote Targets, find your Next.js application\nClick Inspect to open the debugger\nGo to the Debugger tab\n\nDebugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/\u2318+P), your source files will have paths starting with webpack://{application-name}/./ (where {application-name} will be replaced with the name of your application according to your package.json file).\nInspect Server Errors with Browser DevTools\n\nWhen you encounter an error, inspecting the source code can help trace the root cause of errors.\nNext.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process.\nDebugging on Windows\n\nWindows users may run into an issue when using NODE_OPTIONS='--inspect' as that syntax is not supported on Windows platforms. To get around this, install the cross-env package as a development dependency (-D with npm and yarn) and replace the dev script with the following.\npackage.json{\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_OPTIONS='--inspect' next dev\"\n  }\n}\ncross-env will set the NODE_OPTIONS environment variable regardless of which platform you are on (including Mac, Linux, and Windows) and allow you to debug consistently across devices and operating systems.\n\nGood to know: Ensure Windows Defender is disabled on your machine. This external service will check every file read, which has been reported to greatly increase Fast Refresh time with next dev. This is a known issue, not related to Next.js, but it does affect Next.js development.\n\nMore information\n\nTo learn more about how to use a JavaScript debugger, take a look at the following documentation:\n\nNode.js debugging in VS Code: Breakpoints\nChrome DevTools: Debug JavaScript\nFirefox DevTools: Debugger\nPreviousData SecurityNextDraft ModeWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/draft-mode", "content": "ow to preview content with Draft Mode in Next.jsDraft Mode allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to dynamic rendering and see the draft changes without having to rebuild your entire site.\nThis page walks through how to enable and use Draft Mode.\nStep 1: Create a Route Handler\n\nCreate a Route Handler. It can have any name, for example, app/api/draft/route.ts.\napp/api/draft/route.tsTypeScriptJavaScriptTypeScriptexport async function GET(request: Request) {\n  return new Response('')\n}\n\nThen, import the draftMode function and call the enable() method.\napp/api/draft/route.tsTypeScriptJavaScriptTypeScriptimport { draftMode } from 'next/headers'\n\nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.enable()\n  return new Response('Draft mode is enabled')\n}\n\nThis will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger draft mode and change the behavior of statically generated pages.\nYou can test this manually by visiting /api/draft and looking at your browser\u2019s developer tools. Notice the Set-Cookie response header with a cookie named __prerender_bypass.\nStep 2: Access the Route Handler from your Headless CMS\n\nThese steps assume that the headless CMS you\u2019re using supports setting custom draft URLs. If it doesn\u2019t, you can still use this method to secure your draft URLs, but you\u2019ll need to construct and access the draft URL manually. The specific steps will vary depending on which headless CMS you\u2019re using.\n\nTo securely access the Route Handler from your headless CMS:\n\nCreate a secret token string using a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS.\nIf your headless CMS supports setting custom draft URLs, specify a draft URL (this assumes that your Route Handler is located at app/api/draft/route.ts). For example:\n\nTerminalhttps://<your-site>/api/draft?secret=<token>&slug=<path>\n\n<your-site> should be your deployment domain.\n<token> should be replaced with the secret token you generated.\n<path> should be the path for the page that you want to view. If you want to view /posts/one, then you should use &slug=/posts/one.\n\nYour headless CMS might allow you to include a variable in the draft URL so that <path> can be set dynamically based on the CMS\u2019s data like so: &slug=/posts/{entry.fields.slug}\n\nIn your Route Handler, check that the secret matches and that the slug parameter exists (if not, the request should fail), call draftMode.enable() to set the cookie. Then, redirect the browser to the path specified by slug:\n\napp/api/draft/route.tsTypeScriptJavaScriptTypeScriptimport { draftMode } from 'next/headers'\nimport { redirect } from 'next/navigation'\n\nexport async function GET(request: Request) {\n  // Parse query string parameters\n  const { searchParams } = new URL(request.url)\n  const secret = searchParams.get('secret')\n  const slug = searchParams.get('slug')\n\n  // Check the secret and next parameters\n  // This secret should only be known to this Route Handler and the CMS\n  if (secret !== 'MY_SECRET_TOKEN' || !slug) {\n    return new Response('Invalid token', { status: 401 })\n  }\n\n  // Fetch the headless CMS to check if the provided `slug` exists\n  // getPostBySlug would implement the required fetching logic to the headless CMS\n  const post = await getPostBySlug(slug)\n\n  // If the slug doesn't exist prevent draft mode from being enabled\n  if (!post) {\n    return new Response('Invalid slug', { status: 401 })\n  }\n\n  // Enable Draft Mode by setting the cookie\n  const draft = await draftMode()\n  draft.enable()\n\n  // Redirect to the path from the fetched post\n  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities\n  redirect(post.slug)\n}\n\nIf it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.\nStep 3: Preview the Draft Content\n\nThe next step is to update your page to check the value of draftMode().isEnabled.\nIf you request a page which has the cookie set, then data will be fetched at request time (instead of at build time).\nFurthermore, the value of isEnabled will be true.\napp/page.tsxTypeScriptJavaScriptTypeScript// page that fetches data\nimport { draftMode } from 'next/headers'\n\nasync function getData() {\n  const { isEnabled } = await draftMode()\n\n  const url = isEnabled\n    ? 'https://draft.example.com'\n    : 'https://production.example.com'\n\n  const res = await fetch(url)\n\n  return res.json()\n}\n\nexport default async function Page() {\n  const { title, desc } = await getData()\n\n  return (\n    <main>\n      <h1>{title}</h1>\n      <p>{desc}</p>\n    </main>\n  )\n}\n\nIf you access the draft Route Handler (with secret and slug) from your headless CMS or manually using the URL, you should now be able to see the draft content. And, if you update your draft without publishing, you should be able to view the draft.Next StepsSee the API reference for more information on how to use Draft Mode.draftModeAPI Reference for the draftMode function.PreviousDebuggingNextEnvironment VariablesWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/environment-variables", "content": "VariablesHow to use environment variables in Next.js\nNext.js comes with built-in support for environment variables, which allows you to do the following:\n\nUse .env to load environment variables\nBundle environment variables for the browser by prefixing with NEXT_PUBLIC_\n\nWarning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository.\n\nLoading Environment Variables\n\nNext.js has built-in support for loading environment variables from .env* files into process.env.\n.envDB_HOST=localhost\nDB_USER=myuser\nDB_PASS=mypassword\n\nNote: Next.js also supports multiline variables inside of your .env* files:\n# .env\n\n# you can write with line breaks\nPRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\n...\nKh9NV...\n...\n-----END DSA PRIVATE KEY-----\"\n\n# or with `\\n` inside double quotes\nPRIVATE_KEY=\"-----BEGIN RSA PRIVATE KEY-----\\nKh9NV...\\n-----END DSA PRIVATE KEY-----\\n\"\n\nNote: If you are using a /src folder, please note that Next.js will load the .env files only from the parent folder and not from the /src folder.\nThis loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Route Handlers.\nFor example:app/api/route.jsexport async function GET() {\n  const db = await myDB.connect({\n    host: process.env.DB_HOST,\n    username: process.env.DB_USER,\n    password: process.env.DB_PASS,\n  })\n  // ...\n}\nLoading Environment Variables with @next/env\n\nIf you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package.\nThis package is used internally by Next.js to load environment variables from .env* files.\nTo use it, install the package and use the loadEnvConfig function to load the environment variables:\nnpm install @next/env\nenvConfig.tsTypeScriptJavaScriptTypeScriptimport { loadEnvConfig } from '@next/env'\n\nconst projectDir = process.cwd()\nloadEnvConfig(projectDir)\n\nThen, you can import the configuration where needed. For example:\norm.config.tsTypeScriptJavaScriptTypeScriptimport './envConfig.ts'\n\nexport default defineConfig({\n  dbCredentials: {\n    connectionString: process.env.DATABASE_URL!,\n  },\n})\n\nReferencing Other Variables\n\nNext.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example:\n.envTWITTER_USER=nextjs\nTWITTER_URL=https://x.com/$TWITTER_USER\nIn the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs.\n\nGood to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \\$.\n\nBundling Environment Variables for the Browser\n\nNon-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).\nIn order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example:\nTerminalNEXT_PUBLIC_ANALYTICS_ID=abcdefghijk\nThis will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.\n\nNote: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).\n\npages/index.jsimport setupAnalyticsService from '../lib/my-analytics-service'\n\n// 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.\n// It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.\nsetupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)\n\nfunction HomePage() {\n  return <h1>Hello World</h1>\n}\n\nexport default HomePage\nNote that dynamic lookups will not be inlined, such as:\n// This will NOT be inlined, because it uses a variable\nconst varName = 'NEXT_PUBLIC_ANALYTICS_ID'\nsetupAnalyticsService(process.env[varName])\n\n// This will NOT be inlined, because it uses a variable\nconst env = process.env\nsetupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)\nRuntime Environment Variables\n\nNext.js can support both build time and runtime environment variables.\nBy default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.\n\nYou can safely read environment variables on the server during dynamic rendering:app/page.tsTypeScriptJavaScriptTypeScriptimport { connection } from 'next/server'\n\nexport default async function Component() {\n  await connection()\n  // cookies, headers, and other Dynamic APIs\n  // will also opt into dynamic rendering, meaning\n  // this env variable is evaluated at runtime\n  const value = process.env.MY_VALUE\n  // ...\n}\nThis allows you to use a singular Docker image that can be promoted through multiple environments with different values.\nGood to know:\n\nYou can run code on server startup using the register function.\nWe do not recommend using the runtimeConfig option, as this does not work with the standalone output mode. Instead, we recommend incrementally adopting the App Router if you need this feature.\n\nTest Environment Variables\n\nApart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment.\nThis one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you.\nThere is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set).\n\nGood to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore.\n\nWhile running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package.\n// The below can be used in a Jest global setup file or similar for your testing set-up\nimport { loadEnvConfig } from '@next/env'\n\nexport default async () => {\n  const projectDir = process.cwd()\n  loadEnvConfig(projectDir)\n}\nEnvironment Variable Load Order\n\nEnvironment variables are looked up in the following places, in order, stopping once the variable is found.\n\nprocess.env\n.env.$(NODE_ENV).local\n.env.local (Not checked when NODE_ENV is test.)\n.env.$(NODE_ENV)\n.env\n\nFor example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used.\n\nGood to know: The allowed values for NODE_ENV are production, development and test.\n\nGood to know\n\nIf you are using a /src directory, .env.* files should remain in the root of your project.\nIf the environment variable NODE_ENV is unassigned, Next.js automatically assigns development when running the next dev command, or production for all other commands.\n\nVersion History\n\nVersionChangesv9.4.0Support .env and NEXT_PUBLIC_ introduced.PreviousDraft ModeNextFormsWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/forms", "content": "create forms with Server ActionsReact Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions.\nHow it works\n\nReact extends the HTML <form> element to allow Server Actions to be invoked with the action attribute.\nWhen used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods:\napp/invoices/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() {\n  async function createInvoice(formData: FormData) {\n    'use server'\n\n    const rawFormData = {\n      customerId: formData.get('customerId'),\n      amount: formData.get('amount'),\n      status: formData.get('status'),\n    }\n\n    // mutate data\n    // revalidate the cache\n  }\n\n  return <form action={createInvoice}>...</form>\n}\n\nGood to know: When working with forms that have multiple fields, you can use the entries() method with JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData).\n\nPassing additional arguments\n\nOutside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function:\napp/client-component.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { updateUser } from './actions'\n\nexport function UserProfile({ userId }: { userId: string }) {\n  const updateUserWithId = updateUser.bind(null, userId)\n\n  return (\n    <form action={updateUserWithId}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Update User Name</button>\n    </form>\n  )\n}\n\nThe Server Function will receive the userId as an additional argument:\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nexport async function updateUser(userId: string, formData: FormData) {}\n\nGood to know:\n\nAn alternative is to pass arguments as hidden input fields in the form (e.g. <input type=\"hidden\" name=\"userId\" value={userId} />). However, the value will be part of the rendered HTML and will not be encoded.\nbind works in both Server and Client Components and supports progressive enhancement.\n\nForm validation\n\nForms can be validated on the client or server.\n\nFor client-side validation, you can use the HTML attributes like required and type=\"email\" for basic validation.\nFor server-side validation, you can use a library like zod to validate the form fields. For example:\n\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { z } from 'zod'\n\nconst schema = z.object({\n  email: z.string({\n    invalid_type_error: 'Invalid Email',\n  }),\n})\n\nexport default async function createUser(formData: FormData) {\n  const validatedFields = schema.safeParse({\n    email: formData.get('email'),\n  })\n\n  // Return early if the form data is invalid\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    }\n  }\n\n  // Mutate data\n}\n\nValidation errors\n\nTo display validation errors or messages, turn the component that defines the <form> into a Client Component and use React useActionState.\nWhen using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument.\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { z } from 'zod'\n\nexport async function createUser(initialState: any, formData: FormData) {\n  const validatedFields = schema.safeParse({\n    email: formData.get('email'),\n  })\n  // ...\n}\n\nYou can then conditionally render the error message based on the state object.\napp/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useActionState } from 'react'\nimport { createUser } from '@/app/actions'\n\nconst initialState = {\n  message: '',\n}\n\nexport function Signup() {\n  const [state, formAction, pending] = useActionState(createUser, initialState)\n\n  return (\n    <form action={formAction}>\n      <label htmlFor=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" name=\"email\" required />\n      {/* ... */}\n      <p aria-live=\"polite\">{state?.message}</p>\n      <button disabled={pending}>Sign up</button>\n    </form>\n  )\n}\n\nPending states\n\nThe useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed.\napp/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useActionState } from 'react'\nimport { createUser } from '@/app/actions'\n\nexport function Signup() {\n  const [state, formAction, pending] = useActionState(createUser, initialState)\n\n  return (\n    <form action={formAction}>\n      {/* Other form elements */}\n      <button disabled={pending}>Sign up</button>\n    </form>\n  )\n}\n\nAlternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:\napp/ui/button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useFormStatus } from 'react-dom'\n\nexport function SubmitButton() {\n  const { pending } = useFormStatus()\n\n  return (\n    <button disabled={pending} type=\"submit\">\n      Sign Up\n    </button>\n  )\n}\n\nYou can then nest the SubmitButton component inside the form:\napp/ui/signup.tsxTypeScriptJavaScriptTypeScriptimport { SubmitButton } from './button'\nimport { createUser } from '@/app/actions'\n\nexport function Signup() {\n  return (\n    <form action={createUser}>\n      {/* Other form elements */}\n      <SubmitButton />\n    </form>\n  )\n}\n\nGood to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available.\n\nOptimistic updates\n\nYou can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response:\napp/page.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useOptimistic } from 'react'\nimport { send } from './actions'\n\ntype Message = {\n  message: string\n}\n\nexport function Thread({ messages }: { messages: Message[] }) {\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic<\n    Message[],\n    string\n  >(messages, (state, newMessage) => [...state, { message: newMessage }])\n\n  const formAction = async (formData: FormData) => {\n    const message = formData.get('message') as string\n    addOptimisticMessage(message)\n    await send(message)\n  }\n\n  return (\n    <div>\n      {optimisticMessages.map((m, i) => (\n        <div key={i}>{m.message}</div>\n      ))}\n      <form action={formAction}>\n        <input type=\"text\" name=\"message\" />\n        <button type=\"submit\">Send</button>\n      </form>\n    </div>\n  )\n}\n\nNested form elements\n\nYou can call Server Actions in elements nested inside <form> such as <button>, <input type=\"submit\">, and <input type=\"image\">. These elements accept the formAction prop or event handlers.\nThis is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information.\nProgrammatic form submission\n\nYou can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the \u2318 + Enter keyboard shortcut, you can listen for the onKeyDown event:\napp/entry.tsxTypeScriptJavaScriptTypeScript'use client'\n\nexport function Entry() {\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (\n      (e.ctrlKey || e.metaKey) &&\n      (e.key === 'Enter' || e.key === 'NumpadEnter')\n    ) {\n      e.preventDefault()\n      e.currentTarget.form?.requestSubmit()\n    }\n  }\n\n  return (\n    <div>\n      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n    </div>\n  )\n}\n\nThis will trigger the submission of the nearest <form> ancestor, which will invoke the Server Function.PreviousEnvironment VariablesNextISRWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/incremental-static-regeneration", "content": "mplement Incremental Static Regeneration (ISR)Examples\nNext.js Commerce\nOn-Demand ISR\nNext.js Forms\n\nIncremental Static Regeneration (ISR) enables you to:\n\nUpdate static content without rebuilding the entire site\nReduce server load by serving prerendered, static pages for most requests\nEnsure proper cache-control headers are automatically added to pages\nHandle large amounts of content pages without long next build times\n\nHere's a minimal example:\napp/blog/[id]/page.tsxTypeScriptJavaScriptTypeScriptinterface Post {\n  id: string\n  title: string\n  content: string\n}\n\n// Next.js will invalidate the cache when a\n// request comes in, at most once every 60 seconds.\nexport const revalidate = 60\n\n// We'll prerender only the params from `generateStaticParams` at build time.\n// If a request comes in for a path that hasn't been generated,\n// Next.js will server-render the page on-demand.\nexport const dynamicParams = true // or false, to 404 on unknown paths\n\nexport async function generateStaticParams() {\n  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>\n    res.json()\n  )\n  return posts.map((post) => ({\n    id: String(post.id),\n  }))\n}\n\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const post: Post = await fetch(`https://api.vercel.app/blog/${id}`).then(\n    (res) => res.json()\n  )\n  return (\n    <main>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </main>\n  )\n}\n\nHere's how this example works:\n\nDuring next build, all known blog posts are generated (there are 25 in this example)\nAll requests made to these pages (e.g. /blog/1) are cached and instantaneous\nAfter 60 seconds has passed, the next request will still show the cached (stale) page\nThe cache is invalidated and a new version of the page begins generating in the background\nOnce generated successfully, Next.js will display and cache the updated page\nIf /blog/26 is requested, Next.js will generate and cache this page on-demand\n\nReference\n\nRoute segment config\n\nrevalidate\ndynamicParams\nFunctions\n\nrevalidatePath\nrevalidateTag\n\nExamples\n\nTime-based revalidation\n\nThis fetches and displays a list of blog posts on /blog. After an hour, the cache for this page is invalidated on the next visit to the page. Then, in the background, a new version of the page is generated with the latest blog posts.app/blog/page.tsxTypeScriptJavaScriptTypeScriptinterface Post {\n  id: string\n  title: string\n  content: string\n}\n\nexport const revalidate = 3600 // invalidate every hour\n\nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts: Post[] = await data.json()\n  return (\n    <main>\n      <h1>Blog Posts</h1>\n      <ul>\n        {posts.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </main>\n  )\n}We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching to dynamic rendering.On-demand revalidation with revalidatePath\n\nFor a more precise method of revalidation, invalidate pages on-demand with the revalidatePath function.For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either using fetch or connecting to a database, this will clear the cache for the entire route and allow the Server Component to fetch fresh data.app/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { revalidatePath } from 'next/cache'\n\nexport async function createPost() {\n  // Invalidate the /posts route in the cache\n  revalidatePath('/posts')\n}View a demo and explore the source code.On-demand revalidation with revalidateTag\n\nFor most use cases, prefer revalidating entire paths. If you need more granular control, you can use the revalidateTag function. For example, you can tag individual fetch calls:app/blog/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog', {\n    next: { tags: ['posts'] },\n  })\n  const posts = await data.json()\n  // ...\n}If you are using an ORM or connecting to a database, you can use unstable_cache:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport { unstable_cache } from 'next/cache'\nimport { db, posts } from '@/lib/db'\n\nconst getCachedPosts = unstable_cache(\n  async () => {\n    return await db.select().from(posts)\n  },\n  ['posts'],\n  { revalidate: 3600, tags: ['posts'] }\n)\n\nexport default async function Page() {\n  const posts = getCachedPosts()\n  // ...\n}You can then use revalidateTag in a Server Actions or Route Handler:app/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { revalidateTag } from 'next/cache'\n\nexport async function createPost() {\n  // Invalidate all data tagged with 'posts' in the cache\n  revalidateTag('posts')\n}\n\nHandling uncaught exceptions\n\nIf an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data. Learn more about error handling.\n\nCustomizing the cache location\n\nYou can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. Learn more.\nTroubleshooting\n\nDebugging cached data in local development\n\nIf you are using the fetch API, you can add additional logging to understand which requests are cached or uncached. Learn more about the logging option.\nnext.config.jsmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\nVerifying correct production behavior\n\nTo verify your pages are cached and revalidated correctly in production, you can test locally by running next build and then next start to run the production Next.js server.\nThis will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your .env file:\n.envNEXT_PRIVATE_DEBUG_CACHE=1\nThis will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated during next build, as well as how pages are updated as paths are accessed on-demand.\nCaveats\n\nISR is only supported when using the Node.js runtime (default).\nISR is not supported when creating a Static Export.\nIf you have multiple fetch requests in a statically rendered route, and each has a different revalidate frequency, the lowest time will be used for ISR. However, those revalidate frequencies will still be respected by the Data Cache.\nIf any of the fetch requests used on a route have a revalidate time of 0, or an explicit no-store, the route will be dynamically rendered.\nMiddleware won't be executed for on-demand ISR requests, meaning any path rewrites or logic in Middleware will not be applied. Ensure you are revalidating the exact path. For example, /post/1 instead of a rewritten /post-1.\n\nPlatform Support\n\nDeployment OptionSupportedNode.js serverYesDocker containerYesStatic exportNoAdaptersPlatform-specific\nLearn how to configure ISR when self-hosting Next.js.\nVersion history\n\nVersionChangesv14.1.0Custom cacheHandler is stable.v13.0.0App Router is introduced.v12.2.0Pages Router: On-Demand ISR is stablev12.0.0Pages Router: Bot-aware ISR fallback added.v9.5.0Pages Router: Stable ISR introduced.PreviousFormsNextInstrumentationWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/instrumentation", "content": "tionHow to set up instrumentation\nInstrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production.\nConvention\n\nTo set up instrumentation, create instrumentation.ts|js file in the root directory of your project (or inside the src folder if using one).\nThen, export a register function in the file. This function will be called once when a new Next.js server instance is initiated.\nFor example, to use Next.js with OpenTelemetry and @vercel/otel:\ninstrumentation.tsTypeScriptJavaScriptTypeScriptimport { registerOTel } from '@vercel/otel'\n\nexport function register() {\n  registerOTel('next-app')\n}\n\nSee the Next.js with OpenTelemetry example for a complete implementation.\n\nGood to know:\n\nThe instrumentation file should be in the root of your project and not inside the app or pages directory. If you're using the src folder, then place the file inside src alongside pages and app.\nIf you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename to match.\n\nExamples\n\nImporting files with side effects\n\nSometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared.\nWe recommend importing files using JavaScript import syntax within your register function. The following example demonstrates a basic usage of import in a register function:\ninstrumentation.tsTypeScriptJavaScriptTypeScriptexport async function register() {\n  await import('package-with-side-effect')\n}\n\nGood to know:\nWe recommend importing the file from within the register function, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file.\n\nImporting runtime-specific code\n\nNext.js calls register in all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g. Edge or Node.js). You can use the NEXT_RUNTIME environment variable to get the current environment:\ninstrumentation.tsTypeScriptJavaScriptTypeScriptexport async function register() {\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\n    await import('./instrumentation-node')\n  }\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    await import('./instrumentation-edge')\n  }\n}\nLearn more about Instrumentationinstrumentation.jsAPI reference for the instrumentation.js file.PreviousISRNextInternationalizationWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/internationalization", "content": "alizationInternationalizationNext.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and internationalized routes.\nTerminology\n\nLocale: An identifier for a set of language and formatting preferences. This usually includes the preferred language of the user and possibly their geographic region.\n\nen-US: English as spoken in the United States\nnl-NL: Dutch as spoken in the Netherlands\nnl: Dutch, no specific region\n\nRouting Overview\n\nIt\u2019s recommended to use the user\u2019s language preferences in the browser to select which locale to use. Changing your preferred language will modify the incoming Accept-Language header to your application.\nFor example, using the following libraries, you can look at an incoming Request to determine which locale to select, based on the Headers, locales you plan to support, and the default locale.\nmiddleware.jsimport { match } from '@formatjs/intl-localematcher'\nimport Negotiator from 'negotiator'\n\nlet headers = { 'accept-language': 'en-US,en;q=0.5' }\nlet languages = new Negotiator({ headers }).languages()\nlet locales = ['en-US', 'nl-NL', 'nl']\nlet defaultLocale = 'en-US'\n\nmatch(languages, locales, defaultLocale) // -> 'en-US'\nRouting can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information, you can now redirect the user based on the locale inside Middleware.\nmiddleware.jsimport { NextResponse } from \"next/server\";\n\nlet locales = ['en-US', 'nl-NL', 'nl']\n\n// Get the preferred locale, similar to the above or using a library\nfunction getLocale(request) { ... }\n\nexport function middleware(request) {\n  // Check if there is any supported locale in the pathname\n  const { pathname } = request.nextUrl\n  const pathnameHasLocale = locales.some(\n    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`\n  )\n\n  if (pathnameHasLocale) return\n\n  // Redirect if there is no locale\n  const locale = getLocale(request)\n  request.nextUrl.pathname = `/${locale}${pathname}`\n  // e.g. incoming request is /products\n  // The new URL is now /en-US/products\n  return NextResponse.redirect(request.nextUrl)\n}\n\nexport const config = {\n  matcher: [\n    // Skip all internal paths (_next)\n    '/((?!_next).*)',\n    // Optional: only run on root (/) URL\n    // '/'\n  ],\n}\nFinally, ensure all special files inside app/ are nested under app/[lang]. This enables the Next.js router to dynamically handle different locales in the route, and forward the lang parameter to every layout and page. For example:\napp/[lang]/page.tsxTypeScriptJavaScriptTypeScript// You now have access to the current locale\n// e.g. /en-US/products -> `lang` is \"en-US\"\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ lang: string }>\n}) {\n  const { lang } = await params\n  return ...\n}\n\nThe root layout can also be nested in the new folder (e.g. app/[lang]/layout.js).\nLocalization\n\nChanging displayed content based on the user\u2019s preferred locale, or localization, is not something specific to Next.js. The patterns described below would work the same with any web application.\nLet\u2019s assume we want to support both English and Dutch content inside our application. We might maintain two different \u201cdictionaries\u201d, which are objects that give us a mapping from some key to a localized string. For example:\ndictionaries/en.json{\n  \"products\": {\n    \"cart\": \"Add to Cart\"\n  }\n}\ndictionaries/nl.json{\n  \"products\": {\n    \"cart\": \"Toevoegen aan Winkelwagen\"\n  }\n}\nWe can then create a getDictionary function to load the translations for the requested locale:\napp/[lang]/dictionaries.tsTypeScriptJavaScriptTypeScriptimport 'server-only'\n\nconst dictionaries = {\n  en: () => import('./dictionaries/en.json').then((module) => module.default),\n  nl: () => import('./dictionaries/nl.json').then((module) => module.default),\n}\n\nexport const getDictionary = async (locale: 'en' | 'nl') =>\n  dictionaries[locale]()\n\nGiven the currently selected language, we can fetch the dictionary inside of a layout or page.\napp/[lang]/page.tsxTypeScriptJavaScriptTypeScriptimport { getDictionary } from './dictionaries'\n\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ lang: 'en' | 'nl' }>\n}) {\n  const { lang } = await params\n  const dict = await getDictionary(lang) // en\n  return <button>{dict.products.cart}</button> // Add to Cart\n}\n\nBecause all layouts and pages in the app/ directory default to Server Components, we do not need to worry about the size of the translation files affecting our client-side JavaScript bundle size. This code will only run on the server, and only the resulting HTML will be sent to the browser.\nStatic Rendering\n\nTo generate static routes for a given set of locales, we can use generateStaticParams with any page or layout. This can be global, for example, in the root layout:\napp/[lang]/layout.tsxTypeScriptJavaScriptTypeScriptexport async function generateStaticParams() {\n  return [{ lang: 'en-US' }, { lang: 'de' }]\n}\n\nexport default async function RootLayout({\n  children,\n  params,\n}: Readonly<{\n  children: React.ReactNode\n  params: Promise<{ lang: 'en-US' | 'de' }>\n}>) {\n  return (\n    <html lang={(await params).lang}>\n      <body>{children}</body>\n    </html>\n  )\n}\n\nResources\n\nMinimal i18n routing and translations\nnext-intl\nnext-international\nnext-i18n-router\nparaglide-next\nlingui\nPreviousInstrumentationNextJSON-LDWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/json-ld", "content": "to implement JSON-LD in your Next.js applicationJSON-LD is a format for structured data that can be used by search engines and AI to to help them understand the structure of the page beyond pure content. For example, you can use it to describe a person, an event, an organization, a movie, a book, a recipe, and many other types of entities.\nOur current recommendation for JSON-LD is to render structured data as a <script> tag in your layout.js or page.js components.\nThe following snippet uses JSON.stringify, which does not sanitize malicious strings used in XSS injection. To prevent this type of vulnerability, you can scrub HTML tags from the JSON-LD payload, for example, by replacing the character, <, with its unicode equivalent, \\u003c.\nReview your organization's recommended approach to sanitize potentially dangerous strings, or use community maintained alternatives for JSON.stringify such as, serialize-javascript.\napp/products/[id]/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page({ params }) {\n  const { id } = await params\n  const product = await getProduct(id)\n\n  const jsonLd = {\n    '@context': 'https://schema.org',\n    '@type': 'Product',\n    name: product.name,\n    image: product.image,\n    description: product.description,\n  }\n\n  return (\n    <section>\n      {/* Add JSON-LD to your page */}\n      <script\n        type=\"application/ld+json\"\n        dangerouslySetInnerHTML={{\n          __html: JSON.stringify(jsonLd).replace(/</g, '\\\\u003c'),\n        }}\n      />\n      {/* ... */}\n    </section>\n  )\n}\n\nYou can validate and test your structured data with the Rich Results Test for Google or the generic Schema Markup Validator.\nYou can type your JSON-LD with TypeScript using community packages like schema-dts:\nimport { Product, WithContext } from 'schema-dts'\n\nconst jsonLd: WithContext<Product> = {\n  '@context': 'https://schema.org',\n  '@type': 'Product',\n  name: 'Next.js Sticker',\n  image: 'https://nextjs.org/imgs/sticker.png',\n  description: 'Dynamic at the speed of static.',\n}PreviousInternationalizationNextLazy LoadingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/lazy-loading", "content": "gHow to lazy load Client Components and libraries\nLazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.\nIt allows you to defer loading of Client Components and imported libraries, and only include them in the client bundle when they're needed. For example, you might want to defer loading a modal until a user clicks to open it.\nThere are two ways you can implement lazy loading in Next.js:\n\nUsing Dynamic Imports with next/dynamic\nUsing React.lazy() with Suspense\n\nBy default, Server Components are automatically code split, and you can use streaming to progressively send pieces of UI from the server to the client. Lazy loading applies to Client Components.\nnext/dynamic\n\nnext/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for incremental migration.\nExamples\n\nImporting Client Components\n\napp/page.js'use client'\n\nimport { useState } from 'react'\nimport dynamic from 'next/dynamic'\n\n// Client Components:\nconst ComponentA = dynamic(() => import('../components/A'))\nconst ComponentB = dynamic(() => import('../components/B'))\nconst ComponentC = dynamic(() => import('../components/C'), { ssr: false })\n\nexport default function ClientComponentExample() {\n  const [showMore, setShowMore] = useState(false)\n\n  return (\n    <div>\n      {/* Load immediately, but in a separate client bundle */}\n      <ComponentA />\n\n      {/* Load on demand, only when/if the condition is met */}\n      {showMore && <ComponentB />}\n      <button onClick={() => setShowMore(!showMore)}>Toggle</button>\n\n      {/* Load only on the client side */}\n      <ComponentC />\n    </div>\n  )\n}\nNote: When a Server Component dynamically imports a Client Component, automatic code splitting is currently not supported.\nSkipping SSR\n\nWhen using React.lazy() and Suspense, Client Components will be prerendered (SSR) by default.\nNote: ssr: false option will only work for Client Components, move it into Client Components ensure the client code-splitting working properly.\nIf you want to disable pre-rendering for a Client Component, you can use the ssr option set to false:const ComponentC = dynamic(() => import('../components/C'), { ssr: false })Importing Server Components\n\nIf you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-loaded - not the Server Component itself.\nIt will also help preload the static assets such as CSS when you're using it in Server Components.app/page.jsimport dynamic from 'next/dynamic'\n\n// Server Component:\nconst ServerComponent = dynamic(() => import('../components/ServerComponent'))\n\nexport default function ServerComponentExample() {\n  return (\n    <div>\n      <ServerComponent />\n    </div>\n  )\n}\nNote: ssr: false option is not supported in Server Components. You will see an error if you try to use it in Server Components.\nssr: false is not allowed with next/dynamic in Server Components. Please move it into a Client Component.\nLoading External Libraries\n\nExternal libraries can be loaded on demand using the import() function. This example uses the external library fuse.js for fuzzy search. The module is only loaded on the client after the user types in the search input.app/page.js'use client'\n\nimport { useState } from 'react'\n\nconst names = ['Tim', 'Joe', 'Bel', 'Lee']\n\nexport default function Page() {\n  const [results, setResults] = useState()\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search\"\n        onChange={async (e) => {\n          const { value } = e.currentTarget\n          // Dynamically load fuse.js\n          const Fuse = (await import('fuse.js')).default\n          const fuse = new Fuse(names)\n\n          setResults(fuse.search(value))\n        }}\n      />\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\n    </div>\n  )\n}Adding a custom loading component\n\napp/page.js'use client'\n\nimport dynamic from 'next/dynamic'\n\nconst WithCustomLoading = dynamic(\n  () => import('../components/WithCustomLoading'),\n  {\n    loading: () => <p>Loading...</p>,\n  }\n)\n\nexport default function Page() {\n  return (\n    <div>\n      {/* The loading component will be rendered while  <WithCustomLoading/> is loading */}\n      <WithCustomLoading />\n    </div>\n  )\n}Importing Named Exports\n\nTo dynamically import a named export, you can return it from the Promise returned by import() function:components/hello.js'use client'\n\nexport function Hello() {\n  return <p>Hello!</p>\n}app/page.jsimport dynamic from 'next/dynamic'\n\nconst ClientComponent = dynamic(() =>\n  import('../components/hello').then((mod) => mod.Hello)\n)\nPreviousJSON-LDNextDevelopment EnvironmentWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/local-development", "content": "EnvironmentHow to optimize your local development environmentNext.js is designed to provide a great developer experience. As your application grows, you might notice slower compilation times during local development. This guide will help you identify and fix common compile-time performance issues.\nLocal dev vs. production\n\nThe development process with next dev is different than next build and next start.\nnext dev compiles routes in your application as you open or navigate to them. This enables you to start the dev server without waiting for every route in your application to compile, which is both faster and uses less memory. Running a production build applies other optimizations, like minifying files and creating content hashes, which are not needed for local development.\nImproving local dev performance\n\n1. Check your computer's antivirus\n\nAntivirus software can slow down file access.\nTry adding your project folder to the antivirus exclusion list. While this is more common on Windows machines, we recommend this for any system with an antivirus tool installed.\n2. Update Next.js and enable Turbopack\n\nMake sure you're using the latest version of Next.js. Each new version often includes performance improvements.\nTurbopack is a new bundler integrated into Next.js that can improve local performance.\nnpm install next@latest\nnpm run dev --turbopack\nLearn more about Turbopack. See our upgrade guides and codemods for more information.\n3. Check your imports\n\nThe way you import code can greatly affect compilation and bundling time. Learn more about optimizing package bundling and explore tools like Dependency Cruiser or Madge.\nIcon libraries\n\nLibraries like @material-ui/icons or react-icons can import thousands of icons, even if you only use a few. Try to import only the icons you need:\n// Instead of this:\nimport { Icon1, Icon2 } from 'react-icons/md'\n\n// Do this:\nimport Icon1 from 'react-icons/md/Icon1'\nimport Icon2 from 'react-icons/md/Icon2'\nLibraries like react-icons includes many different icon sets. Choose one set and stick with that set.\nFor example, if your application uses react-icons and imports all of these:\n\npi (Phosphor Icons)\nmd (Material Design Icons)\ntb (tabler-icons)\ncg (cssgg)\n\nCombined they will be tens of thousands of modules that the compiler has to handle, even if you only use a single import from each.\nBarrel files\n\n\"Barrel files\" are files that export many items from other files. They can slow down builds because the compiler has to parse them to find if there are side-effects in the module scope by using the import.\nTry to import directly from specific files when possible. Learn more about barrel files and the built-in optimizations in Next.js.\nOptimize package imports\n\nNext.js can automatically optimize imports for certain packages. If you are using packages that utilize barrel files, add them to your next.config.js:\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['package-name'],\n  },\n}\nTurbopack automatically analyzes imports and optimizes them. It does not require this configuration.\n4. Check your Tailwind CSS setup\n\nIf you're using Tailwind CSS, make sure it's set up correctly.\nA common mistake is configuring your content array in a way which includes node_modules or other large directories of files that should not be scanned.\nTailwind CSS version 3.4.8 or newer will warn you about settings that might slow down your build.\n\nIn your tailwind.config.js, be specific about which files to scan:\nmodule.exports = {\n  content: [\n    './src/**/*.{js,ts,jsx,tsx}', // Good\n    // This might be too broad\n    // It will match `packages/**/node_modules` too\n    // '../../packages/**/*.{js,ts,jsx,tsx}',\n  ],\n}\n\nAvoid scanning unnecessary files:\nmodule.exports = {\n  content: [\n    // Better - only scans the 'src' folder\n    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',\n  ],\n}\n\n5. Check custom webpack settings\n\nIf you've added custom webpack settings, they might be slowing down compilation.\nConsider if you really need them for local development. You can optionally only include certain tools for production builds, or explore moving to Turbopack and using loaders.\n6. Optimize memory usage\n\nIf your app is very large, it might need more memory.\nLearn more about optimizing memory usage.\n7. Server Components and data fetching\n\nChanges to Server Components cause the entire page to re-render locally in order to show the new changes, which includes fetching new data for the component.\nThe experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls.\nLearn more about the experimental option.\n8. Consider local development over Docker\n\nIf you're using Docker for development on Mac or Windows, you may experience significantly slower performance compared to running Next.js locally.\nDocker's filesystem access on Mac and Windows can cause Hot Module Replacement (HMR) to take seconds or even minutes, while the same application runs with fast HMR when developed locally.\nThis performance difference is due to how Docker handles filesystem operations outside of Linux environments. For the best development experience:\n\nUse local development (npm run dev or pnpm dev) instead of Docker during development\nReserve Docker for production deployments and testing production builds\nIf you must use Docker for development, consider using Docker on a Linux machine or VM\n\nLearn more about Docker deployment for production use.\nTools for finding problems\n\nDetailed fetch logging\n\nUse the logging.fetches option in your next.config.js file, to see more detailed information about what's happening during development:\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\nLearn more about fetch logging.\nTurbopack tracing\n\nTurbopack tracing is a tool that helps you understand the performance of your application during local development.\nIt provides detailed information about the time taken for each module to compile and how they are related.\n\nMake sure you have the latest version of Next.js installed.\n\nGenerate a Turbopack trace file:\nNEXT_TURBOPACK_TRACING=1 npm run dev\n\nNavigate around your application or make edits to files to reproduce the problem.\n\nStop the Next.js development server.\n\nA file called trace-turbopack will be available in the .next folder.\n\nYou can interpret the file using next internal trace [path-to-file]:\nnext internal trace .next/trace-turbopack\nOn versions where trace is not available, the command was named turbo-trace-server:\nnext internal turbo-trace-server .next/trace-turbopack\n\nOnce the trace server is running you can view the trace at https://trace.nextjs.org/.\n\nBy default the trace viewer will aggregate timings, in order to see each individual time you can switch from \"Aggregated in order\" to \"Spans in order\" at the top right of the viewer.\n\nStill having problems?\n\nShare the trace file generated in the Turbopack Tracing section and share it on GitHub Discussions or Discord.PreviousLazy LoadingNextMDXWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/mdx", "content": "se markdown and MDX in Next.js\nMarkdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs.\nYou write...\nI **love** using [Next.js](https://nextjs.org/)\nOutput:\n<p>I <strong>love</strong> using <a href=\"https://nextjs.org/\">Next.js</a></p>\nMDX is a superset of markdown that lets you write JSX directly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content.\nNext.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router).\n\nGood to know: View the Portfolio Starter Kit template for a complete working example.\n\nInstall dependencies\n\nThe @next/mdx package, and related packages, are used to configure Next.js so it can process markdown and MDX. It sources data from local files, allowing you to create pages with a .md or .mdx extension, directly in your /pages or /app directory.\nInstall these packages to render MDX with Next.js:\nTerminalnpm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx\nConfigure next.config.mjs\n\nUpdate the next.config.mjs file at your project's root to configure it to use MDX:\nnext.config.mjsimport createMDX from '@next/mdx'\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Configure `pageExtensions` to include markdown and MDX files\n  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],\n  // Optionally, add any other Next.js config below\n}\n\nconst withMDX = createMDX({\n  // Add markdown plugins here, as desired\n})\n\n// Merge MDX config with Next.js config\nexport default withMDX(nextConfig)\nThis allows .mdx files to act as pages, routes, or imports in your application.\nHandling .md files\n\nBy default, next/mdx only compiles files with the .mdx extension. To handle .md files with webpack, update the extension option:\nnext.config.mjsconst withMDX = createMDX({\n  extension: /\\.(md|mdx)$/,\n})\n\nGood to know: Turbopack does not currently support the extension option and therefore does not support .md files.\n\nAdd an mdx-components.tsx file\n\nCreate an mdx-components.tsx (or .js) file in the root of your project to define global MDX Components. For example, at the same level as pages or app, or inside src if applicable.\nmdx-components.tsxTypeScriptJavaScriptTypeScriptimport type { MDXComponents } from 'mdx/types'\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    ...components,\n  }\n}\n\nGood to know:\n\nmdx-components.tsx is required to use @next/mdx with App Router and will not work without it.\nLearn more about the mdx-components.tsx file convention.\nLearn how to use custom styles and components.\n\nRendering MDX\n\nYou can render MDX using Next.js's file based routing or by importing MDX files into other pages.\nUsing file based routing\n\nWhen using file based routing, you can use MDX pages like any other page.\nIn App Router apps, that includes being able to use metadata.Create a new MDX page within the /app directory:  my-project\n  \u251c\u2500\u2500 app\n  \u2502   \u2514\u2500\u2500 mdx-page\n  \u2502       \u2514\u2500\u2500 page.(mdx/md)\n  |\u2500\u2500 mdx-components.(tsx/js)\n  \u2514\u2500\u2500 package.json\n\nYou can use MDX in these files, and even import React components, directly inside your MDX page:\nimport { MyComponent } from 'my-component'\n\n# Welcome to my MDX page!\n\nThis is some **bold** and _italics_ text.\n\nThis is a list in markdown:\n\n- One\n- Two\n- Three\n\nCheckout my React component:\n\n<MyComponent />\nNavigating to the /mdx-page route should display your rendered MDX page.\nUsing imports\n\nCreate a new page within the /app directory and an MDX file wherever you'd like:  .\n  \u251c\u2500\u2500 app/\n  \u2502   \u2514\u2500\u2500 mdx-page/\n  \u2502       \u2514\u2500\u2500 page.(tsx/js)\n  \u251c\u2500\u2500 markdown/\n  \u2502   \u2514\u2500\u2500 welcome.(mdx/md)\n  \u251c\u2500\u2500 mdx-components.(tsx/js)\n  \u2514\u2500\u2500 package.json\n\nYou can use MDX in these files, and even import React components, directly inside your MDX page:\n\nImport the MDX file inside the page to display the content:\napp/mdx-page/page.tsxTypeScriptJavaScriptTypeScriptimport Welcome from '@/markdown/welcome.mdx'\n\nexport default function Page() {\n  return <Welcome />\n}\n\nNavigating to the /mdx-page route should display your rendered MDX page.\nUsing dynamic imports\n\nYou can import dynamic MDX components instead of using filesystem routing for MDX files.For example, you can have a dynamic route segment which loads MDX components from a separate directory:generateStaticParams can be used to prerender the provided routes. By marking dynamicParams as false, accessing a route not defined in generateStaticParams will 404.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const { default: Post } = await import(`@/content/${slug}.mdx`)\n\n  return <Post />\n}\n\nexport function generateStaticParams() {\n  return [{ slug: 'welcome' }, { slug: 'about' }]\n}\n\nexport const dynamicParams = false\nGood to know: Ensure you specify the .mdx file extension in your import. While it is not required to use module path aliases (e.g., @/content), it does simplify your import path.\n\nUsing custom styles and components\n\nMarkdown, when rendered, maps to native HTML elements. For example, writing the following markdown:\n## This is a heading\n\nThis is a list in markdown:\n\n- One\n- Two\n- Three\nGenerates the following HTML:\n<h2>This is a heading</h2>\n\n<p>This is a list in markdown:</p>\n\n<ul>\n  <li>One</li>\n  <li>Two</li>\n  <li>Three</li>\n</ul>\nTo style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts.\nGlobal styles and components\n\nAdding styles and components in mdx-components.tsx will affect all MDX files in your application.\nmdx-components.tsxTypeScriptJavaScriptTypeScriptimport type { MDXComponents } from 'mdx/types'\nimport Image, { ImageProps } from 'next/image'\n\n// This file allows you to provide custom React components\n// to be used in MDX files. You can import and use any\n// React component you want, including inline styles,\n// components from other libraries, and more.\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    // Allows customizing built-in components, e.g. to add styling.\n    h1: ({ children }) => (\n      <h1 style={{ color: 'red', fontSize: '48px' }}>{children}</h1>\n    ),\n    img: (props) => (\n      <Image\n        sizes=\"100vw\"\n        style={{ width: '100%', height: 'auto' }}\n        {...(props as ImageProps)}\n      />\n    ),\n    ...components,\n  }\n}\n\nLocal styles and components\n\nYou can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and override global styles and components.\napp/mdx-page/page.tsxTypeScriptJavaScriptTypeScriptimport Welcome from '@/markdown/welcome.mdx'\n\nfunction CustomH1({ children }) {\n  return <h1 style={{ color: 'blue', fontSize: '100px' }}>{children}</h1>\n}\n\nconst overrideComponents = {\n  h1: CustomH1,\n}\n\nexport default function Page() {\n  return <Welcome components={overrideComponents} />\n}\n\nShared layouts\n\nTo share a layout across MDX pages, you can use the built-in layouts support with the App Router.app/mdx-page/layout.tsxTypeScriptJavaScriptTypeScriptexport default function MdxLayout({ children }: { children: React.ReactNode }) {\n  // Create any shared layout or styles here\n  return <div style={{ color: 'blue' }}>{children}</div>\n}\n\nUsing Tailwind typography plugin\n\nIf you are using Tailwind to style your application, using the @tailwindcss/typography plugin will allow you to reuse your Tailwind configuration and styles in your markdown files.\nThe plugin adds a set of prose classes that can be used to add typographic styles to content blocks that come from sources, like markdown.\nInstall Tailwind typography and use with shared layouts to add the prose you want.\napp/mdx-page/layout.tsxTypeScriptJavaScriptTypeScriptexport default function MdxLayout({ children }: { children: React.ReactNode }) {\n  // Create any shared layout or styles here\n  return (\n    <div className=\"prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white\">\n      {children}\n    </div>\n  )\n}\n\nFrontmatter\n\nFrontmatter is a YAML like key/value pairing that can be used to store data about a page. @next/mdx does not support frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as:\n\nremark-frontmatter\nremark-mdx-frontmatter\ngray-matter\n\n@next/mdx does allow you to use exports like any other JavaScript component:\n\nMetadata can now be referenced outside of the MDX file:\napp/blog/page.tsxTypeScriptJavaScriptTypeScriptimport BlogPost, { metadata } from '@/content/blog-post.mdx'\n\nexport default function Page() {\n  console.log('metadata: ', metadata)\n  //=> { author: 'John Doe' }\n  return <BlogPost />\n}\n\nA common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages like Node's fs module or globby to read a directory of posts and extract the metadata.\n\nGood to know:\n\nUsing fs, globby, etc. can only be used server-side.\nView the Portfolio Starter Kit template for a complete working example.\n\nremark and rehype Plugins\n\nYou can optionally provide remark and rehype plugins to transform the MDX content.\nFor example, you can use remark-gfm to support GitHub Flavored Markdown.\nSince the remark and rehype ecosystem is ESM only, you'll need to use next.config.mjs or next.config.ts as the configuration file.\nnext.config.mjsimport remarkGfm from 'remark-gfm'\nimport createMDX from '@next/mdx'\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Allow .mdx extensions for files\n  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],\n  // Optionally, add any other Next.js config below\n}\n\nconst withMDX = createMDX({\n  // Add markdown plugins here, as desired\n  options: {\n    remarkPlugins: [remarkGfm],\n    rehypePlugins: [],\n  },\n})\n\n// Combine MDX and Next.js config\nexport default withMDX(nextConfig)\nUsing Plugins with Turbopack\n\nTo use plugins with Turbopack, upgrade to the latest @next/mdx and specify plugin names using a string:\nnext.config.mjsimport createMDX from '@next/mdx'\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],\n}\n\nconst withMDX = createMDX({\n  options: {\n    remarkPlugins: [],\n    rehypePlugins: [['rehype-katex', { strict: true, throwOnError: true }]],\n  },\n})\n\nexport default withMDX(nextConfig)\n\nGood to know:\nremark and rehype plugins without serializable options cannot be used yet with Turbopack, due to inability to pass JavaScript functions to Rust\n\nRemote MDX\n\nIf your MDX files or content lives somewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A community package for this use is next-mdx-remote-client.\n\nGood to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE).\n\nThe following example uses next-mdx-remote-client:\napp/mdx-page-remote/page.tsxTypeScriptJavaScriptTypeScriptimport { MDXRemote } from 'next-mdx-remote-client/rsc'\n\nexport default async function RemoteMdxPage() {\n  // MDX text - can be from a database, CMS, fetch, anywhere...\n  const res = await fetch('https://...')\n  const markdown = await res.text()\n  return <MDXRemote source={markdown} />\n}\n\nNavigating to the /mdx-page-remote route should display your rendered MDX.\nDeep Dive: How do you transform markdown into HTML?\n\nReact does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished with remark and rehype.\nremark is an ecosystem of tools around markdown. rehype is the same, but for HTML. For example, the following code snippet transforms markdown into HTML:\nimport { unified } from 'unified'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport rehypeSanitize from 'rehype-sanitize'\nimport rehypeStringify from 'rehype-stringify'\n\nmain()\n\nasync function main() {\n  const file = await unified()\n    .use(remarkParse) // Convert into markdown AST\n    .use(remarkRehype) // Transform to HTML AST\n    .use(rehypeSanitize) // Sanitize HTML input\n    .use(rehypeStringify) // Convert AST into serialized HTML\n    .process('Hello, Next.js!')\n\n  console.log(String(file)) // <p>Hello, Next.js!</p>\n}\nThe remark and rehype ecosystem contains plugins for syntax highlighting, linking headings, generating a table of contents, and more.\nWhen using @next/mdx as shown above, you do not need to use remark or rehype directly, as it is handled for you. We're describing it here for a deeper understanding of what the @next/mdx package is doing underneath.\nUsing the Rust-based MDX compiler (experimental)\n\nNext.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configure next.config.js when you pass it to withMDX:\nnext.config.jsmodule.exports = withMDX({\n  experimental: {\n    mdxRs: true,\n  },\n})\nmdxRs also accepts an object to configure how to transform mdx files.\nnext.config.jsmodule.exports = withMDX({\n  experimental: {\n    mdxRs: {\n      jsxRuntime?: string            // Custom jsx runtime\n      jsxImportSource?: string       // Custom jsx import source,\n      mdxType?: 'gfm' | 'commonmark' // Configure what kind of mdx syntax will be used to parse & transform\n    },\n  },\n})\nHelpful Links\n\nMDX\n@next/mdx\nremark\nrehype\nMarkdoc\nPreviousDevelopment EnvironmentNextMemory UsageWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/memory-usage", "content": "eHow to optimize memory usageAs applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds.\nLet's explore some strategies and techniques to optimize memory and address common memory issues in Next.js.\nReduce number of dependencies\n\nApplications with a large amount of dependencies will use more memory.\nThe Bundle Analyzer can help you investigate large dependencies in your application that may be able to be removed to improve performance and memory usage.\nTry experimental.webpackMemoryOptimizations\n\nStarting in v15.0.0, you can add experimental.webpackMemoryOptimizations: true to your next.config.js file to change behavior in Webpack that reduces max memory usage but may increase compilation times by a slight amount.\n\nGood to know: This feature is currently experimental to test on more projects first, but it is considered to be low-risk.\n\nRun next build with --experimental-debug-memory-usage\n\nStarting in 14.2.0, you can run next build --experimental-debug-memory-usage to run the build in a mode where Next.js will print out information about memory usage continuously throughout the build, such as heap usage and garbage collection statistics. Heap snapshots will also be taken automatically when memory usage gets close to the configured limit.\n\nGood to know: This feature is not compatible with the Webpack build worker option which is auto-enabled unless you have custom webpack config.\n\nRecord a heap profile\n\nTo look for memory issues, you can record a heap profile from Node.js and load it in Chrome DevTools to identify potential sources of memory leaks.\nIn your terminal, pass the --heap-prof flag to Node.js when starting your Next.js build:\nnode --heap-prof node_modules/next/dist/bin/next build\nAt the end of the build, a .heapprofile file will be created by Node.js.\nIn Chrome DevTools, you can open the Memory tab and click on the \"Load Profile\" button to visualize the file.\nAnalyze a snapshot of the heap\n\nYou can use an inspector tool to analyze the memory usage of the application.\nWhen running the next build or next dev command, add NODE_OPTIONS=--inspect to the beginning of the command. This will expose the inspector agent on the default port.\nIf you wish to break before any user code starts, you can pass --inspect-brk instead. While the process is running, you can use a tool such as Chrome DevTools to connect to the debugging port to record and analyze a snapshot of the heap to see what memory is being retained.\nStarting in 14.2.0, you can also run next build with the --experimental-debug-memory-usage flag to make it easier to take heap snapshots.\nWhile running in this mode, you can send a SIGUSR2 signal to the process at any point, and the process will take a heap snapshot.\nThe heap snapshot will be saved to the project root of the Next.js application and can be loaded in any heap analyzer, such as Chrome DevTools, to see what memory is retained. This mode is not yet compatible with Webpack build workers.\nSee how to record and analyze heap snapshots for more information.\nWebpack build worker\n\nThe Webpack build worker allows you to run Webpack compilations inside a separate Node.js worker which will decrease memory usage of your application during builds.\nThis option is enabled by default if your application does not have a custom Webpack configuration starting in v14.1.0.\nIf you are using an older version of Next.js or you have a custom Webpack configuration, you can enable this option by setting experimental.webpackBuildWorker: true inside your next.config.js.\n\nGood to know: This feature may not be compatible with all custom Webpack plugins.\n\nDisable Webpack cache\n\nThe Webpack cache saves generated Webpack modules in memory and/or to disk to improve the speed of builds. This can\nhelp with performance, but it will also increase the memory usage of your application to store the cached data.\nYou can disable this behavior by adding a custom Webpack configuration to your application:\nnext.config.mjs/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  webpack: (\n    config,\n    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }\n  ) => {\n    if (config.cache && !dev) {\n      config.cache = Object.freeze({\n        type: 'memory',\n      })\n    }\n    // Important: return the modified config\n    return config\n  },\n}\n\nexport default nextConfig\nDisable static analysis\n\nTypechecking and linting may require a lot of memory, especially in large projects.\nHowever, most projects have a dedicated CI runner that already handles these tasks.\nWhen the build produces out-of-memory issues during the \"Linting and checking validity of types\" step, you can disable these task during builds:\nnext.config.mjs/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  eslint: {\n    // Warning: This allows production builds to successfully complete even if\n    // your project has ESLint errors.\n    ignoreDuringBuilds: true,\n  },\n  typescript: {\n    // !! WARN !!\n    // Dangerously allow production builds to successfully complete even if\n    // your project has type errors.\n    // !! WARN !!\n    ignoreBuildErrors: true,\n  },\n}\n\nexport default nextConfig\n\nIgnoring TypeScript Errors\nESLint in Next.js config\n\nKeep in mind that this may produce faulty deploys due to type errors or linting issues.\nWe strongly recommend only promoting builds to production after static analysis has completed.\nIf you deploy to Vercel, you can check out the guide for staging deployments to learn how to promote builds to production after custom tasks have succeeded.\nDisable source maps\n\nGenerating source maps consumes extra memory during the build process.\nYou can disable source map generation by adding productionBrowserSourceMaps: false and experimental.serverSourceMaps: false to your Next.js configuration.\n\nGood to know: Some plugins may turn on source maps and may require custom configuration to disable.\n\nEdge memory issues\n\nNext.js v14.1.3 fixed a memory issue when using the Edge runtime. Please update to this version (or later) to see if it addresses your issue.\nPreloading Entries\n\nWhen the Next.js server starts, it preloads each page's JavaScript modules into memory, rather than at request time.\nThis optimization allows for faster response times, in exchange for a larger initial memory footprint.\nTo disable this optimization, set the experimental.preloadEntriesOnStart flag to false.\nnext.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next'\n\nconst config: NextConfig = {\n  experimental: {\n    preloadEntriesOnStart: false,\n  },\n}\n\nexport default config\n\nNext.js doesn't unload these JavaScript modules, meaning that even with this optimization disabled, the memory footprint of your Next.js server will eventually be the same if all pages are eventually requested.PreviousMDXNextMigratingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/migrating/app-router-migration", "content": "in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspackOn this pageUpgradingNode.js VersionNext.js VersionESLint VersionNext StepsUpgrading New Features<Image/> Component<Link> Component<Script> ComponentFont OptimizationMigrating from pages to appStep 1: Creating the app directoryStep 2: Creating a Root LayoutMigrating _document.js and _app.jsMigrating the getLayout() pattern to Layouts (Optional)Step 3: Migrating next/headStep 4: Migrating PagesStep 5: Migrating Routing HooksSharing components between pages and appStep 6: Migrating Data Fetching MethodsServer-side Rendering (getServerSideProps)Accessing Request ObjectStatic Site Generation (getStaticProps)Dynamic paths (getStaticPaths)Replacing fallbackIncremental Static Regeneration (getStaticProps with revalidate)API RoutesSingle-Page ApplicationsStep 7: StylingTailwind CSSUsing App Router together with Pages RouterCodemodsEdit this page on GitHub Scroll to top GuidesMigratingApp RouterHow to migrate from Pages to the App RouterThis guide will help you:\n\nUpdate your Next.js application from version 12 to version 13\nUpgrade features that work in both the pages and the app directories\nIncrementally migrate your existing application from pages to app\n\nUpgrading\n\nNode.js Version\n\nThe minimum Node.js version is now v18.17. See the Node.js documentation for more information.\nNext.js Version\n\nTo update to Next.js version 13, run the following command using your preferred package manager:\nTerminalnpm install next@latest react@latest react-dom@latest\nESLint Version\n\nIf you're using ESLint, you need to upgrade your ESLint version:\nTerminalnpm install -D eslint-config-next@latest\n\nGood to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command Palette (cmd+shift+p on Mac; ctrl+shift+p on Windows) and search for ESLint: Restart ESLint Server.\n\nNext Steps\n\nAfter you've updated, see the following sections for next steps:\n\nUpgrade new features: A guide to help you upgrade to new features such as the improved Image and Link Components.\nMigrate from the pages to app directory: A step-by-step guide to help you incrementally migrate from the pages to the app directory.\n\nUpgrading New Features\n\nNext.js 13 introduced the new App Router with new features and conventions. The new Router is available in the app directory and co-exists with the pages directory.\nUpgrading to Next.js 13 does not require using the App Router. You can continue using pages with new features that work in both directories, such as the updated Image component, Link component, Script component, and Font optimization.\n<Image/> Component\n\nNext.js 12 introduced new improvements to the Image Component with a temporary import: next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.\nIn version 13, this new behavior is now the default for next/image.\nThere are two codemods to help you migrate to the new Image Component:\n\nnext-image-to-legacy-image codemod: Safely and automatically renames next/image imports to next/legacy/image. Existing components will maintain the same behavior.\nnext-image-experimental codemod: Dangerously adds inline styles and removes unused props. This will change the behavior of existing components to match the new defaults. To use this codemod, you need to run the next-image-to-legacy-image codemod first.\n\n<Link> Component\n\nThe <Link> Component no longer requires manually adding an <a> tag as a child. This behavior was added as an experimental option in version 12.2 and is now the default. In Next.js 13, <Link> always renders <a> and allows you to forward props to the underlying tag.\nFor example:\nimport Link from 'next/link'\n\n// Next.js 12: `<a>` has to be nested otherwise it's excluded\n<Link href=\"/about\">\n  <a>About</a>\n</Link>\n\n// Next.js 13: `<Link>` always renders `<a>` under the hood\n<Link href=\"/about\">\n  About\n</Link>\nTo upgrade your links to Next.js 13, you can use the new-link codemod.\n<Script> Component\n\nThe behavior of next/script has been updated to support both pages and app, but some changes need to be made to ensure a smooth migration:\n\nMove any beforeInteractive scripts you previously included in _document.js to the root layout file (app/layout.tsx).\nThe experimental worker strategy does not yet work in app and scripts denoted with this strategy will either have to be removed or modified to use a different strategy (e.g. lazyOnload).\nonLoad, onReady, and onError handlers will not work in Server Components so make sure to move them to a Client Component or remove them altogether.\n\nFont Optimization\n\nPreviously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you the ability to customize your font loading experience while still ensuring great performance and privacy. next/font is supported in both the pages and app directories.\nWhile inlining CSS still works in pages, it does not work in app. You should use next/font instead.\nSee the Font Optimization page to learn how to use next/font.\nMigrating from pages to app\n\n\ud83c\udfa5 Watch: Learn how to incrementally adopt the App Router \u2192 YouTube (16 minutes).\n\nMoving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components, Suspense, and more. When combined with new Next.js features such as special files and layouts, migration means new concepts, mental models, and behavioral changes to learn.\nWe recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. The app directory is intentionally designed to work simultaneously with the pages directory to allow for incremental page-by-page migration.\n\nThe app directory supports nested routes and layouts. Learn more.\nUse nested folders to define routes and a special page.js file to make a route segment publicly accessible. Learn more.\nSpecial file conventions are used to create UI for each route segment. The most common special files are page.js and layout.js.\n\nUse page.js to define UI unique to a route.\nUse layout.js to define UI that is shared across multiple routes.\n.js, .jsx, or .tsx file extensions can be used for special files.\n\nYou can colocate other files inside the app directory such as components, styles, tests, and more. Learn more.\nData fetching functions like getServerSideProps and getStaticProps have been replaced with a new API inside app. getStaticPaths has been replaced with generateStaticParams.\npages/_app.js and pages/_document.js have been replaced with a single app/layout.js root layout. Learn more.\npages/_error.js has been replaced with more granular error.js special files. Learn more.\npages/404.js has been replaced with the not-found.js file.\npages/api/* API Routes have been replaced with the route.js (Route Handler) special file.\n\nStep 1: Creating the app directory\n\nUpdate to the latest Next.js version (requires 13.4 or greater):\nnpm install next@latest\nThen, create a new app directory at the root of your project (or src/ directory).\nStep 2: Creating a Root Layout\n\nCreate a new app/layout.tsx file inside the app directory. This is a root layout that will apply to all routes inside app.\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  // Layouts must accept a children prop.\n  // This will be populated with nested layouts or pages\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n\nThe app directory must include a root layout.\nThe root layout must define <html>, and <body> tags since Next.js does not automatically create them\nThe root layout replaces the pages/_app.tsx and pages/_document.tsx files.\n.js, .jsx, or .tsx extensions can be used for layout files.\n\nTo manage <head> HTML elements, you can use the built-in SEO support:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'Home',\n  description: 'Welcome to Next.js',\n}\n\nMigrating _document.js and _app.js\n\nIf you have an existing _app or _document file, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles in app/layout.tsx will not apply to pages/*. You should keep _app/_document while migrating to prevent your pages/* routes from breaking. Once fully migrated, you can then safely delete them.\nIf you are using any React Context providers, they will need to be moved to a Client Component.\nMigrating the getLayout() pattern to Layouts (Optional)\n\nNext.js recommended adding a property to Page components to achieve per-page layouts in the pages directory. This pattern can be replaced with native support for nested layouts in the app directory.\nSee before and after exampleBeforecomponents/DashboardLayout.jsexport default function DashboardLayout({ children }) {\n  return (\n    <div>\n      <h2>My Dashboard</h2>\n      {children}\n    </div>\n  )\n}pages/dashboard/index.jsimport DashboardLayout from '../components/DashboardLayout'\n\nexport default function Page() {\n  return <p>My Page</p>\n}\n\nPage.getLayout = function getLayout(page) {\n  return <DashboardLayout>{page}</DashboardLayout>\n}After\n\nRemove the Page.getLayout property from pages/dashboard/index.js and follow the steps for migrating pages to the app directory.\napp/dashboard/page.jsexport default function Page() {\n  return <p>My Page</p>\n}\n\nMove the contents of DashboardLayout into a new Client Component to retain pages directory behavior.\napp/dashboard/DashboardLayout.js'use client' // this directive should be at top of the file, before any imports.\n\n// This is a Client Component\nexport default function DashboardLayout({ children }) {\n  return (\n    <div>\n      <h2>My Dashboard</h2>\n      {children}\n    </div>\n  )\n}\n\nImport the DashboardLayout into a new layout.js file inside the app directory.\napp/dashboard/layout.jsimport DashboardLayout from './DashboardLayout'\n\n// This is a Server Component\nexport default function Layout({ children }) {\n  return <DashboardLayout>{children}</DashboardLayout>\n}\n\nYou can incrementally move non-interactive parts of DashboardLayout.js (Client Component) into layout.js (Server Component) to reduce the amount of component JavaScript you send to the client.\n\nStep 3: Migrating next/head\n\nIn the pages directory, the next/head React component is used to manage <head> HTML elements such as title and meta . In the app directory, next/head is replaced with the new built-in SEO support.\nBefore:\npages/index.tsxTypeScriptJavaScriptTypeScriptimport Head from 'next/head'\n\nexport default function Page() {\n  return (\n    <>\n      <Head>\n        <title>My page title</title>\n      </Head>\n    </>\n  )\n}\n\nAfter:\napp/page.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My Page Title',\n}\n\nexport default function Page() {\n  return '...'\n}\n\nSee all metadata options.\nStep 4: Migrating Pages\n\nPages in the app directory are Server Components by default. This is different from the pages directory where pages are Client Components.\nData fetching has changed in app. getServerSideProps, getStaticProps and getInitialProps have been replaced with a simpler API.\nThe app directory uses nested folders to define routes and a special page.js file to make a route segment publicly accessible.\n\npages Directoryapp DirectoryRouteindex.jspage.js/about.jsabout/page.js/aboutblog/[slug].jsblog/[slug]/page.js/blog/post-1\n\nWe recommend breaking down the migration of a page into two main steps:\n\nStep 1: Move the default exported Page Component into a new Client Component.\nStep 2: Import the new Client Component into a new page.js file inside the app directory.\n\nGood to know: This is the easiest migration path because it has the most comparable behavior to the pages directory.\n\nStep 1: Create a new Client Component\n\nCreate a new separate file inside the app directory (i.e. app/home-page.tsx or similar) that exports a Client Component. To define Client Components, add the 'use client' directive to the top of the file (before any imports).\n\nSimilar to the Pages Router, there is an optimization step to prerender Client Components to static HTML on the initial page load.\n\nMove the default exported page component from pages/index.js to app/home-page.tsx.\n\napp/home-page.tsxTypeScriptJavaScriptTypeScript'use client'\n\n// This is a Client Component (same as components in the `pages` directory)\n// It receives data as props, has access to state and effects, and is\n// prerendered on the server during the initial page load.\nexport default function HomePage({ recentPosts }) {\n  return (\n    <div>\n      {recentPosts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  )\n}\n\nStep 2: Create a new page\n\nCreate a new app/page.tsx file inside the app directory. This is a Server Component by default.\n\nImport the home-page.tsx Client Component into the page.\n\nIf you were fetching data in pages/index.js, move the data fetching logic directly into the Server Component using the new data fetching APIs. See the data fetching upgrade guide for more details.\napp/page.tsxTypeScriptJavaScriptTypeScript// Import your Client Component\nimport HomePage from './home-page'\n\nasync function getPosts() {\n  const res = await fetch('https://...')\n  const posts = await res.json()\n  return posts\n}\n\nexport default async function Page() {\n  // Fetch data directly in a Server Component\n  const recentPosts = await getPosts()\n  // Forward fetched data to your Client Component\n  return <HomePage recentPosts={recentPosts} />\n}\n\nIf your previous page used useRouter, you'll need to update to the new routing hooks. Learn more.\n\nStart your development server and visit http://localhost:3000. You should see your existing index route, now served through the app directory.\n\nStep 5: Migrating Routing Hooks\n\nA new router has been added to support the new behavior in the app directory.\nIn app, you should use the three new hooks imported from next/navigation: useRouter(), usePathname(), and useSearchParams().\n\nThe new useRouter hook is imported from next/navigation and has different behavior to the useRouter hook in pages which is imported from next/router.\n\nThe useRouter hook imported from next/router is not supported in the app directory but can continue to be used in the pages directory.\n\nThe new useRouter does not return the pathname string. Use the separate usePathname hook instead.\nThe new useRouter does not return the query object. Search parameters and dynamic route parameters are now separate. Use the useSearchParams and useParams hooks instead.\nYou can use useSearchParams and usePathname together to listen to page changes. See the Router Events section for more details.\nThese new hooks are only supported in Client Components. They cannot be used in Server Components.\n\napp/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\n\nexport default function ExampleClientComponent() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n\n  // ...\n}\n\nIn addition, the new useRouter hook has the following changes:\n\nisFallback has been removed because fallback has been replaced.\nThe locale, locales, defaultLocales, domainLocales values have been removed because built-in i18n Next.js features are no longer necessary in the app directory. Learn more about i18n.\nbasePath has been removed. The alternative will not be part of useRouter. It has not yet been implemented.\nasPath has been removed because the concept of as has been removed from the new router.\nisReady has been removed because it is no longer necessary. During static rendering, any component that uses the useSearchParams() hook will skip the prerendering step and instead be rendered on the client at runtime.\nroute has been removed. usePathname or useSelectedLayoutSegments() provide an alternative.\n\nView the useRouter() API reference.\nSharing components between pages and app\n\nTo keep components compatible between the pages and app routers, refer to the useRouter hook from next/compat/router.\nThis is the useRouter hook from the pages directory, but intended to be used while sharing components between routers. Once you are ready to use it only on the app router, update to the new useRouter from next/navigation.\nStep 6: Migrating Data Fetching Methods\n\nThe pages directory uses getServerSideProps and getStaticProps to fetch data for pages. Inside the app directory, these previous data fetching functions are replaced with a simpler API built on top of fetch() and async React Server Components.\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  // This request should be cached until manually invalidated.\n  // Similar to `getStaticProps`.\n  // `force-cache` is the default and can be omitted.\n  const staticData = await fetch(`https://...`, { cache: 'force-cache' })\n\n  // This request should be refetched on every request.\n  // Similar to `getServerSideProps`.\n  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\n\n  // This request should be cached with a lifetime of 10 seconds.\n  // Similar to `getStaticProps` with the `revalidate` option.\n  const revalidatedData = await fetch(`https://...`, {\n    next: { revalidate: 10 },\n  })\n\n  return <div>...</div>\n}\n\nServer-side Rendering (getServerSideProps)\n\nIn the pages directory, getServerSideProps is used to fetch data on the server and forward props to the default exported React component in the file. The initial HTML for the page is prerendered from the server, followed by \"hydrating\" the page in the browser (making it interactive).\npages/dashboard.js// `pages` directory\n\nexport async function getServerSideProps() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return { props: { projects } }\n}\n\nexport default function Dashboard({ projects }) {\n  return (\n    <ul>\n      {projects.map((project) => (\n        <li key={project.id}>{project.name}</li>\n      ))}\n    </ul>\n  )\n}\nIn the App Router, we can colocate our data fetching inside our React components using Server Components. This allows us to send less JavaScript to the client, while maintaining the rendered HTML from the server.\nBy setting the cache option to no-store, we can indicate that the fetched data should never be cached. This is similar to getServerSideProps in the pages directory.\napp/dashboard/page.tsxTypeScriptJavaScriptTypeScript// `app` directory\n\n// This function can be named anything\nasync function getProjects() {\n  const res = await fetch(`https://...`, { cache: 'no-store' })\n  const projects = await res.json()\n\n  return projects\n}\n\nexport default async function Dashboard() {\n  const projects = await getProjects()\n\n  return (\n    <ul>\n      {projects.map((project) => (\n        <li key={project.id}>{project.name}</li>\n      ))}\n    </ul>\n  )\n}\n\nAccessing Request Object\n\nIn the pages directory, you can retrieve request-based data based on the Node.js HTTP API.\nFor example, you can retrieve the req object from getServerSideProps and use it to retrieve the request's cookies and headers.\npages/index.js// `pages` directory\n\nexport async function getServerSideProps({ req, query }) {\n  const authHeader = req.getHeaders()['authorization'];\n  const theme = req.cookies['theme'];\n\n  return { props: { ... }}\n}\n\nexport default function Page(props) {\n  return ...\n}\nThe app directory exposes new read-only functions to retrieve request data:\n\nheaders: Based on the Web Headers API, and can be used inside Server Components to retrieve request headers.\ncookies: Based on the Web Cookies API, and can be used inside Server Components to retrieve cookies.\n\napp/page.tsxTypeScriptJavaScriptTypeScript// `app` directory\nimport { cookies, headers } from 'next/headers'\n\nasync function getData() {\n  const authHeader = (await headers()).get('authorization')\n\n  return '...'\n}\n\nexport default async function Page() {\n  // You can use `cookies` or `headers` inside Server Components\n  // directly or in your data fetching function\n  const theme = (await cookies()).get('theme')\n  const data = await getData()\n  return '...'\n}\n\nStatic Site Generation (getStaticProps)\n\nIn the pages directory, the getStaticProps function is used to pre-render a page at build time. This function can be used to fetch data from an external API or directly from a database, and pass this data down to the entire page as it's being generated during the build.\npages/index.js// `pages` directory\n\nexport async function getStaticProps() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return { props: { projects } }\n}\n\nexport default function Index({ projects }) {\n  return projects.map((project) => <div>{project.name}</div>)\n}\nIn the app directory, data fetching with fetch() will default to cache: 'force-cache', which will cache the request data until manually invalidated. This is similar to getStaticProps in the pages directory.\napp/page.js// `app` directory\n\n// This function can be named anything\nasync function getProjects() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return projects\n}\n\nexport default async function Index() {\n  const projects = await getProjects()\n\n  return projects.map((project) => <div>{project.name}</div>)\n}\nDynamic paths (getStaticPaths)\n\nIn the pages directory, the getStaticPaths function is used to define the dynamic paths that should be pre-rendered at build time.\npages/posts/[id].js// `pages` directory\nimport PostLayout from '@/components/post-layout'\n\nexport async function getStaticPaths() {\n  return {\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\n  }\n}\n\nexport async function getStaticProps({ params }) {\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n\n  return { props: { post } }\n}\n\nexport default function Post({ post }) {\n  return <PostLayout post={post} />\n}\nIn the app directory, getStaticPaths is replaced with generateStaticParams.\ngenerateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and can be used inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of nested param objects or a string of resolved paths.\napp/posts/[id]/page.js// `app` directory\nimport PostLayout from '@/components/post-layout'\n\nexport async function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }]\n}\n\nasync function getPost(params) {\n  const res = await fetch(`https://.../posts/${(await params).id}`)\n  const post = await res.json()\n\n  return post\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params)\n\n  return <PostLayout post={post} />\n}\nUsing the name generateStaticParams is more appropriate than getStaticPaths for the new model in the app directory. The get prefix is replaced with a more descriptive generate, which sits better alone now that getStaticProps and getServerSideProps are no longer necessary. The Paths suffix is replaced by Params, which is more appropriate for nested routing with multiple dynamic segments.\n\nReplacing fallback\n\nIn the pages directory, the fallback property returned from getStaticPaths is used to define the behavior of a page that isn't pre-rendered at build time. This property can be set to true to show a fallback page while the page is being generated, false to show a 404 page, or blocking to generate the page at request time.\npages/posts/[id].js// `pages` directory\n\nexport async function getStaticPaths() {\n  return {\n    paths: [],\n    fallback: 'blocking'\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  ...\n}\n\nexport default function Post({ post }) {\n  return ...\n}\nIn the app directory the config.dynamicParams property controls how params outside of generateStaticParams are handled:\n\ntrue: (default) Dynamic segments not included in generateStaticParams are generated on demand.\nfalse: Dynamic segments not included in generateStaticParams will return a 404.\n\nThis replaces the fallback: true | false | 'blocking' option of getStaticPaths in the pages directory. The fallback: 'blocking' option is not included in dynamicParams because the difference between 'blocking' and true is negligible with streaming.\napp/posts/[id]/page.js// `app` directory\n\nexport const dynamicParams = true;\n\nexport async function generateStaticParams() {\n  return [...]\n}\n\nasync function getPost(params) {\n  ...\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params);\n\n  return ...\n}\nWith dynamicParams set to true (the default), when a route segment is requested that hasn't been generated, it will be server-rendered and cached.\nIncremental Static Regeneration (getStaticProps with revalidate)\n\nIn the pages directory, the getStaticProps function allows you to add a revalidate field to automatically regenerate a page after a certain amount of time.\npages/index.js// `pages` directory\n\nexport async function getStaticProps() {\n  const res = await fetch(`https://.../posts`)\n  const posts = await res.json()\n\n  return {\n    props: { posts },\n    revalidate: 60,\n  }\n}\n\nexport default function Index({ posts }) {\n  return (\n    <Layout>\n      <PostList posts={posts} />\n    </Layout>\n  )\n}\nIn the app directory, data fetching with fetch() can use revalidate, which will cache the request for the specified amount of seconds.\napp/page.js// `app` directory\n\nasync function getPosts() {\n  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })\n  const data = await res.json()\n\n  return data.posts\n}\n\nexport default async function PostList() {\n  const posts = await getPosts()\n\n  return posts.map((post) => <div>{post.name}</div>)\n}\nAPI Routes\n\nAPI Routes continue to work in the pages/api directory without any changes. However, they have been replaced by Route Handlers in the app directory.\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.\napp/api/route.tsTypeScriptJavaScriptTypeScriptexport async function GET(request: Request) {}\n\nGood to know: If you previously used API routes to call an external API from the client, you can now use Server Components instead to securely fetch data. Learn more about data fetching.\n\nSingle-Page Applications\n\nIf you are also migrating to Next.js from a Single-Page Application (SPA) at the same time, see our documentation to learn more.\nStep 7: Styling\n\nIn the pages directory, global stylesheets are restricted to only pages/_app.js. With the app directory, this restriction has been lifted. Global styles can be added to any layout, page, or component.\n\nCSS Modules\nTailwind CSS\nGlobal Styles\nCSS-in-JS\nExternal Stylesheets\nSass\n\nTailwind CSS\n\nIf you're using Tailwind CSS, you'll need to add the app directory to your tailwind.config.js file:\ntailwind.config.jsmodule.exports = {\n  content: [\n    './app/**/*.{js,ts,jsx,tsx,mdx}', // <-- Add this line\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n}\nYou'll also need to import your global styles in your app/layout.js file:\napp/layout.jsimport '../styles/globals.css'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\nLearn more about styling with Tailwind CSS\nUsing App Router together with Pages Router\n\nWhen navigating between routes served by the different Next.js routers, there will be a hard navigation. Automatic link prefetching with next/link will not prefetch across routers.\nInstead, you can optimize navigations between App Router and Pages Router to retain the prefetched and fast page transitions. Learn more.\nCodemods\n\nNext.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. See Codemods for more information.PreviousMigratingNextCreate React AppWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/migrating/from-create-react-app", "content": "in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspackOn this pageWhy Switch?Slow initial page loading timeNo automatic code splittingNetwork waterfallsFast and intentional loading statesChoose the data fetching strategyMiddlewareBuilt-in OptimizationsMigration StepsStep 1: Install the Next.js DependencyStep 2: Create the Next.js Configuration FileStep 3: Create the Root LayoutStep 4: MetadataStep 5: StylesStep 6: Create the Entrypoint PageStep 7: Add a Client-Only EntrypointStep 8: Update Static Image ImportsStep 9: Migrate Environment VariablesStep 10: Update Scripts in package.jsonStep 11: Clean UpAdditional ConsiderationsUsing a Custom homepage in CRAHandling a Custom Service WorkerProxying API RequestsCustom Webpack / Babel ConfigTypeScript SetupBundler CompatibilityNext StepsEdit this page on GitHub Scroll to top GuidesMigratingCreate React AppHow to migrate from Create React App to Next.jsThis guide will help you migrate an existing Create React App (CRA) site to Next.js.\nWhy Switch?\n\nThere are several reasons why you might want to switch from Create React App to Next.js:\nSlow initial page loading time\n\nCreate React App uses purely client-side rendering. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:\n\nThe browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load data.\nYour application code grows with every new feature and dependency you add.\n\nNo automatic code splitting\n\nThe previous issue of slow loading times can be somewhat mitigated with code splitting. However, if you try to do code splitting manually, you can inadvertently introduce network waterfalls. Next.js provides automatic code splitting and tree-shaking built into its router and build pipeline.\nNetwork waterfalls\n\nA common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One pattern for data fetching in a SPA is to render a placeholder, and then fetch data after the component has mounted. Unfortunately, a child component can only begin fetching data after its parent has finished loading its own data, resulting in a \u201cwaterfall\u201d of requests.\nWhile client-side data fetching is supported in Next.js, Next.js also lets you move data fetching to the server. This often eliminates client-server waterfalls altogether.\nFast and intentional loading states\n\nWith built-in support for streaming through React Suspense, you can define which parts of your UI load first and in what order, without creating network waterfalls.\nThis enables you to build pages that are faster to load and eliminate layout shifts.\nChoose the data fetching strategy\n\nDepending on your needs, Next.js allows you to choose your data fetching strategy on a page or component-level basis. For example, you could fetch data from your CMS and render blog posts at build time (SSG) for quick load speeds, or fetch data at request time (SSR) when necessary.\nMiddleware\n\nNext.js Middleware allows you to run code on the server before a request is completed. For instance, you can avoid a flash of unauthenticated content by redirecting a user to a login page in the middleware for authenticated-only pages. You can also use it for features like A/B testing, experimentation, and internationalization.\nBuilt-in Optimizations\n\nImages, fonts, and third-party scripts often have a large impact on an application\u2019s performance. Next.js includes specialized components and APIs that automatically optimize them for you.\nMigration Steps\n\nOur goal is to get a working Next.js application as quickly as possible so that you can then adopt Next.js features incrementally. To begin with, we\u2019ll treat your application as a purely client-side application (SPA) without immediately replacing your existing router. This reduces complexity and merge conflicts.\n\nNote: If you are using advanced CRA configurations such as a custom homepage field in your package.json, a custom service worker, or specific Babel/webpack tweaks, please see the Additional Considerations section at the end of this guide for tips on replicating or adapting these features in Next.js.\n\nStep 1: Install the Next.js Dependency\n\nInstall Next.js in your existing project:\nTerminalnpm install next@latest\nStep 2: Create the Next.js Configuration File\n\nCreate a next.config.ts at the root of your project (same level as your package.json). This file holds your Next.js configuration options.\nnext.config.tsimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  output: 'export', // Outputs a Single-Page Application (SPA)\n  distDir: 'build', // Changes the build output directory to `build`\n}\n\nexport default nextConfig\n\nNote: Using output: 'export' means you\u2019re doing a static export. You will not have access to server-side features like SSR or APIs. You can remove this line to leverage Next.js server features.\n\nStep 3: Create the Root Layout\n\nA Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all your pages.\nThe closest equivalent of the root layout file in a CRA application is public/index.html, which includes your <html>, <head>, and <body> tags.\n\nCreate a new app directory inside your src folder (or at your project root if you prefer app at the root).\nInside the app directory, create a layout.tsx (or layout.js) file:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return '...'\n}\n\nNow copy the content of your old index.html into this <RootLayout> component. Replace body div#root (and body noscript) with <div id=\"root\">{children}</div>.\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"UTF-8\" />\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nGood to know: Next.js ignores CRA\u2019s public/manifest.json, additional iconography, and testing configuration by default. If you need these, Next.js has support with its Metadata API and Testing setup.\n\nStep 4: Metadata\n\nNext.js automatically includes the <meta charset=\"UTF-8\" /> and <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> tags, so you can remove them from <head>:\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nAny metadata files such as favicon.ico, icon.png, robots.txt are automatically added to the application <head> tag as long as you have them placed into the top level of the app directory. After moving all supported files into the app directory you can safely delete their <link> tags:\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nFinally, Next.js can manage your last <head> tags with the Metadata API. Move your final metadata info into an exported metadata object:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'React App',\n  description: 'Web site created with Next.js.',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nWith the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.\nStep 5: Styles\n\nLike CRA, Next.js supports CSS Modules out of the box. It also supports global CSS imports.\nIf you have a global CSS file, import it into your app/layout.tsx:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport '../index.css'\n\nexport const metadata = {\n  title: 'React App',\n  description: 'Web site created with Next.js.',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\nIf you\u2019re using Tailwind CSS, see our installation docs.\nStep 6: Create the Entrypoint Page\n\nCreate React App uses src/index.tsx (or index.js) as the entry point. In Next.js (App Router), each folder inside the app directory corresponds to a route, and each folder should have a page.tsx.\nSince we want to keep the app as an SPA for now and intercept all routes, we\u2019ll use an optional catch-all route.\n\nCreate a [[...slug]] directory inside app.\n\napp\n \u2523 [[...slug]]\n \u2503 \u2517 page.tsx\n \u2523 layout.tsx\n\nAdd the following to page.tsx:\n\napp/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // We'll update this\n}\n\nThis tells Next.js to generate a single route for the empty slug (/), effectively mapping all routes to the same page. This page is a Server Component, prerendered into static HTML.\nStep 7: Add a Client-Only Entrypoint\n\nNext, we\u2019ll embed your CRA\u2019s root App component inside a Client Component so that all logic remains client-side. If this is your first time using Next.js, it's worth knowing that clients components (by default) are still prerendered on the server. You can think about them as having the additional capability of running client-side JavaScript.\nCreate a client.tsx (or client.js) in app/[[...slug]]/:\napp/[[...slug]]/client.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return <App />\n}\n\nThe 'use client' directive makes this file a Client Component.\nThe dynamic import with ssr: false disables server-side rendering for the <App /> component, making it truly client-only (SPA).\n\nNow update your page.tsx (or page.js) to use your new component:\napp/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport { ClientOnly } from './client'\n\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return <ClientOnly />\n}\n\nStep 8: Update Static Image Imports\n\nIn CRA, importing an image file returns its public URL as a string:\nimport image from './img.png'\n\nexport default function App() {\n  return <img src={image} />\n}\nWith Next.js, static image imports return an object. The object can then be used directly with the Next.js <Image> component, or you can use the object's src property with your existing <img> tag.\nThe <Image> component has the added benefits of automatic image optimization. The <Image> component automatically sets the width and height attributes of the resulting <img> based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the <img> dimension attribute's value, which can cause the image to appear distorted.\nKeeping the <img> tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the <Image> component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization.\nConvert absolute import paths for images imported from /public into relative imports:\n// Before\nimport logo from '/logo.png'\n\n// After\nimport logo from '../public/logo.png'\nPass the image src property instead of the whole image object to your <img> tag:\n// Before\n<img src={logo} />\n\n// After\n<img src={logo.src} />\nAlternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value.\n\nWarning: If you're using TypeScript, you might encounter type errors when accessing the src property. To fix them, you need to add next-env.d.ts to the include array of your tsconfig.json file. Next.js will automatically generate this file when you run your application on step 9.\n\nStep 9: Migrate Environment Variables\n\nNext.js supports environment variables similarly to CRA but requires a NEXT_PUBLIC_ prefix for any variable you want to expose in the browser.\nThe main difference is the prefix used to expose environment variables on the client-side. Change all environment variables with the REACT_APP_ prefix to NEXT_PUBLIC_.\nStep 10: Update Scripts in package.json\n\nUpdate your package.json scripts to use Next.js commands. Also, add .next and next-env.d.ts to your .gitignore:\npackage.json{\n  \"scripts\": {\n    \"dev\": \"next dev --turbopack\",\n    \"build\": \"next build\",\n    \"start\": \"npx serve@latest ./build\"\n  }\n}\n.gitignore# ...\n.next\nnext-env.d.ts\nNow you can run:\nnpm run dev\nOpen http://localhost:3000. You should see your application now running on Next.js (in SPA mode).\nStep 11: Clean Up\n\nYou can now remove artifacts that are specific to Create React App:\n\npublic/index.html\nsrc/index.tsx\nsrc/react-app-env.d.ts\nThe reportWebVitals setup\nThe react-scripts dependency (uninstall it from package.json)\n\nAdditional Considerations\n\nUsing a Custom homepage in CRA\n\nIf you used the homepage field in your CRA package.json to serve the app under a specific subpath, you can replicate that in Next.js using the basePath configuration in next.config.ts:\nnext.config.tsimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  basePath: '/my-subpath',\n  // ...\n}\n\nexport default nextConfig\nHandling a Custom Service Worker\n\nIf you used CRA\u2019s service worker (e.g., serviceWorker.js from create-react-app), you can learn how to create Progressive Web Applications (PWAs) with Next.js.\nProxying API Requests\n\nIf your CRA app used the proxy field in package.json to forward requests to a backend server, you can replicate this with Next.js rewrites in next.config.ts:\nnext.config.tsimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*',\n        destination: 'https://your-backend.com/:path*',\n      },\n    ]\n  },\n}\nCustom Webpack / Babel Config\n\nIf you had a custom webpack or Babel configuration in CRA, you can extend Next.js\u2019s config in next.config.ts:\nnext.config.tsimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  webpack: (config, { isServer }) => {\n    // Modify the webpack config here\n    return config\n  },\n}\n\nexport default nextConfig\n\nNote: This will require disabling Turbopack by removing --turbopack from your dev script.\n\nTypeScript Setup\n\nNext.js automatically sets up TypeScript if you have a tsconfig.json. Make sure next-env.d.ts is listed in your tsconfig.json include array:\n{\n  \"include\": [\"next-env.d.ts\", \"app/**/*\", \"src/**/*\"]\n}\nBundler Compatibility\n\nBoth Create React App and Next.js default to webpack for bundling. Next.js also offers Turbopack for faster local development with:\nnext dev --turbopack\nYou can still provide a custom webpack configuration if you need to migrate advanced webpack settings from CRA.\nNext Steps\n\nIf everything worked, you now have a functioning Next.js application running as a single-page application. You aren\u2019t yet leveraging Next.js features like server-side rendering or file-based routing, but you can now do so incrementally:\n\nMigrate from React Router to the Next.js App Router for:\n\nAutomatic code splitting\nStreaming server rendering\nReact Server Components\n\nOptimize images with the <Image> component\nOptimize fonts with next/font\nOptimize third-party scripts with the <Script> component\nEnable ESLint with Next.js recommended rules by running npx next lint and configuring it to match your project\u2019s needs\n\nNote: Using a static export (output: 'export') does not currently support the useParams hook or other server features. To use all Next.js features, remove output: 'export' from your next.config.ts.\nPreviousApp RouterNextViteWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/migrating/from-vite", "content": "in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspackOn this pageWhy Switch?Slow initial page loading timeNo automatic code splittingNetwork waterfallsFast and intentional loading statesChoose the data fetching strategyMiddlewareBuilt-in OptimizationsMigration StepsStep 1: Install the Next.js DependencyStep 2: Create the Next.js Configuration FileStep 3: Update TypeScript ConfigurationStep 4: Create the Root LayoutStep 5: Create the Entrypoint PageStep 6: Update Static Image ImportsStep 7: Migrate the Environment VariablesStep 8: Update Scripts in package.jsonStep 9: Clean UpNext StepsEdit this page on GitHub Scroll to top GuidesMigratingViteHow to migrate from Vite to Next.jsThis guide will help you migrate an existing Vite application to Next.js.\nWhy Switch?\n\nThere are several reasons why you might want to switch from Vite to Next.js:\nSlow initial page loading time\n\nIf you have built your application with the default Vite plugin for React, your application is a purely client-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:\n\nThe browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load some data.\nYour application code grows with every new feature and extra dependency you add.\n\nNo automatic code splitting\n\nThe previous issue of slow loading times can be somewhat managed with code splitting. However, if you try to do code splitting manually, you'll often make performance worse. It's easy to inadvertently introduce network waterfalls when code-splitting manually. Next.js provides automatic code splitting built into its router.\nNetwork waterfalls\n\nA common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the component has mounted. Unfortunately, this means that a child component that fetches data can't start fetching until the parent component has finished loading its own data.\nWhile fetching data on the client is supported with Next.js, it also gives you the option to shift data fetching to the server, which can eliminate client-server waterfalls.\nFast and intentional loading states\n\nWith built-in support for streaming through React Suspense, you can be more intentional about which parts of your UI you want to load first and in what order without introducing network waterfalls.\nThis enables you to build pages that are faster to load and eliminate layout shifts.\nChoose the data fetching strategy\n\nDepending on your needs, Next.js allows you to choose your data fetching strategy on a page and component basis. You can decide to fetch at build time, at request time on the server, or on the client. For example, you can fetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN.\nMiddleware\n\nNext.js Middleware allows you to run code on the server before a request is completed. This is especially useful to avoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login page. The middleware is also useful for experimentation and internationalization.\nBuilt-in Optimizations\n\nImages, fonts, and third-party scripts often have significant impact on an application's performance. Next.js comes with built-in components that automatically optimize those for you.\nMigration Steps\n\nOur goal with this migration is to get a working Next.js application as quickly as possible, so that\nyou can then adopt Next.js features incrementally. To begin with, we'll keep it as a purely\nclient-side application (SPA) without migrating your existing router. This helps minimize the\nchances of encountering issues during the migration process and reduces merge conflicts.\nStep 1: Install the Next.js Dependency\n\nThe first thing you need to do is to install next as a dependency:\nTerminalnpm install next@latest\nStep 2: Create the Next.js Configuration File\n\nCreate a next.config.mjs at the root of your project. This file will hold your\nNext.js configuration options.\nnext.config.mjs/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export', // Outputs a Single-Page Application (SPA).\n  distDir: './dist', // Changes the build output directory to `./dist/`.\n}\n\nexport default nextConfig\n\nGood to know: You can use either .js or .mjs for your Next.js configuration file.\n\nStep 3: Update TypeScript Configuration\n\nIf you're using TypeScript, you need to update your tsconfig.json file with the following changes\nto make it compatible with Next.js. If you're not using TypeScript, you can skip this step.\n\nRemove the project reference to tsconfig.node.json\nAdd ./dist/types/**/*.ts and ./next-env.d.ts to the include array\nAdd ./node_modules to the exclude array\nAdd { \"name\": \"next\" } to the plugins array in compilerOptions: \"plugins\": [{ \"name\": \"next\" }]\nSet esModuleInterop to true: \"esModuleInterop\": true\nSet jsx to preserve: \"jsx\": \"preserve\"\nSet allowJs to true: \"allowJs\": true\nSet forceConsistentCasingInFileNames to true: \"forceConsistentCasingInFileNames\": true\nSet incremental to true: \"incremental\": true\n\nHere's an example of a working tsconfig.json with those changes:\ntsconfig.json{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"preserve\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"allowJs\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"incremental\": true,\n    \"plugins\": [{ \"name\": \"next\" }]\n  },\n  \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"],\n  \"exclude\": [\"./node_modules\"]\n}\nYou can find more information about configuring TypeScript on the\nNext.js docs.\nStep 4: Create the Root Layout\n\nA Next.js App Router application must include a\nroot layout\nfile, which is a React Server Component\nthat will wrap all pages in your application. This file is defined at the top level of the app\ndirectory.\nThe closest equivalent to the root layout file in a Vite application is the\nindex.html file, which contains your\n<html>, <head>, and <body> tags.\nIn this step, you'll convert your index.html file into a root layout file:\n\nCreate a new app directory in your src folder.\nCreate a new layout.tsx file inside that app directory:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return '...'\n}\n\nGood to know: .js, .jsx, or .tsx extensions can be used for Layout files.\n\nCopy the content of your index.html file into the previously created <RootLayout> component while\nreplacing the body.div#root and body.script tags with <div id=\"root\">{children}</div>:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nNext.js already includes by default the\nmeta charset and\nmeta viewport tags, so you\ncan safely remove those from your <head>:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nAny metadata files\nsuch as favicon.ico, icon.png, robots.txt are automatically added to the application\n<head> tag as long as you have them placed into the top level of the app directory. After\nmoving\nall supported files\ninto the app directory you can safely delete their <link> tags:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nFinally, Next.js can manage your last <head> tags with the\nMetadata API. Move your final metadata\ninfo into an exported\nmetadata object:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My App',\n  description: 'My App is a...',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n\nWith the above changes, you shifted from declaring everything in your index.html to using Next.js'\nconvention-based approach built into the framework\n(Metadata API). This approach enables you\nto more easily improve your SEO and web shareability of your pages.\nStep 5: Create the Entrypoint Page\n\nOn Next.js you declare an entrypoint for your application by creating a page.tsx file. The\nclosest equivalent of this file on Vite is your main.tsx file. In this step, you\u2019ll set up the\nentrypoint of your application.\n\nCreate a [[...slug]] directory in your app directory.\n\nSince in this guide we're aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch all possible routes of your application. For that, create a new [[...slug]] directory in your app directory.\nThis directory is what is called an optional catch-all route segment. Next.js uses a file-system based router where folders are used to define routes. This special directory will make sure that all routes of your application will be directed to its containing page.tsx file.\n\nCreate a new page.tsx file inside the app/[[...slug]] directory with the following content:\n\napp/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport '../../index.css'\n\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // We'll update this\n}\n\nGood to know: .js, .jsx, or .tsx extensions can be used for Page files.\n\nThis file is a Server Component. When you run next build, the file is prerendered into a static asset. It does not require any dynamic code.\nThis file imports our global CSS and tells generateStaticParams we are only going to generate one route, the index route at /.\nNow, let's move the rest of our Vite application which will run client-only.\napp/[[...slug]]/client.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport React from 'react'\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return <App />\n}\n\nThis file is a Client Component, defined by the 'use client'\ndirective. Client Components are still prerendered to HTML on the server before being sent to the client.\nSince we want a client-only application to start, we can configure Next.js to disable prerendering from the App component down.\nconst App = dynamic(() => import('../../App'), { ssr: false })\nNow, update your entrypoint page to use the new component:\napp/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport '../../index.css'\nimport { ClientOnly } from './client'\n\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return <ClientOnly />\n}\n\nStep 6: Update Static Image Imports\n\nNext.js handles static image imports slightly different from Vite. With Vite, importing an image\nfile will return its public URL as a string:\nApp.tsximport image from './img.png' // `image` will be '/assets/img.2d8efhg.png' in production\n\nexport default function App() {\n  return <img src={image} />\n}\nWith Next.js, static image imports return an object. The object can then be used directly with the\nNext.js <Image> component, or you can use the object's\nsrc property with your existing <img> tag.\nThe <Image> component has the added benefits of\nautomatic image optimization. The <Image>\ncomponent automatically sets the width and height attributes of the resulting <img> based on\nthe image's dimensions. This prevents layout shifts when the image loads. However, this can cause\nissues if your app contains images with only one of their dimensions being styled without the other\nstyled to auto. When not styled to auto, the dimension will default to the <img> dimension\nattribute's value, which can cause the image to appear distorted.\nKeeping the <img> tag will reduce the amount of changes in your application and prevent the above\nissues. You can then optionally later migrate to the <Image> component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization.\n\nConvert absolute import paths for images imported from /public into relative imports:\n\n// Before\nimport logo from '/logo.png'\n\n// After\nimport logo from '../public/logo.png'\n\nPass the image src property instead of the whole image object to your <img> tag:\n\n// Before\n<img src={logo} />\n\n// After\n<img src={logo.src} />\nAlternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value.\n\nWarning: If you're using TypeScript, you might encounter type errors when accessing the src\nproperty. You can safely ignore those for now. They will be fixed by the end of this guide.\n\nStep 7: Migrate the Environment Variables\n\nNext.js has support for .env\nenvironment variables\nsimilar to Vite. The main difference is the prefix used to expose environment variables on the\nclient-side.\n\nChange all environment variables with the VITE_ prefix to NEXT_PUBLIC_.\n\nVite exposes a few built-in environment variables on the special import.meta.env object which\naren\u2019t supported by Next.js. You need to update their usage as follows:\n\nimport.meta.env.MODE \u21d2 process.env.NODE_ENV\nimport.meta.env.PROD \u21d2 process.env.NODE_ENV === 'production'\nimport.meta.env.DEV \u21d2 process.env.NODE_ENV !== 'production'\nimport.meta.env.SSR \u21d2 typeof window !== 'undefined'\n\nNext.js also doesn't provide a built-in BASE_URL environment variable. However, you can still\nconfigure one, if you need it:\n\nAdd the following to your .env file:\n\n.env# ...\nNEXT_PUBLIC_BASE_PATH=\"/some-base-path\"\n\nSet basePath to process.env.NEXT_PUBLIC_BASE_PATH in your next.config.mjs file:\n\nnext.config.mjs/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export', // Outputs a Single-Page Application (SPA).\n  distDir: './dist', // Changes the build output directory to `./dist/`.\n  basePath: process.env.NEXT_PUBLIC_BASE_PATH, // Sets the base path to `/some-base-path`.\n}\n\nexport default nextConfig\n\nUpdate import.meta.env.BASE_URL usages to process.env.NEXT_PUBLIC_BASE_PATH\n\nStep 8: Update Scripts in package.json\n\nYou should now be able to run your application to test if you successfully migrated to Next.js. But\nbefore that, you need to update your scripts in your package.json with Next.js related commands,\nand add .next and next-env.d.ts to your .gitignore:\npackage.json{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\n.gitignore# ...\n.next\nnext-env.d.ts\ndist\nNow run npm run dev, and open http://localhost:3000. You should see your application now running on Next.js.\n\nExample: Check out this pull request for a\nworking example of a Vite application migrated to Next.js.\n\nStep 9: Clean Up\n\nYou can now clean up your codebase from Vite related artifacts:\n\nDelete main.tsx\nDelete index.html\nDelete vite-env.d.ts\nDelete tsconfig.node.json\nDelete vite.config.ts\nUninstall Vite dependencies\n\nNext Steps\n\nIf everything went according to plan, you now have a functioning Next.js application running as a\nsingle-page application. However, you aren't yet taking advantage of most of Next.js' benefits, but\nyou can now start making incremental changes to reap all the benefits. Here's what you might want to\ndo next:\n\nMigrate from React Router to the Next.js App Router to get:\n\nAutomatic code splitting\nStreaming Server-Rendering\nReact Server Components\n\nOptimize images with the <Image> component\nOptimize fonts with next/font\nOptimize third-party scripts with the <Script> component\nUpdate your ESLint configuration to support Next.js rules\nPreviousCreate React AppNextMulti-tenantWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/multi-tenant", "content": "tHow to build multi-tenant apps in Next.jsIf you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our recommended architecture.PreviousViteNextMulti-zonesWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/multi-zones", "content": "How to build micro-frontends using multi-zones and Next.js\nExamples\nWith Zones\n\nMulti-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework.\nFor example, let's say you have the following set of pages that you would like to split up:\n\n/blog/* for all blog posts\n/dashboard/* for all pages when the user is logged-in to the dashboard\n/* for the rest of your website not covered by other zones\n\nWith Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently.\n\nNavigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from / to /products will be a soft navigation.\nNavigating from a page in one zone to a page in another zone, such as from / to /dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations.\nHow to define a zone\n\nA zone is a normal Next.js application where you also configure an assetPrefix to avoid conflicts with pages and static files in other zones.\nnext.config.js/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  assetPrefix: '/blog-static',\n}\nNext.js assets, such as JavaScript and CSS, will be prefixed with assetPrefix to make sure that they don't conflict with assets from other zones. These assets will be served under /assetPrefix/_next/... for each of the zones.\nThe default application handling all paths not routed to another more specific zone does not need an assetPrefix.\nIn versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15.\nnext.config.js/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  assetPrefix: '/blog-static',\n  async rewrites() {\n    return {\n      beforeFiles: [\n        {\n          source: '/blog-static/_next/:path+',\n          destination: '/_next/:path+',\n        },\n      ],\n    }\n  },\n}\nHow to route requests to the right zone\n\nWith the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain.\nTo route to the correct zone using a Next.js application, you can use rewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone, and you also need to rewrite the requests for the static assets. For example:\nnext.config.jsasync rewrites() {\n    return [\n        {\n            source: '/blog',\n            destination: `${process.env.BLOG_DOMAIN}/blog`,\n        },\n        {\n            source: '/blog/:path+',\n            destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,\n        },\n        {\n            source: '/blog-static/:path+',\n            destination: `${process.env.BLOG_DOMAIN}/blog-static/:path+`,\n        }\n    ];\n}\ndestination should be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests to localhost in local development.\n\nGood to know: URL paths should be unique to a zone. For example, two zones trying to serve /blog would create a routing conflict.\n\nRouting requests using middleware\n\nRouting requests through rewrites is recommended to minimize latency overhead for the requests, but middleware can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use middleware.\nmiddleware.jsexport async function middleware(request) {\n  const { pathname, search } = req.nextUrl;\n  if (pathname === '/your-path' && myFeatureFlag.isEnabled()) {\n    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search});\n  }\n}\nLinking between zones\n\nLinks to paths in a different zone should use an a tag instead of the Next.js <Link> component. This is because Next.js will try to prefetch and soft navigate to any relative path in <Link> component, which will not work across zones.\nSharing code\n\nThe Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in a monorepo to more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages.\nSince the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones.\nServer Actions\n\nWhen using Server Actions with Multi-Zones, you must explicitly allow the user-facing origin since your user facing domain may serve multiple applications. In your next.config.js file, add the following lines:next.config.jsconst nextConfig = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: ['your-production-domain.com'],\n    },\n  },\n}See serverActions.allowedOrigins for more information.PreviousMulti-tenantNextOpenTelemetryWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/open-telemetry", "content": "ryHow to set up instrumentation with OpenTelemetry\nObservability is crucial for understanding and optimizing the behavior and performance of your Next.js app.\nAs applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.\nWe recommend using OpenTelemetry for instrumenting your apps.\nIt's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.\nRead Official OpenTelemetry docs for more information about OpenTelemetry and how it works.\nThis documentation uses terms like Span, Trace or Exporter throughout this doc, all of which can be found in the OpenTelemetry Observability Primer.\nNext.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.\n\nGetting Started\n\nOpenTelemetry is extensible but setting it up properly can be quite verbose.\nThat's why we prepared a package @vercel/otel that helps you get started quickly.\nUsing @vercel/otel\n\nTo get started, install the following packages:\nTerminalnpm install @vercel/otel @opentelemetry/sdk-logs @opentelemetry/api-logs @opentelemetry/instrumentation\nNext, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one):\n\nyour-project/instrumentation.tsTypeScriptJavaScriptTypeScriptimport { registerOTel } from '@vercel/otel'\n\nexport function register() {\n  registerOTel({ serviceName: 'next-app' })\n}\n\nSee the @vercel/otel documentation for additional configuration options.\n\nGood to know:\n\nThe instrumentation file should be in the root of your project and not inside the app or pages directory. If you're using the src folder, then place the file inside src alongside pages and app.\nIf you use the pageExtensions config option to add a suffix, you will also need to update the instrumentation filename to match.\nWe have created a basic with-opentelemetry example that you can use.\n\nManual OpenTelemetry configuration\n\nThe @vercel/otel package provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually.\nFirstly you need to install OpenTelemetry packages:\nTerminalnpm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http\nNow you can initialize NodeSDK in your instrumentation.ts.\nUnlike @vercel/otel, NodeSDK is not compatible with edge runtime, so you need to make sure that you are importing them only when process.env.NEXT_RUNTIME === 'nodejs'. We recommend creating a new file instrumentation.node.ts which you conditionally import only when using node:\ninstrumentation.tsTypeScriptJavaScriptTypeScriptexport async function register() {\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\n    await import('./instrumentation.node.ts')\n  }\n}\n\ninstrumentation.node.tsTypeScriptJavaScriptTypeScriptimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\nimport { Resource } from '@opentelemetry/resources'\nimport { NodeSDK } from '@opentelemetry/sdk-node'\nimport { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node'\nimport { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions'\n\nconst sdk = new NodeSDK({\n  resource: new Resource({\n    [ATTR_SERVICE_NAME]: 'next-app',\n  }),\n  spanProcessor: new SimpleSpanProcessor(new OTLPTraceExporter()),\n})\nsdk.start()\n\nDoing this is equivalent to using @vercel/otel, but it's possible to modify and extend some features that are not exposed by the @vercel/otel. If edge runtime support is necessary, you will have to use @vercel/otel.\nTesting your instrumentation\n\nYou need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally.\nWe recommend using our OpenTelemetry dev environment.\nIf everything works well you should be able to see the root server span labeled as GET /requested/pathname.\nAll other spans from that particular trace will be nested under it.\nNext.js traces more spans than are emitted by default.\nTo see more spans, you must set NEXT_OTEL_VERBOSE=1.\nDeployment\n\nUsing OpenTelemetry Collector\n\nWhen you are deploying with OpenTelemetry Collector, you can use @vercel/otel.\nIt will work both on Vercel and when self-hosted.\nDeploying on Vercel\n\nWe made sure that OpenTelemetry works out of the box on Vercel.\nFollow Vercel documentation to connect your project to an observability provider.\nSelf-hosting\n\nDeploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.\nTo do this, follow the OpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.\nOnce you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.\nCustom Exporters\n\nOpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with @vercel/otel or manual OpenTelemetry configuration.\nCustom Spans\n\nYou can add a custom span with OpenTelemetry APIs.\nTerminalnpm install @opentelemetry/api\nThe following example demonstrates a function that fetches GitHub stars and adds a custom fetchGithubStars span to track the fetch request's result:\nimport { trace } from '@opentelemetry/api'\n\nexport async function fetchGithubStars() {\n  return await trace\n    .getTracer('nextjs-example')\n    .startActiveSpan('fetchGithubStars', async (span) => {\n      try {\n        return await getValue()\n      } finally {\n        span.end()\n      }\n    })\n}\nThe register function will execute before your code runs in a new environment.\nYou can start creating new spans, and they should be correctly added to the exported trace.\nDefault Spans in Next.js\n\nNext.js automatically instruments several spans for you to provide useful insights into your application's performance.\nAttributes on spans follow OpenTelemetry semantic conventions. We also add some custom attributes under the next namespace:\n\nnext.span_name - duplicates span name\nnext.span_type - each span type has a unique identifier\nnext.route - The route pattern of the request (e.g., /[param]/user).\nnext.rsc (true/false) - Whether the request is an RSC request, such as prefetch.\nnext.page\n\nThis is an internal value used by an app router.\nYou can think about it as a route to a special file (like page.ts, layout.ts, loading.ts and others)\nIt can be used as a unique identifier only when paired with next.route because /layout can be used to identify both /(groupA)/layout.ts and /(groupB)/layout.ts\n\n[http.method] [next.route]\n\nnext.span_type: BaseServer.handleRequest\n\nThis span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.\nAttributes:\n\nCommon HTTP attributes\n\nhttp.method\nhttp.status_code\n\nServer HTTP attributes\n\nhttp.route\nhttp.target\n\nnext.span_name\nnext.span_type\nnext.route\n\nrender route (app) [next.route]\n\nnext.span_type: AppRender.getBodyResult.\n\nThis span represents the process of rendering a route in the app router.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.route\n\nfetch [http.method] [http.url]\n\nnext.span_type: AppRender.fetch\n\nThis span represents the fetch request executed in your code.\nAttributes:\n\nCommon HTTP attributes\n\nhttp.method\n\nClient HTTP attributes\n\nhttp.url\nnet.peer.name\nnet.peer.port (only if specified)\n\nnext.span_name\nnext.span_type\n\nThis span can be turned off by setting NEXT_OTEL_FETCH_DISABLED=1 in your environment. This is useful when you want to use a custom fetch instrumentation library.\nexecuting api route (app) [next.route]\n\nnext.span_type: AppRouteRouteHandlers.runHandler.\n\nThis span represents the execution of an API Route Handler in the app router.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.route\n\ngetServerSideProps [next.route]\n\nnext.span_type: Render.getServerSideProps.\n\nThis span represents the execution of getServerSideProps for a specific route.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.route\n\ngetStaticProps [next.route]\n\nnext.span_type: Render.getStaticProps.\n\nThis span represents the execution of getStaticProps for a specific route.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.route\n\nrender route (pages) [next.route]\n\nnext.span_type: Render.renderDocument.\n\nThis span represents the process of rendering the document for a specific route.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.route\n\ngenerateMetadata [next.page]\n\nnext.span_type: ResolveMetadata.generateMetadata.\n\nThis span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.page\n\nresolve page components\n\nnext.span_type: NextNodeServer.findPageComponents.\n\nThis span represents the process of resolving page components for a specific page.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.route\n\nresolve segment modules\n\nnext.span_type: NextNodeServer.getLayoutOrPageModule.\n\nThis span represents loading of code modules for a layout or a page.\nAttributes:\n\nnext.span_name\nnext.span_type\nnext.segment\n\nstart response\n\nnext.span_type: NextNodeServer.startResponse.\n\nThis zero-length span represents the time when the first byte has been sent in the response.PreviousMulti-zonesNextPackage BundlingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/package-bundling", "content": "dlingHow to optimize package bundlingBundling external packages can significantly improve the performance of your application. By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js. This page will guide you through how to analyze and further optimize package bundling. \nAnalyzing JavaScript bundles\n\n@next/bundle-analyzer is a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, or lazy-load your code.\nInstallation\n\nInstall the plugin by running the following command:\nnpm i @next/bundle-analyzer\n# or\nyarn add @next/bundle-analyzer\n# or\npnpm add @next/bundle-analyzer\nThen, add the bundle analyzer's settings to your next.config.js.\nnext.config.js/** @type {import('next').NextConfig} */\nconst nextConfig = {}\n\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\n\nmodule.exports = withBundleAnalyzer(nextConfig)\nGenerating a report\n\nRun the following command to analyze your bundles:\nANALYZE=true npm run build\n# or\nANALYZE=true yarn build\n# or\nANALYZE=true pnpm build\nThe report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.\nOptimizing package imports\n\nSome packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.\nYou can optimize how these packages are imported by adding the optimizePackageImports option to your next.config.js. This option will only load the modules you actually use, while still giving you the convenience of writing import statements with many named exports.\nnext.config.js/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    optimizePackageImports: ['icon-library'],\n  },\n}\n\nmodule.exports = nextConfig\nNext.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See the full list.\n\nOpting specific packages out of bundling\n\nSince packages imported inside Server Components and Route Handlers are automatically bundled by Next.js, you can opt specific packages out of bundling using the serverExternalPackages option in your next.config.js.next.config.js/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfigNext.js includes a list of popular packages that currently are working on compatibility and automatically opt-ed out. See the full list.Next StepsLearn more about optimizing your application for production.ProductionRecommendations to ensure the best performance and user experience before taking your Next.js application to production.PreviousOpenTelemetryNextPrefetchingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/prefetching", "content": "PrefetchingPrefetching makes navigating between different routes in your application feel instant. Next.js tries to intelligently prefetch by default, based on the links used in your application code.\nThis guide will explain how prefetching works and show common implementation patterns:\n\nAutomatic prefetch\nManual prefetch\nHover-triggered prefetch\nExtending or ejecting link\nDisabled prefetch\n\nHow does prefetching work?\n\nWhen navigating between routes, the browser requests assets for the page like HTML and JavaScript files. Prefetching is the process of fetching these resources ahead of time, before you navigate to a new route.\nNext.js automatically splits your application into smaller JavaScript chunks based on routes. Instead of loading all the code upfront like traditional SPAs, only the code needed for the current route is loaded. This reduces the initial load time while other parts of the app are loaded in the background. By the time you click the link, the resources for the new route have already been loaded into the browser cache.\nWhen navigating to the new page, there's no full page reload or browser loading spinner. Instead, Next.js performs a client-side transition, making the page navigation feel instant.\nPrefetching static vs. dynamic routes\n\nStatic pageDynamic pagePrefetchedYes, full routeNo, unless loading.jsClient Cache TTL5 min (default)Off, unless enabledServer roundtrip on clickNoYes, streamed after shell\n\nGood to know: During the initial navigation, the browser fetches the HTML, JavaScript, and React Server Components (RSC) Payload. For subsequent navigations, the browser will fetch the RSC Payload for Server Components and JS bundle for Client Components.\n\nAutomatic prefetch\n\napp/ui/nav-link.tsxTypeScriptJavaScriptTypeScriptimport Link from 'next/link'\n\nexport default function NavLink() {\n  return <Link href=\"/about\">About</Link>\n}\n\nContextPrefetched payloadClient Cache TTLNo loading.jsEntire pageUntil app reloadWith loading.jsLayout to first loading boundary30s (configurable)\nAutomatic prefetching runs only in production. Disable with prefetch={false} or use the wrapper in Disabled Prefetch.\nManual prefetch\n\n'use client'\n\nimport { useRouter } from 'next/navigation'\n\nconst router = useRouter()\nrouter.prefetch('/pricing')\nCall router.prefetch() to warm routes outside the viewport or in response to analytics, hover, scroll, etc.\nHover-triggered prefetch\n\nProceed with caution: Extending Link opts you into maintaining prefetching, cache invalidation, and accessibility concerns. Proceed only if defaults are insufficient.\n\nNext.js tries to do the right prefetching by default, but power users can eject and modify based on their needs. You have the control between performance and resource consumption.\nFor example, you might have to only trigger prefetches on hover, instead of when entering the viewport (the default behavior):\n'use client'\n\nimport Link from 'next/link'\nimport { useState } from 'react'\n\nexport function HoverPrefetchLink({\n  href,\n  children,\n}: {\n  href: string\n  children: React.ReactNode\n}) {\n  const [active, setActive] = useState(false)\n\n  return (\n    <Link\n      href={href}\n      prefetch={active ? null : false}\n      onMouseEnter={() => setActive(true)}\n    >\n      {children}\n    </Link>\n  )\n}\nprefetch={null} restores default (static) prefetching once the user shows intent.\nExtending or ejecting link\n\nYou can extend the <Link> component to create your own custom prefetching strategy. For example, using the ForesightJS library which prefetches links by predicting the direction of the user's cursor.\nAlternatively, you can use useRouter to recreate some of the native <Link> behavior. However, be aware this opts you into maintaining prefetching and cache invalidation.\n'use client'\n\nimport { useRouter } from 'next/navigation'\nimport { useEffect } from 'react'\n\nfunction ManualPrefetchLink({\n  href,\n  children,\n}: {\n  href: string\n  children: React.ReactNode\n}) {\n  const router = useRouter()\n\n  useEffect(() => {\n    let cancelled = false\n    const poll = () => {\n      if (!cancelled) router.prefetch(href, { onInvalidate: poll })\n    }\n    poll()\n    return () => {\n      cancelled = true\n    }\n  }, [href, router])\n\n  return (\n    <a\n      href={href}\n      onClick={(event) => {\n        event.preventDefault()\n        router.push(href)\n      }}\n    >\n      {children}\n    </a>\n  )\n}\nonInvalidate is invoked when Next.js suspects cached data is stale, allowing you to refresh the prefetch.\n\nGood to know: Using an a tag will cause a full page navigation to the destination route, you can use onClick to prevent the full page navigation, and then invoke router.push to navigate to the destination.\n\nDisabled prefetch\n\nYou can fully disable prefetching for certain routes for more fine-grained control over resource consumption.\n'use client'\n\nimport Link, { LinkProps } from 'next/link'\n\nfunction NoPrefetchLink({\n  prefetch,\n  ...rest\n}: LinkProps & { children: React.ReactNode }) {\n  return <Link {...rest} prefetch={false} />\n}\nFor example, you may still want to have consistent usage of <Link> in your application, but links in your footer might not need to be prefetched when entering the viewport.\nPrefetching optimizations\n\nGood to know: Layout deduplication and prefetch scheduling are part of upcoming optimizations. Currently available in Next.js canary via the experimental.clientSegmentCache flag.\n\nClient cache\n\nNext.js stores prefetched React Server Component payloads in memory, keyed by route segments. When navigating between sibling routes (e.g. /dashboard/settings \u2192 /dashboard/analytics), it reuses the parent layout and only fetches the updated leaf page. This reduces network traffic and improves navigation speed.\nPrefetch scheduling\n\nNext.js maintains a small task queue, which prefetches in the following order:\n\nLinks in the viewport\nLinks showing user intent (hover or touch)\nNewer links replace older ones\nLinks scrolled off-screen are discarded\n\nThe scheduler prioritizes likely navigations while minimizing unused downloads.\nPartial Prerendering (PPR)\n\nWhen PPR is enabled, a page is divided into a static shell and a streamed dynamic section:\n\nThe shell, which can be prefetched, streams immediately\nDynamic data streams when ready\nData invalidations (revalidateTag, revalidatePath) silently refresh associated prefetches\n\nTroubleshooting\n\nTriggering unwanted side-effects during prefetching\n\nIf your layouts or pages are not pure and have side-effects (e.g. tracking analytics), these might be triggered when the route is prefetched, not when the user visits the page.\nTo avoid this, you should move side-effects to a useEffect hook or a Server Action triggered from a Client Component.\nBefore:\napp/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport { trackPageView } from '@/lib/analytics'\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  // This runs during prefetch\n  trackPageView()\n\n  return <div>{children}</div>\n}\n\nAfter:\napp/ui/analytics-tracker.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useEffect } from 'react'\nimport { trackPageView } from '@/lib/analytics'\n\nexport function AnalyticsTracker() {\n  useEffect(() => {\n    trackPageView()\n  }, [])\n\n  return null\n}\n\napp/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport { AnalyticsTracker } from '@/app/ui/analytics-tracker'\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <div>\n      <AnalyticsTracker />\n      {children}\n    </div>\n  )\n}\n\nPreventing too many prefetches\n\nNext.js automatically prefetches links in the viewport when using the <Link> component.\nThere may be cases where you want to prevent this to avoid unnecessary usage of resources, such as when rendering a large list of links (e.g. an infinite scroll table).\nYou can disable prefetching by setting the prefetch prop of the <Link> component to false.\napp/ui/no-prefetch-link.tsxTypeScriptJavaScriptTypeScript<Link prefetch={false} href={`/blog/${post.id}`}>\n  {post.title}\n</Link>\nHowever, this means static routes will only be fetched on click, and dynamic routes will wait for the server to render before navigating.\nTo reduce resource usage without disabling prefetch entirely, you can defer prefetching until the user hovers over a link. This targets only links the user is likely to visit.\napp/ui/hover-prefetch-link.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport Link from 'next/link'\nimport { useState } from 'react'\n\nexport function HoverPrefetchLink({\n  href,\n  children,\n}: {\n  href: string\n  children: React.ReactNode\n}) {\n  const [active, setActive] = useState(false)\n\n  return (\n    <Link\n      href={href}\n      prefetch={active ? null : false}\n      onMouseEnter={() => setActive(true)}\n    >\n      {children}\n    </Link>\n  )\n}\nPreviousPackage BundlingNextProductionWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/production-checklist", "content": "ow to optimize your Next.js application for productionBefore taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security.\nThis page provides best practices that you can use as a reference when building your application and before going to production, as well as the automatic Next.js optimizations you should be aware of.\nAutomatic optimizations\n\nThese Next.js optimizations are enabled by default and require no configuration:\n\nServer Components: Next.js uses Server Components by default. Server Components run on the server, and don't require JavaScript to render on the client. As such, they have no impact on the size of your client-side JavaScript bundles. You can then use Client Components as needed for interactivity.\nCode-splitting: Server Components enable automatic code-splitting by route segments. You may also consider lazy loading Client Components and third-party libraries, where appropriate.\nPrefetching: When a link to a new route enters the user's viewport, Next.js prefetches the route in background. This makes navigation to new routes almost instant. You can opt out of prefetching, where appropriate.\nStatic Rendering: Next.js statically renders Server and Client Components on the server at build time and caches the rendered result to improve your application's performance. You can opt into Dynamic Rendering for specific routes, where appropriate. \nCaching: Next.js caches data requests, the rendered result of Server and Client Components, static assets, and more, to reduce the number of network requests to your server, database, and backend services. You may opt out of caching, where appropriate.\n\nThese defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request.\nDuring development\n\nWhile building your application, we recommend using the following features to ensure the best performance and user experience:\nRouting and rendering\n\nLayouts: Use layouts to share UI across pages and enable partial rendering on navigation.\n<Link> component: Use the <Link> component for client-side navigation and prefetching.\nError Handling: Gracefully handle catch-all errors and 404 errors in production by creating custom error pages.\nClient and Server Components: Follow the recommended composition patterns for Server and Client Components, and check the placement of your \"use client\" boundaries to avoid unnecessarily increasing your client-side JavaScript bundle.\nDynamic APIs: Be aware that Dynamic APIs like cookies and the searchParams prop will opt the entire route into Dynamic Rendering (or your whole application if used in the Root Layout). Ensure Dynamic API usage is intentional and wrap them in <Suspense> boundaries where appropriate.\n\nGood to know: Partial Prerendering (experimental) will allow parts of a route to be dynamic without opting the whole route into dynamic rendering.\n\nData fetching and caching\n\nServer Components: Leverage the benefits of fetching data on the server using Server Components.\nRoute Handlers: Use Route Handlers to access your backend resources from Client Components. But do not call Route Handlers from Server Components to avoid an additional server request.\nStreaming: Use Loading UI and React Suspense to progressively send UI from the server to the client, and prevent the whole route from blocking while data is being fetched.\nParallel Data Fetching: Reduce network waterfalls by fetching data in parallel, where appropriate. Also, consider preloading data where appropriate.\nData Caching: Verify whether your data requests are being cached or not, and opt into caching, where appropriate. Ensure requests that don't use fetch are cached.\nStatic Images: Use the public directory to automatically cache your application's static assets, e.g. images.\n\nUI and accessibility\n\nForms and Validation: Use Server Actions to handle form submissions, server-side validation, and handle errors.\n\nFont Module: Optimize fonts by using the Font Module, which automatically hosts your font files with other static assets, removes external network requests, and reduces layout shift.\n<Image> Component: Optimize images by using the Image Component, which automatically optimizes images, prevents layout shift, and serves them in modern formats like WebP.\n<Script> Component: Optimize third-party scripts by using the Script Component, which automatically defers scripts and prevents them from blocking the main thread.\nESLint: Use the built-in eslint-plugin-jsx-a11y plugin to catch accessibility issues early.\n\nSecurity\n\nTainting: Prevent sensitive data from being exposed to the client by tainting data objects and/or specific values.\nServer Actions: Ensure users are authorized to call Server Actions. Review the recommended security practices.\n\nEnvironment Variables: Ensure your .env.* files are added to .gitignore and only public variables are prefixed with NEXT_PUBLIC_.\nContent Security Policy: Consider adding a Content Security Policy to protect your application against various security threats such as cross-site scripting, clickjacking, and other code injection attacks.\n\nMetadata and SEO\n\nMetadata API: Use the Metadata API to improve your application's Search Engine Optimization (SEO) by adding page titles, descriptions, and more.\nOpen Graph (OG) images: Create OG images to prepare your application for social sharing.\nSitemaps and Robots: Help Search Engines crawl and index your pages by generating sitemaps and robots files.\n\nType safety\n\nTypeScript and TS Plugin: Use TypeScript and the TypeScript plugin for better type-safety, and to help you catch errors early.\n\nBefore going to production\n\nBefore going to production, you can run next build to build your application locally and catch any build errors, then run next start to measure the performance of your application in a production-like environment.\nCore Web Vitals\n\nLighthouse: Run lighthouse in incognito to gain a better understanding of how your users will experience your site, and to identify areas for improvement. This is a simulated test and should be paired with looking at field data (such as Core Web Vitals).\n\nuseReportWebVitals hook: Use this hook to send Core Web Vitals data to analytics tools.\n\nAnalyzing bundles\n\nUse the @next/bundle-analyzer plugin to analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance.\nAdditionally, the following tools can help you understand the impact of adding new dependencies to your application:\n\nImport Cost\nPackage Phobia\nBundle Phobia\nbundlejs\nPreviousPrefetchingNextPWAsWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/progressive-web-apps", "content": "build a Progressive Web Application (PWA) with Next.jsProgressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals.\nPWAs allow you to:\n\nDeploy updates instantly without waiting for app store approval\nCreate cross-platform applications with a single codebase\nProvide native-like features such as home screen installation and push notifications\n\nCreating a PWA with Next.js\n\n1. Creating the Web App Manifest\n\nNext.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file:\nFor example, create a app/manifest.ts or app/manifest.json file:\napp/manifest.tsTypeScriptJavaScriptTypeScriptimport type { MetadataRoute } from 'next'\n\nexport default function manifest(): MetadataRoute.Manifest {\n  return {\n    name: 'Next.js PWA',\n    short_name: 'NextPWA',\n    description: 'A Progressive Web App built with Next.js',\n    start_url: '/',\n    display: 'standalone',\n    background_color: '#ffffff',\n    theme_color: '#000000',\n    icons: [\n      {\n        src: '/icon-192x192.png',\n        sizes: '192x192',\n        type: 'image/png',\n      },\n      {\n        src: '/icon-512x512.png',\n        sizes: '512x512',\n        type: 'image/png',\n      },\n    ],\n  }\n}\n\nThis file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience.\nYou can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder.\n2. Implementing Web Push Notifications\n\nWeb Push Notifications are supported with all modern browsers, including:\n\niOS 16.4+ for applications installed to the home screen\nSafari 16 for macOS 13 or later\nChromium based browsers\nFirefox\n\nThis makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support.\nWeb Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application:\nFirst, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, we\u2019ll add some of the imports and utilities we\u2019ll need. It\u2019s okay that the referenced Server Actions do not yet exist:\n'use client'\n\nimport { useState, useEffect } from 'react'\nimport { subscribeUser, unsubscribeUser, sendNotification } from './actions'\n\nfunction urlBase64ToUint8Array(base64String: string) {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')\n\n  const rawData = window.atob(base64)\n  const outputArray = new Uint8Array(rawData.length)\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i)\n  }\n  return outputArray\n}\n\nLet\u2019s now add a component to manage subscribing, unsubscribing, and sending push notifications.\nfunction PushNotificationManager() {\n  const [isSupported, setIsSupported] = useState(false)\n  const [subscription, setSubscription] = useState<PushSubscription | null>(\n    null\n  )\n  const [message, setMessage] = useState('')\n\n  useEffect(() => {\n    if ('serviceWorker' in navigator && 'PushManager' in window) {\n      setIsSupported(true)\n      registerServiceWorker()\n    }\n  }, [])\n\n  async function registerServiceWorker() {\n    const registration = await navigator.serviceWorker.register('/sw.js', {\n      scope: '/',\n      updateViaCache: 'none',\n    })\n    const sub = await registration.pushManager.getSubscription()\n    setSubscription(sub)\n  }\n\n  async function subscribeToPush() {\n    const registration = await navigator.serviceWorker.ready\n    const sub = await registration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: urlBase64ToUint8Array(\n        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!\n      ),\n    })\n    setSubscription(sub)\n    const serializedSub = JSON.parse(JSON.stringify(sub))\n    await subscribeUser(serializedSub)\n  }\n\n  async function unsubscribeFromPush() {\n    await subscription?.unsubscribe()\n    setSubscription(null)\n    await unsubscribeUser()\n  }\n\n  async function sendTestNotification() {\n    if (subscription) {\n      await sendNotification(message)\n      setMessage('')\n    }\n  }\n\n  if (!isSupported) {\n    return <p>Push notifications are not supported in this browser.</p>\n  }\n\n  return (\n    <div>\n      <h3>Push Notifications</h3>\n      {subscription ? (\n        <>\n          <p>You are subscribed to push notifications.</p>\n          <button onClick={unsubscribeFromPush}>Unsubscribe</button>\n          <input\n            type=\"text\"\n            placeholder=\"Enter notification message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n          />\n          <button onClick={sendTestNotification}>Send Test</button>\n        </>\n      ) : (\n        <>\n          <p>You are not subscribed to push notifications.</p>\n          <button onClick={subscribeToPush}>Subscribe</button>\n        </>\n      )}\n    </div>\n  )\n}\n\nFinally, let\u2019s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed.\nfunction InstallPrompt() {\n  const [isIOS, setIsIOS] = useState(false)\n  const [isStandalone, setIsStandalone] = useState(false)\n\n  useEffect(() => {\n    setIsIOS(\n      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream\n    )\n\n    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches)\n  }, [])\n\n  if (isStandalone) {\n    return null // Don't show install button if already installed\n  }\n\n  return (\n    <div>\n      <h3>Install App</h3>\n      <button>Add to Home Screen</button>\n      {isIOS && (\n        <p>\n          To install this app on your iOS device, tap the share button\n          <span role=\"img\" aria-label=\"share icon\">\n            {' '}\n            \u238b{' '}\n          </span>\n          and then \"Add to Home Screen\"\n          <span role=\"img\" aria-label=\"plus icon\">\n            {' '}\n            \u2795{' '}\n          </span>.\n        </p>\n      )}\n    </div>\n  )\n}\n\nexport default function Page() {\n  return (\n    <div>\n      <PushNotificationManager />\n      <InstallPrompt />\n    </div>\n  )\n}\n\nNow, let\u2019s create the Server Actions which this file calls.\n3. Implementing Server Actions\n\nCreate a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications.\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport webpush from 'web-push'\n\nwebpush.setVapidDetails(\n  '<mailto:your-email@example.com>',\n  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,\n  process.env.VAPID_PRIVATE_KEY!\n)\n\nlet subscription: PushSubscription | null = null\n\nexport async function subscribeUser(sub: PushSubscription) {\n  subscription = sub\n  // In a production environment, you would want to store the subscription in a database\n  // For example: await db.subscriptions.create({ data: sub })\n  return { success: true }\n}\n\nexport async function unsubscribeUser() {\n  subscription = null\n  // In a production environment, you would want to remove the subscription from the database\n  // For example: await db.subscriptions.delete({ where: { ... } })\n  return { success: true }\n}\n\nexport async function sendNotification(message: string) {\n  if (!subscription) {\n    throw new Error('No subscription available')\n  }\n\n  try {\n    await webpush.sendNotification(\n      subscription,\n      JSON.stringify({\n        title: 'Test Notification',\n        body: message,\n        icon: '/icon.png',\n      })\n    )\n    return { success: true }\n  } catch (error) {\n    console.error('Error sending push notification:', error)\n    return { success: false, error: 'Failed to send notification' }\n  }\n}\n\nSending a notification will be handled by our service worker, created in step 5.\nIn a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions.\n4. Generating VAPID Keys\n\nTo use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly:\nFirst, install web-push globally:\nTerminalnpm install -g web-push\nGenerate the VAPID keys by running:\nTerminalweb-push generate-vapid-keys\nCopy the output and paste the keys into your .env file:\nNEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here\nVAPID_PRIVATE_KEY=your_private_key_here\n5. Creating a Service Worker\n\nCreate a public/sw.js file for your service worker:\npublic/sw.jsself.addEventListener('push', function (event) {\n  if (event.data) {\n    const data = event.data.json()\n    const options = {\n      body: data.body,\n      icon: data.icon || '/icon.png',\n      badge: '/badge.png',\n      vibrate: [100, 50, 100],\n      data: {\n        dateOfArrival: Date.now(),\n        primaryKey: '2',\n      },\n    }\n    event.waitUntil(self.registration.showNotification(data.title, options))\n  }\n})\n\nself.addEventListener('notificationclick', function (event) {\n  console.log('Notification click received.')\n  event.notification.close()\n  event.waitUntil(clients.openWindow('<https://your-website.com>'))\n})\nThis service worker supports custom images and notifications. It handles incoming push events and notification clicks.\n\nYou can set custom icons for notifications using the icon and badge properties.\nThe vibrate pattern can be adjusted to create custom vibration alerts on supported devices.\nAdditional data can be attached to the notification using the data property.\n\nRemember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application.\n6. Adding to Home Screen\n\nThe InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen.\nTo ensure your application can be installed to a mobile home screen, you must have:\n\nA valid web app manifest (created in step 1)\nThe website served over HTTPS\n\nModern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS).\n7. Testing Locally\n\nTo ensure you can view notifications locally, ensure that:\n\nYou are running locally with HTTPS\n\nUse next dev --experimental-https for testing\n\nYour browser (Chrome, Safari, Firefox) has notifications enabled\n\nWhen prompted locally, accept permissions to use notifications\nEnsure notifications are not disabled globally for the entire browser\nIf you are still not seeing notifications, try using another browser to debug\n\n8. Securing your application\n\nSecurity is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example:\nnext.config.jsmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff',\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY',\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'strict-origin-when-cross-origin',\n          },\n        ],\n      },\n      {\n        source: '/sw.js',\n        headers: [\n          {\n            key: 'Content-Type',\n            value: 'application/javascript; charset=utf-8',\n          },\n          {\n            key: 'Cache-Control',\n            value: 'no-cache, no-store, must-revalidate',\n          },\n          {\n            key: 'Content-Security-Policy',\n            value: \"default-src 'self'; script-src 'self'\",\n          },\n        ],\n      },\n    ]\n  },\n}\nLet\u2019s go over each of these options:\n\nGlobal Headers (applied to all routes):\n\nX-Content-Type-Options: nosniff: Prevents MIME type sniffing, reducing the risk of malicious file uploads.\nX-Frame-Options: DENY: Protects against clickjacking attacks by preventing your site from being embedded in iframes.\nReferrer-Policy: strict-origin-when-cross-origin: Controls how much referrer information is included with requests, balancing security and functionality.\n\nService Worker Specific Headers:\n\nContent-Type: application/javascript; charset=utf-8: Ensures the service worker is interpreted correctly as JavaScript.\nCache-Control: no-cache, no-store, must-revalidate: Prevents caching of the service worker, ensuring users always get the latest version.\nContent-Security-Policy: default-src 'self'; script-src 'self': Implements a strict Content Security Policy for the service worker, only allowing scripts from the same origin.\n\nLearn more about defining Content Security Policies with Next.js.\nNext Steps\n\nExploring PWA Capabilities: PWAs can leverage various web APIs to provide advanced functionality. Consider exploring features like background sync, periodic background sync, or the File System Access API to enhance your application. For inspiration and up-to-date information on PWA capabilities, you can refer to resources like What PWA Can Do Today.\nStatic Exports: If your application requires not running a server, and instead using a static export of files, you can update the Next.js configuration to enable this change. Learn more in the Next.js Static Export documentation. However, you will need to move from Server Actions to calling an external API, as well as moving your defined headers to your proxy.\nOffline Support: To provide offline functionality, one option is Serwist with Next.js. You can find an example of how to integrate Serwist with Next.js in their documentation. Note: this plugin currently requires webpack configuration.\nSecurity Considerations: Ensure that your service worker is properly secured. This includes using HTTPS, validating the source of push messages, and implementing proper error handling.\nUser Experience: Consider implementing progressive enhancement techniques to ensure your app works well even when certain PWA features are not supported by the user's browser.\nNext Stepsmanifest.jsonAPI Reference for manifest.json file.PreviousProductionNextRedirectingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/redirecting", "content": "How to handle redirects in Next.jsThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.\nAPIPurposeWhereStatus CoderedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers307 (Temporary) or 303 (Server Action)permanentRedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers308 (Permanent)useRouterPerform a client-side navigationEvent Handlers in Client ComponentsN/Aredirects in next.config.jsRedirect an incoming request based on a pathnext.config.js file307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionMiddlewareAny\n\nredirect function\n\nThe redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.redirect is often used after a mutation or event. For example, creating a post:app/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { redirect } from 'next/navigation'\nimport { revalidatePath } from 'next/cache'\n\nexport async function createPost(id: string) {\n  try {\n    // Call database\n  } catch (error) {\n    // Handle errors\n  }\n\n  revalidatePath('/posts') // Update cached posts\n  redirect(`/post/${id}`) // Navigate to the new post page\n}\nGood to know:\n\nredirect returns a 307 (Temporary Redirect) status code by default. When used in a Server Action, it returns a 303 (See Other), which is commonly used for redirecting to a success page as a result of a POST request.\nredirect internally throws an error so it should be called outside of try/catch blocks.\nredirect can be called in Client Components during the rendering process but not in event handlers. You can use the useRouter hook instead.\nredirect also accepts absolute URLs and can be used to redirect to external links.\nIf you'd like to redirect before the render process, use next.config.js or Middleware.\n\nSee the redirect API reference for more information.permanentRedirect function\n\nThe permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions.permanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:app/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nimport { permanentRedirect } from 'next/navigation'\nimport { revalidateTag } from 'next/cache'\n\nexport async function updateUsername(username: string, formData: FormData) {\n  try {\n    // Call database\n  } catch (error) {\n    // Handle errors\n  }\n\n  revalidateTag('username') // Update all references to the username\n  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile\n}\nGood to know:\n\npermanentRedirect returns a 308 (permanent redirect) status code by default.\npermanentRedirect also accepts absolute URLs and can be used to redirect to external links.\nIf you'd like to redirect before the render process, use next.config.js or Middleware.\n\nSee the permanentRedirect API reference for more information.\nuseRouter() hook\n\nIf you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:app/page.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useRouter } from 'next/navigation'\n\nexport default function Page() {\n  const router = useRouter()\n\n  return (\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\n      Dashboard\n    </button>\n  )\n}\n\nGood to know:\n\nIf you don't need to programmatically navigate a user, you should use a <Link> component.\n\nSee the useRouter API reference for more information.\n\nredirects in next.config.js\n\nThe redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.\nredirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.\nTo use redirects, add the option to your next.config.js file:\nnext.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  async redirects() {\n    return [\n      // Basic redirect\n      {\n        source: '/about',\n        destination: '/',\n        permanent: true,\n      },\n      // Wildcard path matching\n      {\n        source: '/blog/:slug',\n        destination: '/news/:slug',\n        permanent: true,\n      },\n    ]\n  },\n}\n\nexport default nextConfig\n\nSee the redirects API reference for more information.\n\nGood to know:\n\nredirects can return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with the permanent option.\nredirects may have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution using Middleware. See managing redirects at scale for more.\nredirects runs before Middleware.\n\nNextResponse.redirect in Middleware\n\nMiddleware allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects.\nFor example, to redirect the user to a /login page if they are not authenticated:\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server'\nimport { authenticate } from 'auth-provider'\n\nexport function middleware(request: NextRequest) {\n  const isAuthenticated = authenticate(request)\n\n  // If the user is authenticated, continue as normal\n  if (isAuthenticated) {\n    return NextResponse.next()\n  }\n\n  // Redirect to login page if not authenticated\n  return NextResponse.redirect(new URL('/login', request.url))\n}\n\nexport const config = {\n  matcher: '/dashboard/:path*',\n}\n\nGood to know:\n\nMiddleware runs after redirects in next.config.js and before rendering.\n\nSee the Middleware documentation for more information.\nManaging redirects at scale (advanced)\n\nTo manage a large number of redirects (1000+), you may consider creating a custom solution using Middleware. This allows you to handle redirects programmatically without having to redeploy your application.\nTo do this, you'll need to consider:\n\nCreating and storing a redirect map.\nOptimizing data lookup performance.\n\nNext.js Example: See our Middleware with Bloom filter example for an implementation of the recommendations below.\n\n1. Creating and storing a redirect map\n\nA redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.\nConsider the following data structure:\n{\n  \"/old\": {\n    \"destination\": \"/new\",\n    \"permanent\": true\n  },\n  \"/blog/post-old\": {\n    \"destination\": \"/blog/post-new\",\n    \"permanent\": true\n  }\n}\nIn Middleware, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request:\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server'\nimport { get } from '@vercel/edge-config'\n\ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname\n  const redirectData = await get(pathname)\n\n  if (redirectData && typeof redirectData === 'string') {\n    const redirectEntry: RedirectEntry = JSON.parse(redirectData)\n    const statusCode = redirectEntry.permanent ? 308 : 307\n    return NextResponse.redirect(redirectEntry.destination, statusCode)\n  }\n\n  // No redirect found, continue without redirecting\n  return NextResponse.next()\n}\n\n2. Optimizing data lookup performance\n\nReading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:\n\nUse a database that is optimized for fast reads\nUse a data lookup strategy such as a Bloom filter to efficiently check if a redirect exists before reading the larger redirects file or database.\n\nConsidering the previous example, you can import a generated bloom filter file into Middleware, then, check if the incoming request pathname exists in the bloom filter.\nIf it does, forward the request to a Route Handler  which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Middleware, which can slow down every incoming request.\nmiddleware.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server'\nimport { ScalableBloomFilter } from 'bloom-filters'\nimport GeneratedBloomFilter from './redirects/bloom-filter.json'\n\ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n\n// Initialize bloom filter from a generated JSON file\nconst bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any)\n\nexport async function middleware(request: NextRequest) {\n  // Get the path for the incoming request\n  const pathname = request.nextUrl.pathname\n\n  // Check if the path is in the bloom filter\n  if (bloomFilter.has(pathname)) {\n    // Forward the pathname to the Route Handler\n    const api = new URL(\n      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,\n      request.nextUrl.origin\n    )\n\n    try {\n      // Fetch redirect data from the Route Handler\n      const redirectData = await fetch(api)\n\n      if (redirectData.ok) {\n        const redirectEntry: RedirectEntry | undefined =\n          await redirectData.json()\n\n        if (redirectEntry) {\n          // Determine the status code\n          const statusCode = redirectEntry.permanent ? 308 : 307\n\n          // Redirect to the destination\n          return NextResponse.redirect(redirectEntry.destination, statusCode)\n        }\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n\n  // No redirect found, continue the request without redirecting\n  return NextResponse.next()\n}\n\nThen, in the Route Handler:app/api/redirects/route.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server'\nimport redirects from '@/app/redirects/redirects.json'\n\ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n\nexport function GET(request: NextRequest) {\n  const pathname = request.nextUrl.searchParams.get('pathname')\n  if (!pathname) {\n    return new Response('Bad Request', { status: 400 })\n  }\n\n  // Get the redirect entry from the redirects.json file\n  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]\n\n  // Account for bloom filter false positives\n  if (!redirect) {\n    return new Response('No redirect', { status: 400 })\n  }\n\n  // Return the redirect entry\n  return NextResponse.json(redirect)\n}\n\nGood to know:\n\nTo generate a bloom filter, you can use a library like bloom-filters.\nYou should validate requests made to your Route Handler to prevent malicious requests.\n\nNext StepsredirectAPI Reference for the redirect function.permanentRedirectAPI Reference for the permanentRedirect function.middleware.jsAPI reference for the middleware.js file.redirectsAdd redirects to your Next.js app.PreviousPWAsNextSassWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/sass", "content": "use Sass\nNext.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can use component-level Sass via CSS Modules and the .module.scssor .module.sass extension.\nFirst, install sass:\nTerminalnpm install --save-dev sass\n\nGood to know:\nSass supports two different syntaxes, each with their own extension.\nThe .scss extension requires you use the SCSS syntax,\nwhile the .sass extension requires you use the Indented Syntax (\"Sass\").\nIf you're not sure which to choose, start with the .scss extension which is a superset of CSS, and doesn't require you learn the\nIndented Syntax (\"Sass\").\n\nCustomizing Sass Options\n\nIf you want to configure your Sass options, use sassOptions in next.config.\nnext.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  sassOptions: {\n    additionalData: `$var: red;`,\n  },\n}\n\nexport default nextConfig\n\nImplementation\n\nYou can use the implementation property to specify the Sass implementation to use. By default, Next.js uses the sass package.\nnext.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  sassOptions: {\n    implementation: 'sass-embedded',\n  },\n}\n\nexport default nextConfig\n\nSass Variables\n\nNext.js supports Sass variables exported from CSS Module files.\nFor example, using the exported primaryColor Sass variable:\napp/variables.module.scss$primary-color: #64ff00;\n\n:export {\n  primaryColor: $primary-color;\n}\napp/page.js// maps to root `/` URL\n\nimport variables from './variables.module.scss'\n\nexport default function Page() {\n  return <h1 style={{ color: variables.primaryColor }}>Hello, Next.js!</h1>\n}\nPreviousRedirectingNextScriptsWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/scripts", "content": "to load and optimize scripts\nLayout Scripts\n\nTo load a third-party script for multiple routes, import next/script and include the script directly in your layout component:app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport Script from 'next/script'\n\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <>\n      <section>{children}</section>\n      <Script src=\"https://example.com/script.js\" />\n    </>\n  )\n}The third-party script is fetched when the folder route (e.g. dashboard/page.js) or any nested route (e.g. dashboard/settings/page.js) is accessed by the user. Next.js will ensure the script will only load once, even if a user navigates between multiple routes in the same layout.\nApplication Scripts\n\nTo load a third-party script for all routes, import next/script and include the script directly in your root layout:app/layout.tsxTypeScriptJavaScriptTypeScriptimport Script from 'next/script'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n      <Script src=\"https://example.com/script.js\" />\n    </html>\n  )\n}\n\nThis script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even if a user navigates between multiple pages.\n\nRecommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance.\n\nStrategy\n\nAlthough the default behavior of next/script allows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using the strategy property:\n\nbeforeInteractive: Load the script before any Next.js code and before any page hydration occurs.\nafterInteractive: (default) Load the script early but after some hydration on the page occurs.\nlazyOnload: Load the script later during browser idle time.\nworker: (experimental) Load the script in a web worker.\n\nRefer to the next/script API reference documentation to learn more about each strategy and their use cases.\nOffloading Scripts To A Web Worker (experimental)\n\nWarning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.\n\nScripts that use the worker strategy are offloaded and executed in a web worker with Partytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code.\nThis strategy is still experimental and can only be used if the nextScriptWorkers flag is enabled in next.config.js:\nnext.config.jsmodule.exports = {\n  experimental: {\n    nextScriptWorkers: true,\n  },\n}\nThen, run next (normally npm run dev or yarn dev) and Next.js will guide you through the installation of the required packages to finish the setup:\nTerminalnpm run dev\nYou'll see instructions like these: Please install Partytown by running npm install @builder.io/partytown\nOnce setup is complete, defining strategy=\"worker\" will automatically instantiate Partytown in your application and offload the script to a web worker.\npages/home.tsxTypeScriptJavaScriptTypeScriptimport Script from 'next/script'\n\nexport default function Home() {\n  return (\n    <>\n      <Script src=\"https://example.com/script.js\" strategy=\"worker\" />\n    </>\n  )\n}\n\nThere are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown's tradeoffs documentation for more information.\n\nInline Scripts\n\nInline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:\n<Script id=\"show-banner\">\n  {`document.getElementById('banner').classList.remove('hidden')`}\n</Script>\nOr by using the dangerouslySetInnerHTML property:\n<Script\n  id=\"show-banner\"\n  dangerouslySetInnerHTML={{\n    __html: `document.getElementById('banner').classList.remove('hidden')`,\n  }}\n/>\n\nWarning: An id property must be assigned for inline scripts in order for Next.js to track and optimize the script.\n\nExecuting Additional Code\n\nEvent handlers can be used with the Script component to execute additional code after a certain event occurs:\n\nonLoad: Execute code after the script has finished loading.\nonReady: Execute code after the script has finished loading and every time the component is mounted.\nonError: Execute code if the script fails to load.\n\nThese handlers will only work when next/script is imported and used inside of a Client Component where \"use client\" is defined as the first line of code:app/page.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport Script from 'next/script'\n\nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        onLoad={() => {\n          console.log('Script has loaded')\n        }}\n      />\n    </>\n  )\n}Refer to the next/script API reference to learn more about each event handler and view examples.\n\nAdditional Attributes\n\nThere are many DOM attributes that can be assigned to a <script> element that are not used by the Script component, like nonce or custom data attributes. Including any additional attributes will automatically forward it to the final, optimized <script> element that is included in the HTML.\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Script from 'next/script'\n\nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        id=\"example-script\"\n        nonce=\"XUENAJFW\"\n        data-test=\"script\"\n      />\n    </>\n  )\n}\nAPI ReferenceLearn more about the next/script API.Script ComponentOptimize third-party scripts in your Next.js application using the built-in `next/script` Component.PreviousSassNextSelf-HostingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/self-hosting", "content": "gHow to self-host your Next.js application\nWhen deploying your Next.js app, you may want to configure how different features are handled based on your infrastructure.\n\n\ud83c\udfa5 Watch: Learn more about self-hosting Next.js \u2192 YouTube (45 minutes).\n\nImage Optimization\n\nImage Optimization through next/image works self-hosted with zero configuration when deploying using next start. If you would prefer to have a separate service to optimize images, you can configure an image loader.\nImage Optimization can be used with a static export by defining a custom image loader in next.config.js. Note that images are optimized at runtime, not during the build.\n\nGood to know:\n\nOn glibc-based Linux systems, Image Optimization may require additional configuration to prevent excessive memory usage.\nLearn more about the caching behavior of optimized images and how to configure the TTL.\nYou can also disable Image Optimization and still retain other benefits of using next/image if you prefer. For example, if you are optimizing images yourself separately.\n\nMiddleware\n\nMiddleware works self-hosted with zero configuration when deploying using next start. Since it requires access to the incoming request, it is not supported when using a static export.\nMiddleware uses the Edge runtime, a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. If you do not want this, you can use the full Node.js runtime to run Middleware.\nIf you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to a layout as a Server Component. For example, checking headers and redirecting. You can also use headers, cookies, or query parameters to redirect or rewrite through next.config.js. If that does not work, you can also use a custom server.\nEnvironment Variables\n\nNext.js can support both build time and runtime environment variables.\nBy default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.\n\nYou safely read environment variables on the server during dynamic rendering.app/page.tsTypeScriptJavaScriptTypeScriptimport { connection } from 'next/server'\n\nexport default async function Component() {\n  await connection()\n  // cookies, headers, and other Dynamic APIs\n  // will also opt into dynamic rendering, meaning\n  // this env variable is evaluated at runtime\n  const value = process.env.MY_VALUE\n  // ...\n}\nThis allows you to use a singular Docker image that can be promoted through multiple environments with different values.\n\nGood to know:\n\nYou can run code on server startup using the register function.\nWe do not recommend using the runtimeConfig option, as this does not work with the standalone output mode. Instead, we recommend incrementally adopting the App Router.\n\nCaching and ISR\n\nNext.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts.\nCaching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.\nYou can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.\nAutomatic Caching\n\nNext.js sets the Cache-Control header of public, max-age=31536000, immutable to truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static Image Imports. You can configure the TTL for images.\nIncremental Static Regeneration (ISR) sets the Cache-Control header of s-maxage: <revalidate in getStaticProps>, stale-while-revalidate. This revalidation time is defined in your getStaticProps function in seconds. If you set revalidate: false, it will default to a one-year cache duration.\nDynamically rendered pages set a Cache-Control header of private, no-cache, no-store, max-age=0, must-revalidate to prevent user-specific data from being cached. This applies to both the App Router and Pages Router. This also includes Draft Mode.\n\nStatic Assets\n\nIf you want to host static assets on a different domain or CDN, you can use the assetPrefix configuration in next.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution.\nLearn more about assetPrefix.\nConfiguring Caching\n\nBy default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.\nTo configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in your next.config.js file:\nnext.config.jsmodule.exports = {\n  cacheHandler: require.resolve('./cache-handler.js'),\n  cacheMaxMemorySize: 0, // disable default in-memory caching\n}\nThen, create cache-handler.js in the root of your project, for example:\ncache-handler.jsconst cache = new Map()\n\nmodule.exports = class CacheHandler {\n  constructor(options) {\n    this.options = options\n  }\n\n  async get(key) {\n    // This could be stored anywhere, like durable storage\n    return cache.get(key)\n  }\n\n  async set(key, data, ctx) {\n    // This could be stored anywhere, like durable storage\n    cache.set(key, {\n      value: data,\n      lastModified: Date.now(),\n      tags: ctx.tags,\n    })\n  }\n\n  async revalidateTag(tags) {\n    // tags is either a string or an array of strings\n    tags = [tags].flat()\n    // Iterate over all entries in the cache\n    for (let [key, value] of cache) {\n      // If the value's tags include the specified tag, delete this entry\n      if (value.tags.some((tag) => tags.includes(tag))) {\n        cache.delete(key)\n      }\n    }\n  }\n\n  // If you want to have temporary in memory cache for a single request that is reset\n  // before the next request you can leverage this method\n  resetRequestCache() {}\n}\nUsing a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, like Redis or AWS S3.\n\nGood to know:\n\nrevalidatePath is a convenience layer on top of cache tags. Calling revalidatePath will call the revalidateTag function with a special default tag for the provided page.\n\nBuild Cache\n\nNext.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers.\nIf you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:\nnext.config.jsmodule.exports = {\n  generateBuildId: async () => {\n    // This could be anything, using the latest git hash\n    return process.env.GIT_HASH\n  },\n}\nVersion Skew\n\nNext.js will automatically mitigate most instances of version skew and automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in the deploymentId, transitions between pages will perform a hard navigation versus using a prefetched value.\nWhen the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state like useState would be lost in such navigations.\nStreaming and Suspense\n\nThe Next.js App Router supports streaming responses when self-hosting. If you are using Nginx or a similar proxy, you will need to configure it to disable buffering to enable streaming.For example, you can disable buffering in Nginx by setting X-Accel-Buffering to no:next.config.jsmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/:path*{/}?',\n        headers: [\n          {\n            key: 'X-Accel-Buffering',\n            value: 'no',\n          },\n        ],\n      },\n    ]\n  },\n}Partial Prerendering\n\nPartial Prerendering (experimental) works by default with Next.js and is not a CDN-only feature. This includes deployment as a Node.js server (through next start) and when used with a Docker container.Usage with CDNs\n\nWhen using a CDN in front on your Next.js application, the page will include Cache-Control: private response header when dynamic APIs are accessed. This ensures that the resulting HTML page is marked as non-cachable. If the page is fully prerendered to static, it will include Cache-Control: public to allow the page to be cached on the CDN.If you don't need a mix of both static and dynamic components, you can make your entire route static and cache the output HTML on a CDN. This Automatic Static Optimization is the default behavior when running next build if dynamic APIs are not used.As Partial Prerendering moves to stable, we will provide support through the Deployment Adapters API.\nafter\n\nafter is fully supported when self-hosting with next start.When stopping the server, ensure a graceful shutdown by sending SIGINT or SIGTERM signals and waiting. This allows the Next.js server to wait until after pending callback functions or promises used inside after have finished.\nPreviousScriptsNextSPAsWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/single-page-applications", "content": "build single-page applications with Next.jsNext.js fully supports building Single-Page Applications (SPAs).\nThis includes fast route transitions with prefetching, client-side data fetching, using browser APIs, integrating with third-party client libraries, creating static routes, and more.\nIf you have an existing SPA, you can migrate to Next.js without large changes to your code. Next.js then allows you to progressively add server features as needed.\nWhat is a Single-Page Application?\n\nThe definition of a SPA varies. We\u2019ll define a \u201cstrict SPA\u201d as:\n\nClient-side rendering (CSR): The app is served by one HTML file (e.g. index.html). Every route, page transition, and data fetch is handled by JavaScript in the browser.\nNo full-page reloads: Rather than requesting a new document for each route, client-side JavaScript manipulates the current page\u2019s DOM and fetches data as needed.\n\nStrict SPAs often require large amounts of JavaScript to load before the page can be interactive. Further, client data waterfalls can be challenging to manage. Building SPAs with Next.js can address these issues.\nWhy use Next.js for SPAs?\n\nNext.js can automatically code split your JavaScript bundles, and generate multiple HTML entry points into different routes. This avoids loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.\nThe next/link component automatically prefetches routes, giving you the fast page transitions of a strict SPA, but with the advantage of persisting application routing state to the URL for linking and sharing.\nNext.js can start as a static site or even a strict SPA where everything is rendered client-side. If your project grows, Next.js allows you to progressively add more server features (e.g. React Server Components, Server Actions, and more) as needed.\nExamples\n\nLet's explore common patterns used to build SPAs and how Next.js solves them.\nUsing React\u2019s use within a Context Provider\n\nWe recommend fetching data in a parent component (or layout), returning the Promise, and then unwrapping the value in a Client Component with React\u2019s use hook.\nNext.js can start data fetching early on the server. In this example, that\u2019s the root layout \u2014 the entry point to your application. The server can immediately begin streaming a response to the client.\nBy \u201choisting\u201d your data fetching to the root layout, Next.js starts the specified requests on the server early before any other components in your application. This eliminates client waterfalls and prevents having multiple roundtrips between client and server. It can also significantly improve performance, as your server is closer (and ideally colocated) to where your database is located.\nFor example, update your root layout to call the Promise, but do not await it.\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport { UserProvider } from './user-provider'\nimport { getUser } from './user' // some server-side function\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  let userPromise = getUser() // do NOT await\n\n  return (\n    <html lang=\"en\">\n      <body>\n        <UserProvider userPromise={userPromise}>{children}</UserProvider>\n      </body>\n    </html>\n  )\n}\n\nWhile you can defer and pass a single Promise as a prop to a Client Component, we generally see this pattern paired with a React context provider. This enables easier access from Client Components with a custom React Hook.\nYou can forward a Promise to the React context provider:\napp/user-provider.tsTypeScriptJavaScriptTypeScript'use client';\n\nimport { createContext, useContext, ReactNode } from 'react';\n\ntype User = any;\ntype UserContextType = {\n  userPromise: Promise<User | null>;\n};\n\nconst UserContext = createContext<UserContextType | null>(null);\n\nexport function useUser(): UserContextType {\n  let context = useContext(UserContext);\n  if (context === null) {\n    throw new Error('useUser must be used within a UserProvider');\n  }\n  return context;\n}\n\nexport function UserProvider({\n  children,\n  userPromise\n}: {\n  children: ReactNode;\n  userPromise: Promise<User | null>;\n}) {\n  return (\n    <UserContext.Provider value={{ userPromise }}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nFinally, you can call the useUser() custom hook in any Client Component and unwrap the Promise:\napp/profile.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { use } from 'react'\nimport { useUser } from './user-provider'\n\nexport function Profile() {\n  const { userPromise } = useUser()\n  const user = use(userPromise)\n\n  return '...'\n}\n\nThe component that consumes the Promise (e.g. Profile above) will be suspended. This enables partial hydration. You can see the streamed and prerendered HTML before JavaScript has finished loading.\nSPAs with SWR\n\nSWR is a popular React library for data fetching.\nWith SWR 2.3.0 (and React 19+), you can gradually adopt server features alongside your existing SWR-based client data fetching code. This is an abstraction of the above use() pattern. This means you can move data fetching between the client and server-side, or use both:\n\nClient-only: useSWR(key, fetcher)\nServer-only: useSWR(key) + RSC-provided data\nMixed: useSWR(key, fetcher) + RSC-provided data\n\nFor example, wrap your application with <SWRConfig> and a fallback:\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport { SWRConfig } from 'swr'\nimport { getUser } from './user' // some server-side function\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <SWRConfig\n      value={{\n        fallback: {\n          // We do NOT await getUser() here\n          // Only components that read this data will suspend\n          '/api/user': getUser(),\n        },\n      }}\n    >\n      {children}\n    </SWRConfig>\n  )\n}\n\nBecause this is a Server Component, getUser() can securely read cookies, headers, or talk to your database. No separate API route is needed. Client components below the <SWRConfig> can call useSWR() with the same key to retrieve the user data. The component code with useSWR does not require any changes from your existing client-fetching solution.\napp/profile.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport useSWR from 'swr'\n\nexport function Profile() {\n  const fetcher = (url) => fetch(url).then((res) => res.json())\n  // The same SWR pattern you already know\n  const { data, error } = useSWR('/api/user', fetcher)\n\n  return '...'\n}\n\nThe fallback data can be prerendered and included in the initial HTML response, then immediately read in the child components using useSWR. SWR\u2019s polling, revalidation, and caching still run client-side only, so it preserves all the interactivity you rely on for an SPA.\nSince the initial fallback data is automatically handled by Next.js, you can now delete any conditional logic previously needed to check if data was undefined. When the data is loading, the closest <Suspense> boundary will be suspended.\nSWRRSCRSC + SWRSSR dataStreaming while SSRDeduplicate requestsClient-side features\nSPAs with React Query\n\nYou can use React Query with Next.js on both the client and server. This enables you to build both strict SPAs, as well as take advantage of server features in Next.js paired with React Query.\nLearn more in the React Query documentation.\nRendering components only in the browser\n\nClient components are prerendered during next build. If you want to disable prerendering for a Client Component and only load it in the browser environment, you can use next/dynamic:\nimport dynamic from 'next/dynamic'\n\nconst ClientOnlyComponent = dynamic(() => import('./component'), {\n  ssr: false,\n})\nThis can be useful for third-party libraries that rely on browser APIs like window or document. You can also add a useEffect that checks for the existence of these APIs, and if they do not exist, return null or a loading state which would be prerendered.\nShallow routing on the client\n\nIf you are migrating from a strict SPA like Create React App or Vite, you might have existing code which shallow routes to update the URL state. This can be useful for manual transitions between views in your application without using the default Next.js file-system routing.\nNext.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page.\npushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams.\n'use client'\n\nimport { useSearchParams } from 'next/navigation'\n\nexport default function SortProducts() {\n  const searchParams = useSearchParams()\n\n  function updateSorting(sortOrder: string) {\n    const urlSearchParams = new URLSearchParams(searchParams.toString())\n    urlSearchParams.set('sort', sortOrder)\n    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)\n  }\n\n  return (\n    <>\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\n    </>\n  )\n}\n\nLearn more about how routing and navigation work in Next.js.\nUsing Server Actions in Client Components\n\nYou can progressively adopt Server Actions while still using Client Components. This allows you to remove boilerplate code to call an API route, and instead use React features like useActionState to handle loading and error states.\nFor example, create your first Server Action:\napp/actions.tsTypeScriptJavaScriptTypeScript'use server'\n\nexport async function create() {}\n\nYou can import and use a Server Action from the client, similar to calling a JavaScript function. You do not need to create an API endpoint manually:\napp/button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { create } from './actions'\n\nexport function Button() {\n  return <button onClick={() => create()}>Create</button>\n}\n\nLearn more about mutating data with Server Actions.\nStatic export (optional)\n\nNext.js also supports generating a fully static site. This has some advantages over strict SPAs:\n\nAutomatic code-splitting: Instead of shipping a single index.html, Next.js will generate an HTML file per route, so your visitors get the content faster without waiting for the client JavaScript bundle.\nImproved user experience: Instead of a minimal skeleton for all routes, you get fully rendered pages for each route. When users navigate client side, transitions remain instant and SPA-like.\n\nTo enable a static export, update your configuration:\nnext.config.tsimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  output: 'export',\n}\n\nexport default nextConfig\nAfter running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.\n\nNote: Next.js server features are not supported with static exports. Learn more.\n\nMigrating existing projects to Next.js\n\nYou can incrementally migrate to Next.js by following our guides:\n\nMigrating from Create React App\nMigrating from Vite\n\nIf you are already using a SPA with the Pages Router, you can learn how to incrementally adopt the App Router.PreviousSelf-HostingNextStatic ExportsWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/static-exports", "content": "rtsHow to create a static export of your Next.js application\nNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.\nWhen running next build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.\nSince Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.\nConfiguration\n\nTo enable a static export, change the output mode inside next.config.js:\nnext.config.js/**\n * @type {import('next').NextConfig}\n */\nconst nextConfig = {\n  output: 'export',\n\n  // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`\n  // trailingSlash: true,\n\n  // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`\n  // skipTrailingSlashRedirect: true,\n\n  // Optional: Change the output directory `out` -> `dist`\n  // distDir: 'dist',\n}\n\nmodule.exports = nextConfig\nAfter running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.\n\nSupported Features\n\nThe core of Next.js has been designed to support static exports.Server Components\n\nWhen you run next build to generate a static export, Server Components consumed inside the app directory will run during the build, similar to traditional static-site generation.The resulting component will be rendered into static HTML for the initial page load and a static payload for client navigation between routes. No changes are required for your Server Components when using the static export, unless they consume dynamic server functions.app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() {\n  // This fetch will run on the server during `next build`\n  const res = await fetch('https://api.example.com/...')\n  const data = await res.json()\n\n  return <main>...</main>\n}Client Components\n\nIf you want to perform data fetching on the client, you can use a Client Component with SWR to memoize requests.app/other/page.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport useSWR from 'swr'\n\nconst fetcher = (url: string) => fetch(url).then((r) => r.json())\n\nexport default function Page() {\n  const { data, error } = useSWR(\n    `https://jsonplaceholder.typicode.com/posts/1`,\n    fetcher\n  )\n  if (error) return 'Failed to load'\n  if (!data) return 'Loading...'\n\n  return data.title\n}Since route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to navigate to different posts on the client:app/page.tsxTypeScriptJavaScriptTypeScriptimport Link from 'next/link'\n\nexport default function Page() {\n  return (\n    <>\n      <h1>Index Page</h1>\n      <hr />\n      <ul>\n        <li>\n          <Link href=\"/post/1\">Post 1</Link>\n        </li>\n        <li>\n          <Link href=\"/post/2\">Post 2</Link>\n        </li>\n      </ul>\n    </>\n  )\n}\n\nImage Optimization\n\nImage Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js. For example, you can optimize images with a service like Cloudinary:\nnext.config.js/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',\n  images: {\n    loader: 'custom',\n    loaderFile: './my-loader.ts',\n  },\n}\n\nmodule.exports = nextConfig\nThis custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary:\nmy-loader.tsTypeScriptJavaScriptTypeScriptexport default function cloudinaryLoader({\n  src,\n  width,\n  quality,\n}: {\n  src: string\n  width: number\n  quality?: number\n}) {\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\n  return `https://res.cloudinary.com/demo/image/upload/${params.join(\n    ','\n  )}${src}`\n}\n\nYou can then use next/image in your application, defining relative paths to the image in Cloudinary:\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Image from 'next/image'\n\nexport default function Page() {\n  return <Image alt=\"turtles\" src=\"/turtles.jpg\" width={300} height={300} />\n}\n\nRoute Handlers\n\nRoute Handlers will render a static response when running next build. Only the GET HTTP verb is supported. This can be used to generate static HTML, JSON, TXT, or other files from cached or uncached data. For example:app/data.json/route.tsTypeScriptJavaScriptTypeScriptexport async function GET() {\n  return Response.json({ name: 'Lee' })\n}The above file app/data.json/route.ts will render to a static file during next build, producing data.json containing { name: 'Lee' }.If you need to read dynamic values from the incoming request, you cannot use a static export.Browser APIs\n\nClient Components are pre-rendered to HTML during next build. Because Web APIs like window, localStorage, and navigator are not available on the server, you need to safely access these APIs only when running in the browser. For example:'use client';\n\nimport { useEffect } from 'react';\n\nexport default function ClientComponent() {\n  useEffect(() => {\n    // You now have access to `window`\n    console.log(window.innerHeight);\n  }, [])\n\n  return ...;\n}\nUnsupported Features\n\nFeatures that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported:\n\nDynamic Routes with dynamicParams: true\nDynamic Routes without generateStaticParams()\nRoute Handlers that rely on Request\nCookies\nRewrites\nRedirects\nHeaders\nMiddleware\nIncremental Static Regeneration\nImage Optimization with the default loader\nDraft Mode\nServer Actions\nIntercepting Routes\nAttempting to use any of these features with next dev will result in an error, similar to setting the dynamic option to error in the root layout.export const dynamic = 'error'\n\nDeploying\n\nWith a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.\nWhen running next build, Next.js generates the static export into the out folder. For example, let's say you have the following routes:\n\n/\n/blog/[id]\n\nAfter running next build, Next.js will generate the following files:\n\n/out/index.html\n/out/404.html\n/out/blog/post-1.html\n/out/blog/post-2.html\n\nIf you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:\nnginx.confserver {\n  listen 80;\n  server_name acme.com;\n\n  root /var/www/out;\n\n  location / {\n      try_files $uri $uri.html $uri/ =404;\n  }\n\n  # This is necessary when `trailingSlash: false`.\n  # You can omit this when `trailingSlash: true`.\n  location /blog/ {\n      rewrite ^/blog/(.*)$ /blog/$1.html break;\n  }\n\n  error_page 404 /404.html;\n  location = /404.html {\n      internal;\n  }\n}\nVersion History\n\nVersionChangesv14.0.0next export has been removed in favor of \"output\": \"export\"v13.4.0App Router (Stable) adds enhanced static export support, including using React Server Components and Route Handlers.v13.3.0next export is deprecated and replaced with \"output\": \"export\"PreviousSPAsNextTailwind CSSWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/tailwind-css", "content": "SHow to install Tailwind CSS in your Next.js application\nTailwind CSS is a utility-first CSS framework that is fully compatible with Next.js. This guide will walk you through how to install Tailwind CSS in your Next.js application.\nInstalling Tailwind\n\nInstall the necessary Tailwind CSS packages:\nTerminalnpm install -D tailwindcss @tailwindcss/postcss postcss\n\nGood to know: If you're using the create-next-app CLI to create your project, Next.js will prompt if you'd like to install Tailwind and automatically configure the project.\n\nConfiguring Tailwind\n\nCreate a postcss.config.mjs file in the root of your project and add the @tailwindcss/postcss plugin to your PostCSS configuration:\npostcss.config.mjs/** @type {import('tailwindcss').Config} */\nexport default {\n  plugins: {\n    '@tailwindcss/postcss': {},\n  },\n}\nAs of Tailwind v4, there is zero configuration required by default. If you do need to configure Tailwind, you can follow the official documentation for configuring the global CSS file.\nThere is also an upgrade CLI and guide if you have an existing Tailwind v3 project.\nImporting Styles\n\nAdd the Tailwind CSS directives that Tailwind will use to inject its generated styles to a Global Stylesheet in your application, for example:app/globals.css@import 'tailwindcss';Inside the root layout (app/layout.tsx), import the globals.css stylesheet to apply the styles to every route in your application.app/layout.tsxTypeScriptJavaScriptTypeScriptimport type { Metadata } from 'next'\n\n// These styles apply to every route in the application\nimport './globals.css'\n\nexport const metadata: Metadata = {\n  title: 'Create Next App',\n  description: 'Generated by create next app',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}Using Classes\n\nAfter installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application.app/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() {\n  return <h1 className=\"text-3xl font-bold underline\">Hello, Next.js!</h1>\n}\n\nUsage with Turbopack\n\nAs of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.PreviousStatic ExportsNextTestingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/guides/third-party-libraries", "content": "LibrariesHow to optimize third-party libraries\n@next/third-parties is a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application.\nAll third-party integrations provided by @next/third-parties have been optimized for performance and ease of use.\nGetting Started\n\nTo get started, install the @next/third-parties library:\nTerminalnpm install @next/third-parties@latest next@latest\n\n@next/third-parties is currently an experimental library under active development. We recommend installing it with the latest or canary flags while we work on adding more third-party integrations.\nGoogle Third-Parties\n\nAll supported third-party libraries from Google can be imported from @next/third-parties/google.\nGoogle Tag Manager\n\nThe GoogleTagManager component can be used to instantiate a Google Tag Manager container to your page. By default, it fetches the original inline script after hydration occurs on the page.\nTo load Google Tag Manager for all routes, include the component directly in your root layout and pass in your GTM container ID:app/layout.tsxTypeScriptJavaScriptTypeScriptimport { GoogleTagManager } from '@next/third-parties/google'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <GoogleTagManager gtmId=\"GTM-XYZ\" />\n      <body>{children}</body>\n    </html>\n  )\n}\n\nTo load Google Tag Manager for a single route, include the component in your page file:\napp/page.jsimport { GoogleTagManager } from '@next/third-parties/google'\n\nexport default function Page() {\n  return <GoogleTagManager gtmId=\"GTM-XYZ\" />\n}\n\nSending Events\n\nThe sendGTMEvent function can be used to track user interactions on your page by sending events\nusing the dataLayer object. For this function to work, the <GoogleTagManager /> component must be\nincluded in either a parent layout, page, or component, or directly in the same file.\napp/page.js'use client'\n\nimport { sendGTMEvent } from '@next/third-parties/google'\n\nexport function EventButton() {\n  return (\n    <div>\n      <button\n        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}\n      >\n        Send Event\n      </button>\n    </div>\n  )\n}\n\nRefer to the Tag Manager developer\ndocumentation to learn about the\ndifferent variables and events that can be passed into the function.\nServer-side Tagging\n\nIf you're using a server-side tag manager and serving gtm.js scripts from your tagging server you can\nuse gtmScriptUrl option to specify the URL of the script.\nOptions\n\nOptions to pass to the Google Tag Manager. For a full list of options, read the Google Tag Manager\ndocs.\nNameTypeDescriptiongtmIdRequiredYour GTM container ID. Usually starts with GTM-.gtmScriptUrlOptionalGTM script URL. Defaults to https://www.googletagmanager.com/gtm.js.dataLayerOptionalData layer object to instantiate the container with.dataLayerNameOptionalName of the data layer. Defaults to dataLayer.authOptionalValue of authentication parameter (gtm_auth) for environment snippets.previewOptionalValue of preview parameter (gtm_preview) for environment snippets.\nGoogle Analytics\n\nThe GoogleAnalytics component can be used to include Google Analytics\n4 to your page via the Google tag\n(gtag.js). By default, it fetches the original scripts after hydration occurs on the page.\n\nRecommendation: If Google Tag Manager is already included in your application, you can\nconfigure Google Analytics directly using it, rather than including Google Analytics as a separate\ncomponent. Refer to the\ndocumentation\nto learn more about the differences between Tag Manager and gtag.js.\n\nTo load Google Analytics for all routes, include the component directly in your root layout and pass\nin your measurement ID:app/layout.tsxTypeScriptJavaScriptTypeScriptimport { GoogleAnalytics } from '@next/third-parties/google'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n      <GoogleAnalytics gaId=\"G-XYZ\" />\n    </html>\n  )\n}\n\nTo load Google Analytics for a single route, include the component in your page file:\napp/page.jsimport { GoogleAnalytics } from '@next/third-parties/google'\n\nexport default function Page() {\n  return <GoogleAnalytics gaId=\"G-XYZ\" />\n}\n\nSending Events\n\nThe sendGAEvent function can be used to measure user interactions on your page by sending events\nusing the dataLayer object. For this function to work, the <GoogleAnalytics /> component must be\nincluded in either a parent layout, page, or component, or directly in the same file.\napp/page.js'use client'\n\nimport { sendGAEvent } from '@next/third-parties/google'\n\nexport function EventButton() {\n  return (\n    <div>\n      <button\n        onClick={() => sendGAEvent('event', 'buttonClicked', { value: 'xyz' })}\n      >\n        Send Event\n      </button>\n    </div>\n  )\n}\n\nRefer to the Google Analytics developer\ndocumentation to learn\nmore about event parameters.\nTracking Pageviews\n\nGoogle Analytics automatically tracks pageviews when the browser history state changes. This means\nthat client-side navigations between Next.js routes will send pageview data without any configuration.\nTo ensure that client-side navigations are being measured correctly, verify that the \u201cEnhanced\nMeasurement\u201d property is\nenabled in your Admin panel and the \u201cPage changes based on browser history events\u201d checkbox is\nselected.\n\nNote: If you decide to manually send pageview events, make sure to disable the default\npageview measurement to avoid having duplicate data. Refer to the Google Analytics developer\ndocumentation\nto learn more.\n\nOptions\n\nOptions to pass to the <GoogleAnalytics> component.\nNameTypeDescriptiongaIdRequiredYour measurement ID. Usually starts with G-.dataLayerNameOptionalName of the data layer. Defaults to dataLayer.nonceOptionalA nonce.\nGoogle Maps Embed\n\nThe GoogleMapsEmbed component can be used to add a Google Maps\nEmbed to your page. By\ndefault, it uses the loading attribute to lazy-load the embed below the fold.\napp/page.jsimport { GoogleMapsEmbed } from '@next/third-parties/google'\n\nexport default function Page() {\n  return (\n    <GoogleMapsEmbed\n      apiKey=\"XYZ\"\n      height={200}\n      width=\"100%\"\n      mode=\"place\"\n      q=\"Brooklyn+Bridge,New+York,NY\"\n    />\n  )\n}\n\nOptions\n\nOptions to pass to the Google Maps Embed. For a full list of options, read the Google Map Embed\ndocs.\nNameTypeDescriptionapiKeyRequiredYour api key.modeRequiredMap modeheightOptionalHeight of the embed. Defaults to auto.widthOptionalWidth of the embed. Defaults to auto.styleOptionalPass styles to the iframe.allowfullscreenOptionalProperty to allow certain map parts to go full screen.loadingOptionalDefaults to lazy. Consider changing if you know your embed will be above the fold.qOptionalDefines map marker location. This may be required depending on the map mode.centerOptionalDefines the center of the map view.zoomOptionalSets initial zoom level of the map.maptypeOptionalDefines type of map tiles to load.languageOptionalDefines the language to use for UI elements and for the display of labels on map tiles.regionOptionalDefines the appropriate borders and labels to display, based on geo-political sensitivities.\nYouTube Embed\n\nThe YouTubeEmbed component can be used to load and display a YouTube embed. This component loads\nfaster by using lite-youtube-embed under the\nhood.\napp/page.jsimport { YouTubeEmbed } from '@next/third-parties/google'\n\nexport default function Page() {\n  return <YouTubeEmbed videoid=\"ogfYd705cRs\" height={400} params=\"controls=0\" />\n}\n\nOptions\n\nNameTypeDescriptionvideoidRequiredYouTube video id.widthOptionalWidth of the video container. Defaults to autoheightOptionalHeight of the video container. Defaults to autoplaylabelOptionalA visually hidden label for the play button for accessibility.paramsOptionalThe video player params defined here.  Params are passed as a query param string.  Eg: params=\"controls=0&start=10&end=30\"styleOptionalUsed to apply styles to the video container.PreviousVitestNextUpgradingWas this helpful?\n\nsupported.Send"}
