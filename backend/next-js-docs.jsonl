{"url": "https://nextjs.org/docs/app/getting-started/installation", "content": "stallationInstallation\nSystem requirements\n\nBefore you begin, make sure your system meets the following requirements:\n\nNode.js 18.18 or later.\nmacOS, Windows (including WSL), or Linux.\n\nAutomatic installation\n\nThe quickest way to create a new Next.js app is using create-next-app, which sets up everything automatically for you. To create a project, run:\nTerminalnpx create-next-app@latest\nOn installation, you'll see the following prompts:\nTerminalWhat is your project named? my-app\nWould you like to use TypeScript? No / Yes\nWould you like to use ESLint? No / Yes\nWould you like to use Tailwind CSS? No / Yes\nWould you like your code inside a `src/` directory? No / Yes\nWould you like to use App Router? (recommended) No / Yes\nWould you like to use Turbopack for `next dev`?  No / Yes\nWould you like to customize the import alias (`@/*` by default)? No / Yes\nWhat import alias would you like configured? @/*\nAfter the prompts, create-next-app will create a folder with your project name and install the required dependencies.\nManual installation\n\nTo manually create a new Next.js app, install the required packages:\npnpmnpmyarnbunTerminalpnpm i next@latest react@latest react-dom@latest\n\nThen, add the following scripts to your package.json file:\npackage.json{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  }\n}\nThese scripts refer to the different stages of developing an application:\n\nnext dev: Starts the development server.\nnext build: Builds the application for production.\nnext start: Starts the production server.\nnext lint: Runs ESLint.\n\nCreate the app directory\n\nNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.Create an app folder. Then, inside app, create a layout.tsx file. This file is the root layout. It's required and must contain the <html> and <body> tags.app/layout.tsxTypeScriptJavaScriptTypeScriptexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}Create a home page app/page.tsx with some initial content:app/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() {\n  return <h1>Hello, Next.js!</h1>\n}Both layout.tsx and page.tsx will be rendered when the user visits the root of your application (/).\nGood to know:\n\nIf you forget to create the root layout, Next.js will automatically create this file when running the development server with next dev.\nYou can optionally use a src folder in the root of your project to separate your application's code from configuration files.\n\nCreate the public folder (optional)\n\nCreate a public folder at the root of your project to store static assets such as images, fonts, etc. Files inside public can then be referenced by your code starting from the base URL (/).\nYou can then reference these assets using the root path (/). For example, public/profile.png can be referenced as /profile.png:\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Image from 'next/image'\n\nexport default function Page() {\n  return <Image src=\"/profile.png\" alt=\"Profile\" width={100} height={100} />\n}\n\nRun the development server\n\nRun npm run dev to start the development server.\nVisit http://localhost:3000 to view your application.\nEdit the app/page.tsx file and save it to see the updated result in your browser.\n\nSet up TypeScript\n\nMinimum TypeScript version: v4.5.2\n\nNext.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to .ts / .tsx and run next dev. Next.js will automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options.\nIDE Plugin\n\nNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.You can enable the plugin in VS Code by:\nOpening the command palette (Ctrl/\u2318 + Shift + P)\nSearching for \"TypeScript: Select TypeScript Version\"\nSelecting \"Use Workspace Version\"\n\nSee the TypeScript reference page for more information.\nSet up ESLint\n\nNext.js comes with built-in ESLint. It automatically installs the necessary packages and configures the proper settings when you create a new project with create-next-app.\nTo manually add ESLint to an existing project, add next lint as a script to package.json:\npackage.json{\n  \"scripts\": {\n    \"lint\": \"next lint\"\n  }\n}\nThen, run npm run lint and you will be guided through the installation and configuration process.\nTerminalnpm run lint\nYou'll see a prompt like this:\n\n? How would you like to configure ESLint?\n\u276f Strict (recommended)\nBase\nCancel\n\nStrict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.\nBase: Includes Next.js' base ESLint configuration.\nCancel: Skip configuration. Select this option if you plan on setting up your own custom ESLint configuration.\n\nIf Strict or Base are selected, Next.js will automatically install eslint and eslint-config-next as dependencies in your application and create an .eslintrc.json file in the root of your project that includes your selected configuration.\nYou can now run next lint every time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build (next build). Errors will fail the build, while warnings will not.\nSee the ESLint Plugin page for more information.\nSet up Absolute Imports and Module Path Aliases\n\nNext.js has in-built support for the \"paths\" and \"baseUrl\" options of tsconfig.json and jsconfig.json files.\nThese options allow you to alias project directories to absolute paths, making it easier and cleaner to import modules. For example:\n// Before\nimport { Button } from '../../../components/button'\n\n// After\nimport { Button } from '@/components/button'\nTo configure absolute imports, add the baseUrl configuration option to your tsconfig.json or jsconfig.json file. For example:\ntsconfig.json or jsconfig.json{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\"\n  }\n}\nIn addition to configuring the baseUrl path, you can use the \"paths\" option to \"alias\" module paths.\nFor example, the following configuration maps @/components/* to components/*:\ntsconfig.json or jsconfig.json{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\",\n    \"paths\": {\n      \"@/styles/*\": [\"styles/*\"],\n      \"@/components/*\": [\"components/*\"]\n    }\n  }\n}\nEach of the \"paths\" are relative to the baseUrl location.PreviousGetting StartedNextProject StructureWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/project-structure", "content": "oject StructureProject structure and organizationThis page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project.\nFolder and file conventions\n\nTop-level folders\n\nTop-level folders are used to organize your application's code and static assets.\n\nappApp RouterpagesPages RouterpublicStatic assets to be servedsrcOptional application source folder\nTop-level files\n\nTop-level files are used to configure your application, manage dependencies, run middleware, integrate monitoring tools, and define environment variables.\nNext.jsnext.config.jsConfiguration file for Next.jspackage.jsonProject dependencies and scriptsinstrumentation.tsOpenTelemetry and Instrumentation filemiddleware.tsNext.js request middleware.envEnvironment variables.env.localLocal environment variables.env.productionProduction environment variables.env.developmentDevelopment environment variables.eslintrc.jsonConfiguration file for ESLint.gitignoreGit files and folders to ignorenext-env.d.tsTypeScript declaration file for Next.jstsconfig.jsonConfiguration file for TypeScriptjsconfig.jsonConfiguration file for JavaScript\nRouting Files\n\nlayout.js .jsx .tsxLayoutpage.js .jsx .tsxPageloading.js .jsx .tsxLoading UInot-found.js .jsx .tsxNot found UIerror.js .jsx .tsxError UIglobal-error.js .jsx .tsxGlobal error UIroute.js .tsAPI endpointtemplate.js .jsx .tsxRe-rendered layoutdefault.js .jsx .tsxParallel route fallback pageNested routes\n\nfolderRoute segmentfolder/folderNested route segmentDynamic routes\n\n[folder]Dynamic route segment[...folder]Catch-all route segment[[...folder]]Optional catch-all route segmentRoute Groups and private folders\n\n(folder)Group routes without affecting routing_folderOpt folder and all child segments out of routingParallel and Intercepted Routes\n\n@folderNamed slot(.)folderIntercept same level(..)folderIntercept one level above(..)(..)folderIntercept two levels above(...)folderIntercept from rootMetadata file conventions\n\nApp icons\n\nfavicon.icoFavicon fileicon.ico .jpg .jpeg .png .svgApp Icon fileicon.js .ts .tsxGenerated App Iconapple-icon.jpg .jpeg, .pngApple App Icon fileapple-icon.js .ts .tsxGenerated Apple App IconOpen Graph and Twitter images\n\nopengraph-image.jpg .jpeg .png .gifOpen Graph image fileopengraph-image.js .ts .tsxGenerated Open Graph imagetwitter-image.jpg .jpeg .png .gifTwitter image filetwitter-image.js .ts .tsxGenerated Twitter imageSEO\n\nsitemap.xmlSitemap filesitemap.js .tsGenerated Sitemaprobots.txtRobots filerobots.js .tsGenerated Robots file\n\nOrganizing your project\n\nNext.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.Component hierarchy\n\nThe components defined in special files are rendered in a specific hierarchy:\nlayout.js\ntemplate.js\nerror.js (React error boundary)\nloading.js (React suspense boundary)\nnot-found.js (React error boundary)\npage.js or nested layout.js\nThe components are rendered recursively in nested routes, meaning the components of a route segment will be nested inside the components of its parent segment.Colocation\n\nIn the app directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.However, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file is added to a route segment.And, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client.This means that project files can be safely colocated inside route segments in the app directory without accidentally being routable.\nGood to know: While you can colocate your project files in app you don't have to. If you prefer, you can keep them outside the app directory.\nPrivate folders\n\nPrivate folders can be created by prefixing a folder with an underscore: _folderNameThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.Since files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for:\nSeparating UI logic from routing logic.\nConsistently organizing internal files across a project and the Next.js ecosystem.\nSorting and grouping files in code editors.\nAvoiding potential naming conflicts with future Next.js file conventions.\n\nGood to know:\n\nWhile not a framework convention, you might also consider marking files outside private folders as \"private\" using the same underscore pattern.\nYou can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of an underscore): %5FfolderName.\nIf you don't use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming conflicts.\n\nRoute groups\n\nRoute groups can be created by wrapping a folder in parenthesis: (folderName)This indicates the folder is for organizational purposes and should not be included in the route's URL path.Route groups are useful for:\nOrganizing routes by site section, intent, or team. e.g. marketing pages, admin pages, etc.\nEnabling nested layouts in the same route segment level:\n\nCreating multiple nested layouts in the same segment, including multiple root layouts\nAdding a layout to a subset of routes in a common segment\n\nsrc folder\n\nNext.js supports storing application code (including app) inside an optional src folder. This separates application code from project configuration files which mostly live in the root of a project.Examples\n\nThe following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project.\nGood to know: In our examples below, we're using components and lib folders as generalized placeholders, their naming has no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc.\nStore project files outside of app\n\nThis strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing purposes.Store project files in top-level folders inside of app\n\nThis strategy stores all application code in shared folders in the root of the app directory.Split project files by feature or route\n\nThis strategy stores globally shared application code in the root app directory and splits more specific application code into the route segments that use them.Organize routes without affecting the URL path\n\nTo organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g. (marketing) or (shop)).Even though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by adding a layout.js file inside their folders.Opting specific segments into a layout\n\nTo opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout).Opting for loading skeletons on a specific route\n\nTo apply a loading skeleton via a loading.js file to a specific route, create a new route group (e.g., /(overview)) and then move your loading.tsx inside that route group.Now, the loading.tsx file will only apply to your dashboard \u2192 overview page instead of all your dashboard pages without affecting the URL path structure.Creating multiple root layouts\n\nTo create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.In the example above, both (marketing) and (shop) have their own root layout.PreviousInstallationNextLayouts and PagesWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/layouts-and-pages", "content": "youts and PagesLayouts and PagesNext.js uses file-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.\nCreating a page\n\nA page is UI that is rendered on a specific route. To create a page, add a page file inside the app directory and default export a React component. For example, to create an index page (/):\n\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() {\n  return <h1>Hello Next.js!</h1>\n}\n\nCreating a layout\n\nA layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.\nYou can define a layout by default exporting a React component from a layout file. The component should accept a children prop which can be a page or another layout.\nFor example, to create a layout that accepts your index page as child, add a layout file inside the app directory:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {/* Layout UI */}\n        {/* Place children where you want to render a page or nested layout */}\n        <main>{children}</main>\n      </body>\n    </html>\n  )\n}\n\nThe layout above is called a root layout because it's defined at the root of the app directory. The root layout is required and must contain html and body tags.\nCreating a nested route\n\nA nested route is a route composed of multiple URL segments. For example, the /blog/[slug] route is composed of three segments:\n\n/ (Root Segment)\nblog (Segment)\n[slug] (Leaf Segment)\n\nIn Next.js:\n\nFolders are used to define the route segments that map to URL segments.\nFiles (like page and layout) are used to create UI that is shown for a segment.\n\nTo create nested routes, you can nest folders inside each other. For example, to add a route for /blog, create a folder called blog in the app directory. Then, to make /blog publicly accessible, add a page.tsx file:\n\napp/blog/page.tsxTypeScriptJavaScriptTypeScript// Dummy imports\nimport { getPosts } from '@/lib/posts'\nimport { Post } from '@/ui/post'\n\nexport default async function Page() {\n  const posts = await getPosts()\n\n  return (\n    <ul>\n      {posts.map((post) => (\n        <Post key={post.id} post={post} />\n      ))}\n    </ul>\n  )\n}\n\nYou can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new [slug] folder inside blog and add a page file:\n\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptfunction generateStaticParams() {}\n\nexport default function Page() {\n  return <h1>Hello, Blog Post Page!</h1>\n}\n\nWrapping a folder name in square brackets (e.g. [slug]) creates a dynamic route segment which is used to generate multiple pages from data. e.g. blog posts, product pages, etc.\nNesting layouts\n\nBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children prop. You can nest layouts by adding layout inside specific route segments (folders).\nFor example, to create a layout for the /blog route, add a new layout file inside the blog folder.\n\napp/blog/layout.tsxTypeScriptJavaScriptTypeScriptexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <section>{children}</section>\n}\n\nIf you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).\nCreating a dynamic segment\n\nDynamic segments allow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.\nTo create a dynamic segment, wrap the segment (folder) name in square brackets: [segmentName]. For example, in the app/blog/[slug]/page.tsx route, the [slug] is the dynamic segment.\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexport default async function BlogPostPage({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await getPost(slug)\n\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  )\n}\n\nLearn more about Dynamic Segments.\nLinking between pages\n\nYou can use the <Link> component to navigate between routes. <Link> is a built-in Next.js component that extends the HTML <a> tag to provide prefetching and client-side navigation.\nFor example, to generate a list of blog posts, import <Link> from next/link and pass a href prop to the component:\napp/ui/post.tsxTypeScriptJavaScriptTypeScriptimport Link from 'next/link'\n\nexport default async function Post({ post }) {\n  const posts = await getPosts()\n\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.slug}>\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\n        </li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know: <Link> is the primary way to navigate between routes in Next.js. You can also use the useRouter hook for more advanced navigation.\nAPI ReferenceLearn more about the features mentioned in this page by reading the API Reference.Linking and NavigatingLearn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.layout.jsAPI reference for the layout.js file.page.jsAPI reference for the page.js file.Link ComponentEnable fast client-side navigation with the built-in `next/link` component.Dynamic SegmentsDynamic Route Segments can be used to programmatically generate route segments from dynamic data.PreviousProject StructureNextLinking and NavigatingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/layouts-and-pages", "content": "youts and PagesLayouts and PagesNext.js uses file-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.\nCreating a page\n\nA page is UI that is rendered on a specific route. To create a page, add a page file inside the app directory and default export a React component. For example, to create an index page (/):\n\napp/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() {\n  return <h1>Hello Next.js!</h1>\n}\n\nCreating a layout\n\nA layout is UI that is shared between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.\nYou can define a layout by default exporting a React component from a layout file. The component should accept a children prop which can be a page or another layout.\nFor example, to create a layout that accepts your index page as child, add a layout file inside the app directory:\n\napp/layout.tsxTypeScriptJavaScriptTypeScriptexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {/* Layout UI */}\n        {/* Place children where you want to render a page or nested layout */}\n        <main>{children}</main>\n      </body>\n    </html>\n  )\n}\n\nThe layout above is called a root layout because it's defined at the root of the app directory. The root layout is required and must contain html and body tags.\nCreating a nested route\n\nA nested route is a route composed of multiple URL segments. For example, the /blog/[slug] route is composed of three segments:\n\n/ (Root Segment)\nblog (Segment)\n[slug] (Leaf Segment)\n\nIn Next.js:\n\nFolders are used to define the route segments that map to URL segments.\nFiles (like page and layout) are used to create UI that is shown for a segment.\n\nTo create nested routes, you can nest folders inside each other. For example, to add a route for /blog, create a folder called blog in the app directory. Then, to make /blog publicly accessible, add a page.tsx file:\n\napp/blog/page.tsxTypeScriptJavaScriptTypeScript// Dummy imports\nimport { getPosts } from '@/lib/posts'\nimport { Post } from '@/ui/post'\n\nexport default async function Page() {\n  const posts = await getPosts()\n\n  return (\n    <ul>\n      {posts.map((post) => (\n        <Post key={post.id} post={post} />\n      ))}\n    </ul>\n  )\n}\n\nYou can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new [slug] folder inside blog and add a page file:\n\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptfunction generateStaticParams() {}\n\nexport default function Page() {\n  return <h1>Hello, Blog Post Page!</h1>\n}\n\nWrapping a folder name in square brackets (e.g. [slug]) creates a dynamic route segment which is used to generate multiple pages from data. e.g. blog posts, product pages, etc.\nNesting layouts\n\nBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their children prop. You can nest layouts by adding layout inside specific route segments (folders).\nFor example, to create a layout for the /blog route, add a new layout file inside the blog folder.\n\napp/blog/layout.tsxTypeScriptJavaScriptTypeScriptexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <section>{children}</section>\n}\n\nIf you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).\nCreating a dynamic segment\n\nDynamic segments allow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.\nTo create a dynamic segment, wrap the segment (folder) name in square brackets: [segmentName]. For example, in the app/blog/[slug]/page.tsx route, the [slug] is the dynamic segment.\napp/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexport default async function BlogPostPage({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await getPost(slug)\n\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  )\n}\n\nLearn more about Dynamic Segments.\nLinking between pages\n\nYou can use the <Link> component to navigate between routes. <Link> is a built-in Next.js component that extends the HTML <a> tag to provide prefetching and client-side navigation.\nFor example, to generate a list of blog posts, import <Link> from next/link and pass a href prop to the component:\napp/ui/post.tsxTypeScriptJavaScriptTypeScriptimport Link from 'next/link'\n\nexport default async function Post({ post }) {\n  const posts = await getPosts()\n\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.slug}>\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\n        </li>\n      ))}\n    </ul>\n  )\n}\n\nGood to know: <Link> is the primary way to navigate between routes in Next.js. You can also use the useRouter hook for more advanced navigation.\nAPI ReferenceLearn more about the features mentioned in this page by reading the API Reference.Linking and NavigatingLearn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.layout.jsAPI reference for the layout.js file.page.jsAPI reference for the page.js file.Link ComponentEnable fast client-side navigation with the built-in `next/link` component.Dynamic SegmentsDynamic Route Segments can be used to programmatically generate route segments from dynamic data.PreviousProject StructureNextLinking and NavigatingWas this helpful?\n\nsupported.Send"}
{"url": "https://nextjs.org/docs/app/getting-started/server-and-client-components", "content": "rver and Client ComponentsServer and Client ComponentsBy default, layouts and pages are Server Components, which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can use Client Components to layer in functionality.\nThis page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application.\nWhen to use Server and Client Components?\n\nThe client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case.\nUse Client Components when you need:\n\nState and event handlers. E.g. onClick, onChange.\nLifecycle logic. E.g. useEffect.\nBrowser-only APIs. E.g. localStorage, window, Navigator.geolocation, etc.\nCustom hooks.\n\nUse Server Components when you need:\n\nFetch data from databases or APIs close to the source.\nUse API keys, tokens, and other secrets without exposing them to the client.\nReduce the amount of JavaScript sent to the browser.\nImprove the First Contentful Paint (FCP), and stream content progressively to the client.\n\nFor example, the <Page> component is a Server Component that fetches data about a post, and passes it as props to the <LikeButton> which handles client-side interactivity.\napp/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport LikeButton from '@/app/ui/like-button'\nimport { getPost } from '@/lib/data'\n\nexport default async function Page({ params }: { params: { id: string } }) {\n  const post = await getPost(params.id)\n\n  return (\n    <div>\n      <main>\n        <h1>{post.title}</h1>\n        {/* ... */}\n        <LikeButton likes={post.likes} />\n      </main>\n    </div>\n  )\n}\n\napp/ui/like-button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useState } from 'react'\n\nexport default function LikeButton({ likes }: { likes: number }) {\n  // ...\n}\n\nHow do Server and Client Components work in Next.js?\n\nOn the server\n\nOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments (layouts and pages):\n\nServer Components are rendered into a special data format called the React Server Component Payload (RSC Payload).\nClient Components and the RSC Payload are used to prerender HTML.\n\nWhat is the React Server Component Payload (RSC)?\nThe RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:\n\nThe rendered result of Server Components\nPlaceholders for where Client Components should be rendered and references to their JavaScript files\nAny props passed from a Server Component to a Client Component\n\nOn the client (first load)\n\nThen, on the client:\n\nHTML is used to immediately show a fast non-interactive preview of the route to the user.\nRSC Payload is used to reconcile the Client and Server Component trees.\nJavaScript is used to hydrate Client Components and make the application interactive.\n\nWhat is hydration?\nHydration is React's process for attaching event handlers to the DOM, to make the static HTML interactive.\n\nSubsequent Navigations\n\nOn subsequent navigations:\n\nThe RSC Payload is prefetched and cached for instant navigation.\nClient Components are rendered entirely on the client, without the server-rendered HTML.\n\nExamples\n\nUsing Client Components\n\nYou can create a Client Component by adding the \"use client\" directive at the top of the file, above your imports.\napp/ui/counter.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useState } from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <div>\n      <p>{count} likes</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n\n\"use client\" is used to declare a boundary between the Server and Client module graphs (trees).\nOnce a file is marked with \"use client\", all its imports and child components are considered part of the client bundle. This means you don't need to add the directive to every component that is intended for the client.\nReducing JS bundle size\n\nTo reduce the size of your client JavaScript bundles, add 'use client' to specific interactive components instead of marking large parts of your UI as Client Components.\nFor example, the <Layout> component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. <Search /> is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component.\napp/layout.tsxTypeScriptJavaScriptTypeScript// Client Component\nimport Search from './search'\n// Server Component\nimport Logo from './logo'\n\n// Layout is a Server Component by default\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <>\n      <nav>\n        <Logo />\n        <Search />\n      </nav>\n      <main>{children}</main>\n    </>\n  )\n}\n\napp/ui/search.tsxTypeScriptJavaScriptTypeScript'use client'\n\nexport default function Search() {\n  // ...\n}\n\nPassing data from Server to Client Components\n\nYou can pass data from Server Components to Client Components using props.\napp/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport LikeButton from '@/app/ui/like-button'\nimport { getPost } from '@/lib/data'\n\nexport default async function Page({ params }: { params: { id: string } }) {\n  const post = await getPost(params.id)\n\n  return <LikeButton likes={post.likes} />\n}\n\napp/ui/like-button.tsxTypeScriptJavaScriptTypeScript'use client'\n\nexport default function LikeButton({ likes }: { likes: number }) {\n  // ...\n}\n\nAlternatively, you can stream data from a Server Component to a Client Component with the use Hook. See an example.\n\nGood to know: Props passed to Client Components need to be serializable by React.\n\nInterleaving Server and Client Components\n\nYou can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components.\nA common pattern is to use children to create a slot in a <ClientComponent>. For example, a <Cart> component that fetches data on the server, inside a <Modal> component that uses client state to toggle visibility.\napp/ui/modal.tsxTypeScriptJavaScriptTypeScript'use client'\n\nexport default function Modal({ children }: { children: React.ReactNode }) {\n  return <div>{children}</div>\n}\n\nThen, in a parent Server Component (e.g.<Page>), you can pass a <Cart> as the child of the <Modal>:\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Modal from './ui/modal'\nimport Cart from './ui/cart'\n\nexport default function Page() {\n  return (\n    <Modal>\n      <Cart />\n    </Modal>\n  )\n}\n\nIn this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree.\nContext providers\n\nReact context is commonly used to share global state like the current theme. However, React context is not supported in Server Components.\nTo use context, create a Client Component that accepts children:\napp/theme-provider.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { createContext } from 'react'\n\nexport const ThemeContext = createContext({})\n\nexport default function ThemeProvider({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n}\n\nThen, import it into a Server Component (e.g. layout):\napp/layout.tsxTypeScriptJavaScriptTypeScriptimport ThemeProvider from './theme-provider'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        <ThemeProvider>{children}</ThemeProvider>\n      </body>\n    </html>\n  )\n}\n\nYour Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context.\n\nGood to know: You should render providers as deep as possible in the tree \u2013 notice how ThemeProvider only wraps {children} instead of the entire <html> document. This makes it easier for Next.js to optimize the static parts of your Server Components.\n\nThird-party components\n\nWhen using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected.\nFor example, the <Carousel /> can be imported from the acme-carousel package. This component uses useState, but it doesn't yet have the \"use client\" directive.\nIf you use <Carousel /> within a Client Component, it will work as expected:\napp/gallery.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { useState } from 'react'\nimport { Carousel } from 'acme-carousel'\n\nexport default function Gallery() {\n  const [isOpen, setIsOpen] = useState(false)\n\n  return (\n    <div>\n      <button onClick={() => setIsOpen(true)}>View pictures</button>\n      {/* Works, since Carousel is used within a Client Component */}\n      {isOpen && <Carousel />}\n    </div>\n  )\n}\n\nHowever, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know <Carousel /> is using client-only features.\nTo fix this, you can wrap third-party components that rely on client-only features in your own Client Components:\napp/carousel.tsxTypeScriptJavaScriptTypeScript'use client'\n\nimport { Carousel } from 'acme-carousel'\n\nexport default Carousel\n\nNow, you can use <Carousel /> directly within a Server Component:\napp/page.tsxTypeScriptJavaScriptTypeScriptimport Carousel from './carousel'\n\nexport default function Page() {\n  return (\n    <div>\n      <p>View pictures</p>\n      {/*  Works, since Carousel is a Client Component */}\n      <Carousel />\n    </div>\n  )\n}\n\nAdvice for Library Authors\nIf you\u2019re building a component library, add the \"use client\" directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers.\nIt's worth noting some bundlers might strip out \"use client\" directives. You can find an example of how to configure esbuild to include the \"use client\" directive in the React Wrap Balancer and Vercel Analytics repositories.\n\nPreventing environment poisoning\n\nJavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function:\nlib/data.tsTypeScriptJavaScriptTypeScriptexport async function getData() {\n  const res = await fetch('https://external-service.com/data', {\n    headers: {\n      authorization: process.env.API_KEY,\n    },\n  })\n\n  return res.json()\n}\n\nThis function contains an API_KEY that should never be exposed to the client.\nIn Next.js, only environment variables prefixed with NEXT_PUBLIC_ are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string.\nAs a result, even though getData() can be imported and executed on the client, it won't work as expected.\nTo prevent accidental usage in Client Components, you can use the server-only package.\nThen, import the package into a file that contains server-only code:\nlib/data.jsimport 'server-only'\n\nexport async function getData() {\n  const res = await fetch('https://external-service.com/data', {\n    headers: {\n      authorization: process.env.API_KEY,\n    },\n  })\n\n  return res.json()\n}\nNow, if you try to import the module into a Client Component, there will be a build-time error.\nThe corresponding client-only package can be used to mark modules that contain client-only logic like code that accesses the window object.\nIn Next.js, installing server-only or client-only is optional. However, if your linting rules flag extraneous dependencies, you may install them to avoid issues.\n\npnpmnpmyarnbunTerminalpnpm add server-only\n\nNext.js handles server-only and client-only imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js.\nNext.js also provides its own type declarations for server-only and client-only, for TypeScript configurations where noUncheckedSideEffectImports is active.Next StepsLearn more about the APIs mentioned in this page.use clientLearn how to use the use client directive to render a component on the client.PreviousLinking and NavigatingNextPartial PrerenderingWas this helpful?\n\nsupported.Send"}
